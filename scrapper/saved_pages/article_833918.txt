<!DOCTYPE html>

<html lang="ru">
<head>
<title>JPA Entity. Загрузи меня не полностью / Хабр</title>
</head>
<body>
<div id="mount"><div data-async-called="true" id="app"><div class="tm-layout__wrapper"><!--[--><!-- --><div></div><!-- --><header class="tm-header" data-test-id="header"><div class="tm-page-width"><!--[--><div class="tm-header__container"><!-- --><span class="tm-header__logo-wrap"><a class="tm-header__logo tm-header__logo_hl-ru tm-header__logo" href="/ru/"><svg class="tm-svg-img tm-header__icon" height="16" width="16"><title>Хабр</title><use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a><span class="tm-header__beta-sign" style="display:none;">β</span></span><!--[--><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><!--[--><button class="tm-header__dropdown-toggle"><svg class="tm-svg-img tm-header__icon tm-header__icon_dropdown" height="16" width="16"><title>Открыть список</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#arrow-down"></use></svg></button><!--]--></div><!-- --></div><a class="tm-header__become-author-btn" href="/ru/sandbox/start/">Как стать автором</a><div class="tm-feature tm-feature tm-feature_variant-inline tm-header__feature"><!-- --></div><!-- --><!--]--><!-- --></div><!--]--></div></header><div class="tm-layout"><div class="tm-page-progress-bar"></div><div class="tm-base-layout__header_is-sticky tm-base-layout__header" data-menu-sticky="true"><div class="tm-page-width"><!--[--><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/feed/">Моя лента</a><!--]--><!--[--><a class="tm-main-menu__item" href="/ru/articles/">Все потоки</a><!--]--><!--[--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/develop/">Разработка</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/admin/">Администрирование</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/design/">Дизайн</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/management/">Менеджмент</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/marketing/">Маркетинг</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/popsci/">Научпоп</a><!--]--><!--]--></nav></div></div><div class="tm-header-user-menu tm-base-layout__user-menu"><a class="tm-header-user-menu__item tm-header-user-menu__search" data-test-id="search-button" href="/ru/search/"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark" height="24" width="24"><title>Поиск</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#search"></use></svg></a><!-- --><!-- --><div class="tm-header-user-menu__item tm-header-user-menu__write"><div><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_write tm-header-user-menu__icon_dark" height="24" width="24"><title>Написать публикацию</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#write"></use></svg></div><!-- --></div><!--[--><div class="tm-header-user-menu__item"><button class="tm-header-user-menu__toggle" data-test-id="user-menu-settings"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_dark" height="24" width="24"><title>Настройки</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#page-settings"></use></svg></button></div><a class="tm-header-user-menu__item" href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/companies/spring_aio/articles/833918/&amp;hl=ru" rel="nofollow"><!--[--><button class="btn btn_solid btn_small tm-header-user-menu__login" type="button"><!--[-->Войти<!--]--></button><!--]--></a><!--]--><!-- --><!--teleport start--><!--teleport end--><!-- --></div></div><!--]--></div></div><!-- --><div class="tm-page-width"><!--[--><!--]--></div><main class="tm-layout__container"><div class="tm-page" companyname="spring_aio" data-async-called="true" hl="ru" style="--0c809c5a:16px;--a086013e:100%;--7c457026:0;"><div class="tm-page-width"><!--[--><div class="tm-page__header"><!--[--><!--]--></div><div class="tm-page__wrapper"><div class="tm-page__main_has-sidebar tm-page__main"><div class="pull-down"><!-- --><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg class="tm-svg-img pull-down__icon pull-down__arrow" height="24" width="24"><title>Обновить</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#pull-arrow"></use></svg></div></div><!--[--><!--[--><div class="tm-article-presenter"><!--[--><!--[--><!-- --><div class="tm-company-profile-card tm-company-article__profile-card"><div class="tm-company-card tm-company-profile-card__info"><div class="tm-company-card__header"><a class="tm-company-card__avatar" href="/ru/companies/spring_aio/profile/"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" height="48" src="//habrastorage.org/getpro/habr/company/8f1/91a/458/8f191a4584b8fab12d15af23e447a1d5.png" width="48"/></div></a><!--[--><!-- --><div class="tm-counter-container tm-company-card__rating"><div class="tm-counter-container__header"><!--[--><!--[--><!--]--><div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating"><!-- --><div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score"><!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">77.73</span></span><!--]--></div><!-- --></div><!--]--></div><div class="tm-counter-container__footer"><!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]--></div></div><!-- --><!--]--></div><div class="tm-company-card__info"><a class="tm-company-card__name" href="/ru/companies/spring_aio/profile/"><span>Spring АйО</span></a><!-- --></div></div><div class="tm-company-profile-card__buttons"><div class="tm-button-follow tm-company-profile-card__button tm-company-profile-card__button_follow"><!-- --><button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button></div><!-- --><!-- --><!-- --></div></div><!-- --><!--]--><!--]--><div class="tm-article-presenter__body" data-test-id="article-body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><!--[--><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><!--[--><div class="tm-article-presenter__header"><!--[--><!--]--><div class="tm-article-snippet tm-article-snippet tm-article-presenter__snippet"><!--[--><!--]--><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a class="tm-user-info__userpic" data-test-id="user-info-pic" href="/ru/users/spring_aio/" title="spring_aio"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" height="24" src="//habrastorage.org/r/w48/getpro/habr/avatars/8e0/5e8/a1c/8e05e8a1c5fd4560f661efb2cb00e77e.png" width="24"/></div></a><span class="tm-user-info__user tm-user-info__user_appearance-default" data-test-id="user-info-description"><a class="tm-user-info__username" href="/ru/users/spring_aio/">spring_aio <!-- --></a><!--[--><span class="tm-article-datetime-published"><time datetime="2024-08-14T10:29:31.000Z" title="2024-08-14, 13:29">14  авг  2024 в 13:29</time></span><!--]--></span></span></div><!-- --></div><h1 class="tm-title tm-title_h1" data-test-id="articleTitle" lang="ru"><span>JPA Entity. Загрузи меня не полностью</span></h1><div class="tm-article-snippet__stats" data-test-id="articleStats"><div class="tm-article-complexity tm-article-complexity_complexity-low"><span class="tm-svg-icon__wrapper tm-article-complexity__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Уровень сложности</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#complexity-low"></use></svg></span><span class="tm-article-complexity__label">Простой</span></div><div class="tm-article-reading-time"><span class="tm-svg-icon__wrapper tm-article-reading-time__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Время на прочтение</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#clock"></use></svg></span><span class="tm-article-reading-time__label">16 мин</span></div><span class="tm-icon-counter tm-data-icons__item"><svg class="tm-svg-img tm-icon-counter__icon" height="24" width="24"><title>Количество просмотров</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-views"></use></svg><span class="tm-icon-counter__value" title="9556">9.6K</span></span></div><div class="tm-publication-hubs__container" data-test-id="articleHubsList"><div class="tm-publication-hubs"><!--[--><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/companies/spring_aio/articles/"><!--[--><span>Блог компании Spring АйО</span><!-- --><!--]--></a></span><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/hubs/programming/"><!--[--><span>Программирование</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/hubs/java/"><!--[--><span>Java</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/hubs/kotlin/"><!--[--><span>Kotlin</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><!--]--></div></div><!-- --><!-- --><!-- --></div></div><!--[--><!-- --><div class="tm-article-body" data-gallery-root="" lang="ru"><div><!--[--><!--]--></div><div id="post-content-body"><div><div class="article-formatted-body article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>JPA часто подвергается критике за невозможность загружать сущности частично, что на самом деле является большим заблуждением. Spring Data JPA и Hibernate включают в себя множество инструментов по частичной загрузке сущностей. </p><p>Команда <a href="https://t.me/+QmrKn0wA8CdkNjAy">Spring АйО</a> подготовила статью, в которой рассмотрела имеющиеся в Spring Data JPA инструменты для частичной загрузки сущностей, а также разобрала их особенности и corner-кейсы. Давайте попробуем рассмотреть все способы такой частичной загрузки сущностей на примере основных способов взаимодействия с Hibernate в Spring приложениях:</p><ul><li><p>Spring Data JPA</p></li><li><p>EntityManager</p></li><li><p>Criteria API</p></li></ul><p>Также существует проект <a href="https://github.com/jakartaee/data">Jakarta Data</a>, который активно развивается. Однако на момент написания этой статьи вышла только первая стабильная версия 1.0.0. Рассматривать его не станем, пока не накопим достаточное количество реальных использований.  </p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/35e/8d6/bd5/35e8d6bd500bb63a86a1fbd3608387e8.png" height="444" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/35e/8d6/bd5/35e8d6bd500bb63a86a1fbd3608387e8.png" width="780"/></figure><h3>Интересует ли эта проблема сообщество</h3><p>После очередного холивара в одном из Telegram-каналов про Java на тему того, как плох JPA и Hibernate в частности, как он неоптимизированно выполняет запросы и как много грузится лишних данных, я решил немного углубиться в эти вопросы и попытаться встать на защиту упомянутого выше стэка, отправившись в путешествие на Stackoverflow. Сделаем поиск по тегу <code>[spring-data-jpa]</code> и отсортируем вопросы по популярности. Мы увидим, что вопрос <a href="https://stackoverflow.com/questions/22007341/spring-jpa-selecting-specific-columns">Spring JPA selecting specific columns</a>  находится на шестом месте.<br/>В этой статье мы постараемся ответить на этот вопрос максимально широко: рассмотрим не только самые простые случаи с базовыми атрибутами, но также окунемся и в мир JPA-ассоциаций.</p><h3>Задача</h3><p>В <a href="https://github.com/comru/jpa-partial-load">проекте</a> будет рассматриваться следующая модель данных:</p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/5a6/cc9/76c/5a6cc976c104ca2209aee23b0911f222.png" height="762" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/5a6/cc9/76c/5a6cc976c104ca2209aee23b0911f222.png" width="1788"/></figure><p>Нашей задачей является загрузка нескольких базовый полей + ToOne (в нашем случае это атрибут author, ссылающийся на сущность Post) ассоциации для каждого способа частичной загрузки. Предположим, мы хотим получить все статьи, заголовок которых содержит некоторый текст, причем поиск не чувствителен к регистру, т.е. contains with ignore case. Итого выгружаем <code>Post: id, slug, title; User(author): id, username</code>.</p><p>Проверять результат мы будем в соответствующих <a href="https://github.com/comru/jpa-partial-load/tree/main/src/test/java/io/amplicode/jpa/repository">тестах</a>, итоговые запросы будут видны в консоли: лог, в котором отобразится SQL-запрос, сгенерированный силами Hibernate.</p><h3>Тестовые данные</h3><p>Создадим две записи <code>Post</code>, проинициализировав базовые поля и привязав авторов. Сервис в котором создаются и удаляются данные <a href="https://github.com/comru/jpa-partial-load/blob/main/src/test/java/io/amplicode/jpa/InitTestDataService.java">InitTestDataService</a>.</p><h3>toOne</h3><p>Всего был найден 21 способ частичной загрузки для поставленной нами задачи.</p><p>Эти способы включают в себя разные подходы написания запроса:</p><ul><li><p>Spring Data Repository derived-methods</p></li><li><p>Spring Data Repository query-methods</p></li><li><p>Entity Manager</p></li><li><p>Criteria API</p></li></ul><p>Тестовый класс в котором можно увидеть все тесты с комментариями - <a href="https://github.com/comru/jpa-partial-load/blob/main/src/test/java/io/amplicode/jpa/repository/ToOneTest.java">ToOneTest</a>.</p><h3>Предисловие</h3><p>Стоит внести небольшую ясность перед нашим экспериментом. <code>Derived</code> методы — это методы, автоматически реализуемые фреймворком на основе их имен, т.е. без явного указания аннотации <a href="https://docs.spring.io/spring-data/commons/reference/repositories/query-methods.html">@Query</a>. Поскольку мы не указываем запрос явно, а значит у нас отсутствует возможность указать, какие именно атрибуты нам требуется загрузить, у нас есть всего один способ указания конкретных атрибутов для загрузки - это <strong>projection</strong>.<br/><br/>Сами же проекции бывают двух видов: <strong>основанные на интерфейсах </strong>(Interface-based Projections) и <strong>на классах </strong>(Class-based Projections). <strong>Interface-based Projections </strong>в свою очередь можно поделить на открытые и закрытые.</p><p>В <a href="https://docs.spring.io/spring-data/jpa/reference/repositories/projections.html#projections.interfaces.closed">закрытых</a> проекциях геттеры объявляются явно:</p><pre><code class="java">interface NamesOnly {
  String getFirstname();
  String getLastname();
}</code></pre><p>В случае <a href="https://docs.spring.io/spring-data/jpa/reference/repositories/projections.html#projections.interfaces.open">открытых проекций</a> значение геттеров интерфейсов могут высчитываться на основе SpEL выражения:</p><pre><code class="java">interface NamesOnly {  
    @Value("#{target.firstname + ' ' + target.lastname}")
    String getFullName();
}  </code></pre><p>Их мы рассматривать не будем, т.к. в <a href="https://docs.spring.io/spring-data/cassandra/reference/repositories/projections.html#:~:text=Spring%20Data%20cannot%20apply%20query%20execution%20optimizations%20in%20this%20case%2C%20because%20the%20SpEL%20expression%20could%20use%20any%20attribute%20of%20the%20aggregate%20root.">документации явно сказано</a>, что для них оптимизация запроса производиться не будет:</p><blockquote><p>Spring Data cannot apply query execution optimizations in this case, because the SpEL expression could use any  attribute of the aggregate root.</p></blockquote><p>Для загрузки <strong>ToOne</strong>-ассоциаций ставим задачу проверить два варианта с <strong>flatten</strong> (плоскими) атрибутами, с <strong>nested</strong> (вложенным) классом, а также с <strong>Tuple</strong> и <strong>Map</strong>. </p><p>Для <strong>ToMany</strong>  имеет смысл проверять работу с плоскими атрибутами, однако в этом случае загрузка будет со сложностью n*m. Это означает, что наш эксперимент подходит и для ToOne, и для ToMany, однако записей в случае с ToMany<strong> </strong>выгрузится больше.</p><p>Почти все, что мы рассмотрим для ToOne, справедливо и для ToMany, однако Hibernate не способен мапить коллекционные атрибуты на DTO/Projection, в связи с чем Hibernate в силах выполнить только HQL, и для кейса с ToMany будет возвращено декартово произведение n*m. Иначе говоря, кроме выгрузки и мапинга результата нам придется еще схлопывать дубликаты записей. Если эта тема будет интересна, мы обязательно напишем дополнительный пост про частичную загрузку и с ToMany-ассоциациями. Однако с несколькими примерами можно ознакомиться в <a href="https://github.com/comru/jpa-partial-load">проекте</a> в тестовом классе <a href="https://github.com/comru/jpa-partial-load/blob/main/src/test/java/io/amplicode/jpa/repository/ToManyTest.java">ToManyTest</a>. </p><p>Все, что будет рассмотрено далее, отлично подойдет и для <strong>Embbeded</strong>-кейса, поэтому отдельно его рассматривать не имеет смысла</p><h3>Derived-methods</h3><h4>Interface-based flat projection</h4><p>Для данного кейса будем в качестве проекции использовать отдельно взятый интерфейс. Пожалуй, данный подход можно отнести к базовой концепции в контексте использования проекций.</p><p>Объявим в нашем репозитории метод:</p><pre><code class="java">public interface PostRepository extends JpaRepository&lt;Post, Long&gt; {  
	&lt;T&gt; List&lt;T&gt; findAllByTitleContainsIgnoreCase(String title, Class&lt;T&gt; projection);
}</code></pre><p>Исключительно в целях удобства метод будет заточен под <a href="https://www.baeldung.com/spring-data-jpa-projections#dynamic-projections">динамическую проекцию</a>, чтобы не писать под каждую проекцию отдельный метод.<br/>Создадим класс проекции:</p><pre><code class="java"> public interface PostWithAuthorFlat {  
    Long getId();  
    String getSlug();  
    String getTitle();  
    Long getAuthorId();  
    String getAuthorUsername();  
}</code></pre><p>Протестируем решение, написав тест. Попробуем немного углубиться в работу проекции, воспользовавшись дебагом. Ставим breakpoint на нашем тесте:</p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/7ec/4f3/22a/7ec4f322a5dc3d29bfc8063ca8781ab2.png" height="490" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/7ec/4f3/22a/7ec4f322a5dc3d29bfc8063ca8781ab2.png" width="1958"/></figure><p>Завершающим звеном по получению данных является работа класса TupleBackedMap, сам объект Tuple же будет содержать необходимую нам информацию. Чтобы посмотреть цепочку по получению данных, обозначим границу установкой breakpoint в методе получения значения из TupleBackedMap <code>(org.springframework.data.jpa.repository.query.AbstractJpaQuery.TupleConverter.TupleBackedMap)</code>:</p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/e9f/6a4/6eb/e9f6a46eb3593c4f697fb9d969342921.png" height="1038" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/e9f/6a4/6eb/e9f6a46eb3593c4f697fb9d969342921.png" width="1868"/></figure><p> И наблюдаем следующую цепочку по получению данных:</p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/3b1/583/39a/3b158339a53f896ee5054a88059a359d.png" height="666" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/3b1/583/39a/3b158339a53f896ee5054a88059a359d.png" width="1150"/></figure><p>Полученный прокси сначала дойдет до метода <code>invoke</code> класса <code>MapAccessingMethodInterceptor</code>:</p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/e22/093/332/e220933326bb1a1f4bafb5cdc2970990.png" height="1204" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/e22/093/332/e220933326bb1a1f4bafb5cdc2970990.png" width="1980"/></figure><p>В результате чего мы получаем объект класса <code>Accessor</code>, который предоставляет доступ к самому <code>propertyName</code>. Преобразованная строка будет передана в <code>TupleBackedMap</code>. Далее полученное значение будет нам представлено из всеми нам знакомого объекта <code>Tuple</code>:</p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/114/4a5/a4b/1144a5a4b4209a20809c180ffcfba573.png" height="1019" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/114/4a5/a4b/1144a5a4b4209a20809c180ffcfba573.png" width="1738"/></figure><p>Сам же объект <code>Tuple</code> в свою очередь предоставляет нам полный доступ к ключу и значению.</p><p>Всю схему можно описать так:<br/>Под проекцией лежит прокси, в прокси - прокси, в прокси лежит некий target-объект, который является объектом <code>TupleBackedMap</code>.</p><p>Или так:<br/> <em>«На море на океане есть остров, на том острове дуб стоит, под дубом сундук зарыт, в сундуке — заяц, в зайце — утка, в утке — яйцо»</em> в яйце игла — смерть Кощея!</p><p>Подводя итоги данного кейса можно сделать вывод о том, что Spring предоставляет конвертер, который сам маппит <code>Tuple</code> на проекцию. Этот подход отлично подходит для решения поставленной нами задачи, ведь в запросе присутствуют только те колонки, которые указаны в проекции:</p><pre><code class="sql">Hibernate: 
    select
        p1_0.id,
        p1_0.slug,
        p1_0.title,
        p1_0.author_id,
        a1_0.username 
    from
        posts p1_0 
    left join
        users a1_0 
            on a1_0.id=p1_0.author_id 
    where
        upper(p1_0.title) like upper(?) escape '\'</code></pre><h4>Interface-based nested interface projections</h4><p>Следующим способом для решения нашей задачи могло быть решение, основанное на использовании проекции, имеющей внутри себя еще одну проекцию, для получения данных об авторе поста. Это и есть тот самый <strong>nested</strong> кейс.</p><pre><code class="java">public interface PostWithAuthorNested {  
    Long getId();  
    String getSlug();  
    String getTitle();  
    UserPresentation getAuthor();  
}</code></pre><p>Для базовых полей будет загружено только то, что указано в проекции. Мы получим необходимые нам <code>id</code>, <code>slug</code>, <code>title</code>. Однако для вложенного объекта будут загружены абсолютно все поля, что конечно, противоречит нашим требованиям. Проблема известна и даже имеет <a href="https://github.com/spring-projects/spring-data-jpa/issues/3352">официальный ответ</a>. </p><p>Стоит обратить внимание, что <code>PostWithAuthorNested</code> это все тот же прокси вокруг <code>TupleBackedMap</code>, а вот сам вложенный объект <code>UserPresentation</code> является прокси непосредственно вокруг самой сущности <code>User</code>:</p><pre><code class="sql">Hibernate: 
    select
        p1_0.id,
        p1_0.slug,
        p1_0.title,
        a1_0.id,
        a1_0.bio,
        a1_0.email,
        a1_0.image,
        a1_0.password,
        a1_0.token,
        a1_0.username 
    from
        posts p1_0 
    left join
        users a1_0 
            on a1_0.id=p1_0.author_id 
    where
        upper(p1_0.title) like upper(?) escape '\'</code></pre><p>Подводя итоги: подход работает неоптимально, поставленную нами задачу не решает.</p><h4>Class-based flat projections</h4><p>Идем далее и следующим вариантом решения задачи по частичной выгрузке полей сущности можно отметить использования в качестве проекции отдельного <code>Record</code>-класса (метод репозитория остается прежним)</p><pre><code class="java">public record PostWithAuthorFlatDto(Long id,  
                                    String slug,  
                                    String title,  
                                    Long authorId,  
                                    String authorUsername) {  
}</code></pre><p>Сам тест:</p><pre><code class="java">@Test  
void derivedMethodClassFlatPrj() {  
    var posts = postRepository.findAllByTitleContainsIgnoreCase(
      "spring",
      PostWithAuthorFlatDto.class
    );  
    assertEquals(1, posts.size());  
    var postFirst = posts.getFirst();  
    assertEquals(POST1_SLUG, postFirst.slug());  
    assertEquals(POST1_AUTHOR_NAME, postFirst.authorUsername());  
}</code></pre><p><strong>Spring Data JPA</strong> передает result type в Hibernate, который в свою очередь производит мапинг. На плечах Spring'а только лишь грамотное формирование <strong>JPQL</strong> запроса. Этот вариант нас полностью устраивает.</p><p>Результат:</p><pre><code class="sql">Hibernate: 
    select
        p1_0.id,
        p1_0.slug,
        p1_0.title,
        p1_0.author_id,
        a1_0.username 
    from
        posts p1_0 
    left join
        users a1_0 
            on a1_0.id=p1_0.author_id 
    where
        upper(p1_0.title) like upper(?) escape '\'</code></pre><h4>Class-based nested dto projections</h4><p>Идем хорошим темпом, однако стоило бы рассмотреть и негативные, нерабочие сценарии, чтобы лучше понять логику работы с проекциями. Создадим такой record класс с вложенной DTO-проекцией:</p><pre><code class="java">public record PostWithAuthorNestedDto(Long id,  
                                      String slug,  
                                      String title,  
                                      UserPresentationDto author) {  
}</code></pre><p>Вроде, все должно заработать, однако при попытке "взлететь" мы получим ошибку:</p><pre><code class="java">Cannot set field 'author' to instantiate 'io.spring.jpa.projection.PostWithAuthorNestedDto'</code></pre><p>О чем нас <a href="https://docs.spring.io/spring-data/jpa/reference/repositories/projections.html#projections.dtos">предупреждали</a>:</p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/751/e8b/0a2/751e8b0a2f3d8c3c326de3544dbc7383.png" height="952" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/751/e8b/0a2/751e8b0a2f3d8c3c326de3544dbc7383.png" width="1588"/></figure><p>В данном случае вся логика лежит на стороне Hibernate, Spring Data здесь не оказывает никакого влияния.</p><h3>Class-based nested entity projections</h3><p>Мы также можем указать для record целую сущность. Однако данный способ обязывает нас получить все поля из вложенной сущности. Придется положить в копилку еще один негативный кейс. Не наш вариант, но знать про это, кажется, было бы полезно:</p><pre><code class="java">public record PostWithAuthorEntity(Long id,  
                                   String slug,  
                                   String title,  
                                   User author) {  
}</code></pre><p>Получаем:</p><pre><code class="sql">Hibernate: 
    select
        p1_0.id,
        p1_0.slug,
        p1_0.title,
        a1_0.id,
        a1_0.bio,
        a1_0.email,
        a1_0.image,
        a1_0.password,
        a1_0.token,
        a1_0.username 
    from
        posts p1_0 
    left join
        users a1_0 
            on a1_0.id=p1_0.author_id 
    where
        upper(p1_0.title) like upper(?) escape '\'</code></pre><h3>Query-methods</h3><p>А теперь давайте рассмотрим способ, когда мы можем явно в запросе указывать, какие атрибуты нам нужно выгрузить, т.е. к <code>Query</code>-методам. В этом случае мы сразу же решаем одну немаловажную задачу - явно указываем то, что хотим получить. В нашей зоне ответственности остается только лишь правильно реализовать маппинг.</p><h4>Interface-based flat projections</h4><p>Spring богат своими возможностями, потому он, например, может обработать <code>JPQL</code> который мы написали самостоятельно, а затем и вовсе сформировать <code>TupleBackedMap</code>.</p><p>Данный способ интересен тем, что нам ничего не мешает написать обычный <code>JPQL</code> запрос, а в качестве возвращаемого значения указать проекцию:</p><pre><code class="java">@Query("""
            select  a.id as id,
                    a.slug as slug,
                    a.title as title,
                    a.author.id as authorId,
                    a.author.username as authorUsername
            from Post a
            where lower(a.title) like lower(concat('%', ?1, '%'))""")
List&lt;PostWithAuthorFlat&gt; findAllPostWithAuthorFlat(String title);</code></pre><p>Сама проекция:</p><pre><code class="java">public interface PostWithAuthorFlat {  
    Long getId();  
    String getSlug();  
    String getTitle();  
    Long getAuthorId();  
    String getAuthorUsername();  
}</code></pre><p>Ключевым моментом формирования <code>JPQL</code>-запроса является требование по указанию алиасов: они обязательно должны быть такими же, как свойства в проекции, иначе магии маппинга не произойдет. Кстати, как и ожидалось, под интерфейсом лежит все та же прокси с <code>TupleBackedMap</code>.</p><p>Сам результат:</p><pre><code class="sql">Hibernate: 
    select
        p1_0.id,
        p1_0.slug,
        p1_0.title,
        p1_0.author_id,
        a1_0.username 
    from
        posts p1_0 
    join
        users a1_0 
            on a1_0.id=p1_0.author_id 
    where
        lower(p1_0.title) like lower(('%'||?||'%')) escape ''</code></pre><h4>Class-based flat projections</h4><p>Данный способ по частичному получению данных является базовым для Hibernate. Нужно всего лишь создать класс-проекцию с конструктором. После чего инициализируем этот класс прямо в JPQL. Алиасы в этом случае нам не требуются. Прокси в этом случае также не создается, используется только DTO-проекция.</p><pre><code class="java">@Query("""
            select
                new io.spring.jpa.projection.PostWithAuthorFlatDto(
                    a.id, 
                    a.slug, 
                    a.title, 
                    a.author.id, 
                    a.author.username
                ) 
            from Post a
            where lower(a.title) like lower(concat('%', ?1, '%'))""")
List&lt;PostWithAuthorFlatDto&gt; findAllPostWithAuthorFlatDto(String title);</code></pre><p>Проекция:</p><pre><code class="java">public record PostWithAuthorFlatDto(Long id,  
                                    String slug,  
                                    String title,  
                                    Long authorId,  
                                    String authorUsername) {  
}</code></pre><p>Тест:</p><pre><code class="java">@Test  
void queryMethodClassFlat() {  
    var posts = postRepository.findAllPostWithAuthorFlatDto("spring");  
    assertEquals(1, posts.size());  
    PostWithAuthorFlatDto post = posts.getFirst();  
    assertEquals(POST1_SLUG, post.slug());  
    assertEquals(POST1_AUTHOR_NAME, post.authorUsername());  
}</code></pre><p>Успех:</p><pre><code class="sql">Hibernate: 
    select
        p1_0.id,
        p1_0.slug,
        p1_0.title,
        p1_0.author_id,
        a1_0.username 
    from
        posts p1_0 
    join
        users a1_0 
            on a1_0.id=p1_0.author_id 
    where
        lower(p1_0.title) like lower(('%'||?||'%')) escape ''</code></pre><h4>Class-based nested class projections</h4><p>Важной особенностью метода с использованием вложенных проекций является то, что можно делать сколько угодно вложенностей. Поскольку мы используем HQL, то <a href="https://docs.jboss.org/hibernate/orm/6.6/userguide/html_single/Hibernate_User_Guide.html#hql-select-new">можем инициализировать нашу DTO</a> как нам удобно. В том числе и создавая новые DTO объекты внутри DTO.</p><p>Напишем такой метод:</p><pre><code class="java">@Query("""
            select
                new io.spring.jpa.projection.PostWithAuthorNestedDto(
                    a.id,
                    a.slug,
                    a.title,
                    new io.spring.jpa.projection.UserPresentationDto(
                        a.author.id,
                        a.author.username
                    )
                )
            from Post a
            where lower(a.title) like lower(concat('%', ?1, '%'))""")
List&lt;PostWithAuthorNestedDto&gt; findAllPostWithAuthorNestedDto(String title);</code></pre><p>А также пару проекций под него: проекцию для самого поста, внутри нее объявляем проекцию для автора.</p><pre><code class="java">public record PostWithAuthorNestedDto(Long id,  
                                      String slug,  
                                      String title,  
                                      UserPresentationDto author) {  
}</code></pre><p>Проекция для автора:</p><pre><code class="java">public record UserPresentationDto(Long id, String username) {  
}</code></pre><p>Напишем простой тест:</p><pre><code class="java">@Test  
void queryMethodClassNested() {  
    var posts = postRepository.findAllPostWithAuthorNestedDto("spring");  
    assertEquals(1, posts.size());  
    PostWithAuthorNestedDto post = posts.getFirst();  
    assertEquals(POST1_SLUG, post.slug());  
    assertEquals(POST1_AUTHOR_NAME, post.author().username());  
}</code></pre><p>Непосредственно запрос:</p><pre><code class="sql">Hibernate: 
    select
        p1_0.id,
        p1_0.slug,
        p1_0.title,
        p1_0.author_id,
        a1_0.username 
    from
        posts p1_0 
    join
        users a1_0 
            on a1_0.id=p1_0.author_id 
    where
        lower(p1_0.title) like lower(('%'||?||'%')) escape ''</code></pre><h4>Tuple, Object[], List&lt;&gt;, Map</h4><p>Hibernate также позволяет возвращать select expression, которые мы можем написать в виде <code>Object[]</code>, <code>Tuple</code>, <code>Map</code>, <code>List</code>. Подробно останавливаться на каждом не станем, разница лишь в возвращаемом значении:</p><pre><code class="java">@Query("""
            select
                a.id as id,
                a.slug as slug,
                a.title as title
            from Post a
            where lower(a.title) like lower(concat('%', ?1, '%'))""")
List&lt;Tuple&gt; findAllTupleBasic(String title);</code></pre><pre><code class="java">@Query("""
            select
                a.id as id,
                a.slug as slug,
                a.title as title
            from Post a
            where lower(a.title) like lower(concat('%', ?1, '%'))""")
List&lt;Object[]&gt; findAllObjectWithAuthor(String title);</code></pre><pre><code class="java">@Query("""
            select
                a.id as id,
                a.slug as slug,
                a.title as title
            from Post a
            where lower(a.title) like lower(concat('%', ?1, '%'))""")
List&lt;List&lt;?&gt;&gt; findAllListWithAuthor(String title);</code></pre><pre><code class="java">@Query("""
            select
                a.id as id,
                a.slug as slug,
                a.title as title
            from Post a
            where lower(a.title) like lower(concat('%', ?1, '%'))""")
List&lt;Map&lt;String, Object&gt;&gt; findAllMapWithAuthor(String title);</code></pre><p>P.S.: для <code>Derived</code>-методов аналогично можно указывать такие же возвращаемые значения. Spring Data все возьмет на себя <span class="habrahidden">и выгрузит все поля.</span></p><h3>Entity Manager</h3><p>Все способы, описанные для <code>@Query</code>, работают и в <strong>Entity Manager</strong>, кроме <strong>Interface-based projection</strong>, так как  Interface-based projection является концепцией самого Spring, сам же Hibernate ничего про нее не знает.</p><h3>Criteria API</h3><p><strong>Criteria API</strong> используется для создания типобезопасных и гибких запросов к базе данных на языке Java. Сам по себе Criteria API является "type-safe alternative to HQL". </p><p>Мы будем использовать стандартные функции <code>CriteriaBuilder</code>, однако, если возникнет потребность в дополнительных функциях из <a href="https://docs.jboss.org/hibernate/orm/6.4/introduction/html_single/Hibernate_Introduction.html#criteria-queries">HibernateCriteriaBuilder</a>, приведенные ниже примеры будут актуальны и для него.</p><p>Для начала нам нужно указать атрибуты, которые мы собираемся передать в запрос. Имя атрибута мы можем очень удобно указать с помощью константы, которая была сгенерирована автоматически с использованием зависимости:</p><pre><code class="json">dependencies {
	annotationProcessor 'org.hibernate:hibernate-jpamodelgen:{version}'
}</code></pre><pre><code class="java">var idPath = owner.&lt;Long&gt;get(Post_.ID);  
var slugPath = owner.&lt;String&gt;get(Post_.SLUG);  
var titlePath = owner.&lt;String&gt;get(Post_.TITLE);  
var authorIdPath = owner.get(Post_.AUTHOR).&lt;Long&gt;get(User_.ID);  
var authorUsernamePath = owner.get(Post_.AUTHOR).&lt;String&gt;get(User_.USERNAME);</code></pre><p>В последней документации Hibernate данный способ используется во всех примерах, из чего можно сделать вывод, что это "тихая" рекомендация.</p><p>По итогу константы всегда будут перегенерированы и всегда будут находиться в актуальном состоянии, в результате чего мы выигрываем в безопасности и надежности приложения.</p><h4>DTO</h4><p>Итак, мы объявили path'ы, остается лишь написать запрос, закинуть результат в коллекцию, после чего убедиться в жизнеспособности подхода:</p><pre><code class="java">@Test
void criteriaDto() {
  var cb = em.getCriteriaBuilder();
  var query = cb.createQuery(PostWithAuthorFlatDto.class);
  
  var owner = query.from(Post.class);

  var idPath = owner.&lt;Long&gt;get(Post_.ID);
  var slugPath = owner.&lt;String&gt;get(Post_.SLUG);
  var titlePath = owner.&lt;String&gt;get(Post_.TITLE);
  var authorIdPath = owner.get(Post_.AUTHOR).&lt;Long&gt;get(User_.ID);
  var authorUsernamePath = owner.get(Post_.AUTHOR).&lt;String&gt;get(User_.USERNAME);

  query.multiselect(idPath, slugPath, titlePath, authorIdPath, authorUsernamePath)
           .where(cb.like(cb.lower(titlePath), "%spring%"));

  var resultList = em.createQuery(query).getResultList();

  for (PostWithAuthorFlatDto post : resultList) {
      assertEquals(POST1_SLUG, post.slug());
      assertEquals(POST1_AUTHOR_NAME, post.authorUsername());
  }
}</code></pre><p>Проекция:</p><pre><code class="java">public record PostWithAuthorFlatDto(Long id,  
                                    String slug,  
                                    String title,  
                                    Long authorId,  
                                    String authorUsername) {  
}</code></pre><p>В данном случае мы возвращаем множество элементов (атрибутов) и мапим их на DTO, которое указываем при создании query</p><pre><code class="java">jakarta.persistence.criteria.CriteriaBuilder#createQuery(java.lang.Class)</code></pre><p>Успешный успех:</p><pre><code class="sql">Hibernate: 
    select
        p1_0.id,
        p1_0.slug,
        p1_0.title,
        p1_0.author_id,
        a1_0.username 
    from
        posts p1_0 
    join
        users a1_0 
            on a1_0.id=p1_0.author_id 
    where
        lower(p1_0.title) like ? escape ''</code></pre><p>К минусам работы через DTO можно отнести только то, что сохраняется риск случайного рефактиринга DTO. В этом случае мы поймаем ошибку, что не нашлось, например, подходящего конструктора. Для решения этой проблемы рассмотрим вариант с использованием <code>Tuple</code>.</p><h4>Tuple</h4><p>В случае с <code>Tuple</code> инициализация объекта происходит ручным способом и мы попросту не сможем создать сам объект и, конечно, поймаем ошибку ещё до запуска приложения на этапе компиляции.</p><p>Представляем вашему вниманию, пожалуй, самый безопасный способ выполнения частичных запросов:</p><pre><code class="java">@Test
void criteriaTuple() {
  var cb = em.getCriteriaBuilder();
  var query = cb.createTupleQuery();

  var owner = query.from(Post.class);

  var idPath = owner.&lt;Long&gt;get(Post_.ID);
  var slugPath = owner.&lt;String&gt;get(Post_.SLUG);
  var titlePath = owner.&lt;String&gt;get(Post_.TITLE);
  var authorIdPath = owner.get(Post_.AUTHOR).&lt;Long&gt;get(User_.ID);
  var authorUsernamePath = owner.get(Post_.AUTHOR).&lt;String&gt;get(User_.USERNAME);

  query.select(cb.tuple(idPath, slugPath, titlePath, authorIdPath, authorUsernamePath))
         .where(cb.like(cb.lower(titlePath), "%spring%"));

  var resultList = em.createQuery(query).getResultList().stream()
           .map(tuple -&gt; new PostWithAuthorNestedDto(
                  tuple.get(idPath),
                  tuple.get(slugPath),
                  tuple.get(titlePath),
                  new UserPresentationDto(
                           tuple.get(authorIdPath),
                           tuple.get(authorUsernamePath)
                  )
            )).toList();

  for (PostWithAuthorNestedDto post : resultList) {
      assertEquals(POST1_SLUG, post.slug());
      assertEquals(POST1_AUTHOR_NAME, post.author().username());
  }
}</code></pre><p>Сами проекции:</p><pre><code class="java">public record PostWithAuthorNestedDto(Long id,  
                                      String slug,  
                                      String title,  
                                      UserPresentationDto author) {  
}</code></pre><pre><code class="java">public record UserPresentationDto(Long id, String username) {  
}</code></pre><p>После формирования Path мы достаем значения из <code>Tuple</code> и складываем в наше DTO (если не требуются дополнительные манипуляции с выборкой). Таким образом мы получаем не только "type-safe alternative to HQL", но и безопасную и контролируемую работу с результатом нашего запроса. Концепция очень похожа на работу с <code>Tuple</code> в библиотеке <a href="http://querydsl.com/static/querydsl/3.4.2/reference/html/ch03s02.html">QueryDSL</a>.</p><p>В результате получаем запрос, удовлетворяющий наши требования. Остальные примеры для Criteria API рассмотрены вот <a href="https://github.com/comru/jpa-partial-load/blob/main/src/test/java/io/amplicode/jpa/repository/BasicAttributesTest.java">тут</a>. Работает все максимально типично относительно случаев, рассмотренных выше.</p><h4>CriteriaDefinition в Hibernate 6.3+</h4><p><strong>UPD</strong>: Начиная с версии 6.3, Hibernate позволяет нам использовать вспомогательный класс <code>CriteriaDefinition</code> для уменьшения многословности criteria-запросов.</p><p>Пример с <strong>DTO</strong> будет выглядеть следующим образом:</p><pre><code class="java">@Test
void criteriaDefinitionDto() {
    var query = new CriteriaDefinition&lt;&gt;(em, PostWithAuthorFlatDto.class) {{
    var owner = from(Post.class);

    var titlePath = owner.&lt;String&gt;get(Post_.TITLE);
    var authorPath = owner.get(Post_.AUTHOR);

    multiselect(
              owner.get(Post_.ID),
              owner.get(Post_.SLUG),
              titlePath,
              authorPath.get(User_.ID),
              authorPath.get(User_.USERNAME)
      ).where(like(lower(titlePath), "%spring%"));
  }};

    var resultList = em.createQuery(query).getResultList();

    assertEquals(1, resultList.size());
    for (var post : resultList) {
        assertEquals(POST1_SLUG, post.slug());
        assertEquals(POST1_AUTHOR_NAME, post.authorUsername());
    }
}</code></pre><p>Пример с <strong>Tuple</strong>:</p><pre><code class="java">@Test
void criteriaDefinitionTuple() {
    var query = new CriteriaDefinition&lt;&gt;(em, Tuple.class) {};
    var owner = query.from(Post.class);

    var idPath = owner.&lt;Long&gt;get(Post_.ID);
    var slugPath = owner.&lt;String&gt;get(Post_.SLUG);
    var titlePath = owner.&lt;String&gt;get(Post_.TITLE);
    var authorPath = owner.get(Post_.AUTHOR);
    var authorIdPath = authorPath.&lt;Long&gt;get(User_.ID);
    var authorUsernamePath = authorPath.&lt;String&gt;get(User_.USERNAME);

    query.where(query.like(query.lower(titlePath), "%spring%"))
            .multiselect(idPath, slugPath, titlePath, authorIdPath, authorUsernamePath);

    var resultList = em.createQuery(query).getResultList().stream()
            .map(tuple -&gt; new PostWithAuthorNestedDto(
                    tuple.get(idPath),
                    tuple.get(slugPath),
                    tuple.get(titlePath),
                    new UserPresentationDto(
                            tuple.get(authorIdPath),
                            tuple.get(authorUsernamePath)
                    )
            )).toList();

    assertEquals(1, resultList.size());
  
    for (var post : resultList) {
        assertEquals(POST1_SLUG, post.slug());
        assertEquals(POST1_AUTHOR_NAME, post.author().username());
    }
}</code></pre><p>Ознакомиться с результатами работы всех способов вы можете в <a href="https://github.com/comru/jpa-partial-load">репозитории</a>.</p><p>Кстати, до 6 версии Hibernate <code>Criteria API</code>-запросы к сущностям выполнялись <a href="https://vladmihalcea.com/hibernate-sqm-semantic-query-model/">следующим образом</a>:</p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/974/399/b0b/974399b0bef5b0e727c746c5b5553bf0.png" height="676" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/974/399/b0b/974399b0bef5b0e727c746c5b5553bf0.png" width="1149"/></figure><p>Criteria API генерировал обычный JPQL, Hibernate же в свою очередь проводил его анализ в соответствии с грамматикой HQL, только затем генерировался SQL-запрос.</p><p>Начиная с Hibernate 6 Criteria API сразу преобразуется в SQM:</p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/d3d/07c/12e/d3d07c12e54d389bac24f0ea34a22107.png" height="676" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/d3d/07c/12e/d3d07c12e54d389bac24f0ea34a22107.png" width="1570"/></figure><p>Подробнее про SQM можно почитать <a href="https://vladmihalcea.com/hibernate-sqm-semantic-query-model/">тут</a>.</p><h4>Выводы</h4><ol><li><p>Если мы пишем HQL/JPQL query, то мы контролируем запрос и возвращаем только то что мы хотим. Вопрос только в том, как мапить.</p></li><li><p>Если мы пишем HQL/JPQL всегда можно вернуть <code>Tuple</code> или <code>Map</code> и помапить с него на DTO.</p></li><li><p>"Использовать ли repository derived method?" -  каждый решает сам. В простых случаях и HQL будет простым, в сложных - длина имени метода будет стремиться выйти за пределы нашей солнечной системы. В рамках решаемых задач для этого проекта, конкретно для частичной выгрузки данных, repository derived method выглядит самым небезопасным. Мы не можем контролировать запрос, а HQL может поменяться из-за изменения DTO/Projection или самой Entity.</p></li><li><p>Когда мы работаем с <code>Tuple</code> , очень удобным решением является использование библиотеки hibernate-jpamodelgen, что позволяет нам пользоваться автосгенерированными константами. В последней документации Hibernate данный способ используется во всех примерах, можно сказать, что это "тихая" рекомендация. Также, используя эти константы, легко создавать jakarta.persistence.criteria.Path для Criteria API.</p></li><li><p>Когда мы пишем Query в Spring Data и используем DTO, по дефолту будут валидироваться выражения с DTO: будут проверены как типы, так и количество аргументов в конструкторе. А самое главное - никакой прокси-магии.</p></li><li><p>Не знаете что вернуть? Верните <code>Tuple</code>. Это очень удобно.</p></li><li><p>HQL + Class-Based Projection, он же DTO, он же select new class конструкция работают всегда, включая вложенные классы.</p></li><li><p>Для ToMany, при выгрузки данных в виде Projection/DTO/Tuple нам придется решать вопрос о мердже дублирующихся данных.</p></li></ol><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/10a/d75/0d1/10ad750d1120b5865791de847bb44c6e.png" height="412" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/10a/d75/0d1/10ad750d1120b5865791de847bb44c6e.png" width="1920"/></figure><p>Присоединяйтесь к русскоязычному сообществу разработчиков на Spring Boot в телеграм — <a href="https://t.me/+oBwACbkvJ19iODAy">Spring АйО</a>, чтобы быть в курсе последних новостей из мира разработки на Spring Boot и всего, что с ним связано.</p><p>Ждем всех, <a href="https://t.me/+oBwACbkvJ19iODAy">присоединяйтесь</a>! </p><p></p></div></div></div><!-- --><!-- --></div><!-- --><!-- --></div><!--]--><!-- --><div class="tm-article-presenter__meta" data-test-id="article-meta-links"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[java]"><span>java</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[kotlin]"><span>kotlin</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[spring]"><span>spring</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[spring+boot]"><span>spring boot</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[hibernate]"><span>hibernate</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[jpa]"><span>jpa</span></a><!--]--></li><!--]--><!-- --></ul></div><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/companies/spring_aio/articles/"><!--[--><span>Блог компании Spring АйО</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/hubs/programming/"><!--[--><span>Программирование</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/hubs/java/"><!--[--><span>Java</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/hubs/kotlin/"><!--[--><span>Kotlin</span><!--]--></a><!--]--></li><!--]--><!-- --></ul></div></div><!-- --><!--]--></article><!--]--></div><!-- --></div><div class="tm-article-sticky-panel" data-test-id="article-sticky-panel" style=""><div class="tm-data-icons tm-data-icons tm-data-icons_space-big tm-article-sticky-panel__icons" data-test-id="article-stats-icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon tm-votes-meter__icon_appearance-article" height="24" width="24"><title>Всего голосов 17: ↑16 и ↓1</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-rating"></use></svg><span class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating tm-votes-meter__value" data-test-id="votes-meter-value" title="Всего голосов 17: ↑16 и ↓1">+15</span></div><!--teleport start--><!--teleport end--><!-- --></div><!-- --><!-- --><button class="bookmarks-button tm-data-icons__item" title="Добавить в закладки" type="button"><span class="tm-svg-icon__wrapper bookmarks-button__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Добавить в закладки</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-favorite"></use></svg></span><span class="bookmarks-button__counter" title="Количество пользователей, добавивших публикацию в закладки">81</span></button><div class="tm-sharing tm-data-icons__item" title="Поделиться"><button class="tm-sharing__button" type="button"><svg class="tm-sharing__icon" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z" fill="currentColor"></path></svg></button><!--teleport start--><!--teleport end--></div><div class="tm-article-comments-counter-link tm-data-icons__item" title="Читать комментарии"><a class="tm-article-comments-counter-link__link" data-test-id="counter-comments" href="/ru/companies/spring_aio/articles/833918/comments/"><!--[--><svg class="tm-svg-img tm-article-comments-counter-link__icon" height="24" width="24"><title>Комментарии</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value">14</span><!--]--></a><!-- --></div><!--[--><!--[--><!--[--><!-- --><!--]--><!--]--><!--]--><!--teleport start--><!--teleport end--><!-- --></div></div></div><!--[--><!--]--><div class="tm-article-presenter__footer"><!--[--><!--[--><div class="tm-article-blocks"><!-- --><!--[--><section class="tm-block tm-block tm-block_spacing-bottom"><!-- --><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-balanced"><!--[--><div class="tm-article-author" data-test-id="article-author-info"><!--[--><!--[--><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a class="tm-company-snippet__logo-link" href="/ru/companies/spring_aio/profile/"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" height="40" src="//habrastorage.org/getpro/habr/company/8f1/91a/458/8f191a4584b8fab12d15af23e447a1d5.png" width="40"/></div></a><div class="tm-company-snippet__info"><a class="tm-company-snippet__title" data-test-id="company-title" href="/ru/companies/spring_aio/profile/"><span>Spring АйО</span></a><div class="tm-company-snippet__description">Компания</div></div></div><div class="tm-article-author__buttons"><!-- --><!-- --></div></div><div class="tm-article-author__company-contacts"><!--[--><a class="tm-article-author__contact" href="https://telegram.me/spring_aio" rel="noopener" target="_blank">Telegram</a><a class="tm-article-author__contact" href="https://www.springnow.ru" rel="noopener" target="_blank">Сайт</a><!--]--></div><div class="tm-article-author__separator"></div></div><!--]--><!--]--><div class="tm-user-card tm-user-card tm-user-card_variant-article tm-article-author__user-card" data-async-called="true"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a class="tm-user-card__userpic tm-user-card__userpic_size-40" href="/ru/users/spring_aio/"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" src="//habrastorage.org/getpro/habr/avatars/8e0/5e8/a1c/8e05e8a1c5fd4560f661efb2cb00e77e.png"/></div></a><div class="tm-user-card__meta"><div class="tm-counter-container tm-karma tm-karma" title=" 85 голосов "><div class="tm-counter-container__header"><!--[--><div class="karma-display positive" data-v-7635202e="">45</div><!-- --><!--]--></div><div class="tm-counter-container__footer"><!--[--><div class="tm-karma__text">Карма</div><!--teleport start--><!--teleport end--><!--]--></div></div><div class="tm-counter-container" title="Рейтинг пользователя"><div class="tm-counter-container__header"><!--[--><!--[--><!--]--><div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating"><!-- --><div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score_no-margin tm-votes-lever__score"><!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">105.9</span></span><!--]--></div><!-- --></div><!--]--></div><div class="tm-counter-container__footer"><!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]--></div></div></div></div></div><div class="tm-user-card__info tm-user-card__info_variant-article tm-user-card__info"><div class="tm-user-card__title tm-user-card__title_variant-article tm-user-card__title"><span class="tm-user-card__name tm-user-card__name_variant-article tm-user-card__name">Spring АйО</span><a class="tm-user-card__nickname tm-user-card__nickname tm-user-card__nickname_variant-article" href="/ru/users/spring_aio/"> @spring_aio</a><!-- --></div><p class="tm-user-card__short-info tm-user-card__short-info_variant-article tm-user-card__short-info" data-test-id="user-card-speciality">Главный по Spring</p></div></div><div class="tm-user-card__buttons tm-user-card__buttons_variant-article tm-user-card__buttons"><!-- --><div class="tm-user-card__button"><div class="tm-button-follow tm-user-card__button-follow"><!-- --><button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button></div></div><!-- --><div class="tm-user-card__button tm-user-card__button_write" data-test-id="user-card-conversations"><svg class="tm-svg-img tm-user-card__button-icon" height="16" width="16"><title>Отправить сообщение</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#mail"></use></svg></div><!-- --></div><!-- --></div><!-- --></div><!--]--></div><!--]--><!-- --></section><!-- --><!--[--><!--]--><!--]--><div class="tm-article-blocks__comments"><div class="tm-article-page-comments" id="publication-comments"><div><!--[--><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style" data-test-id="counter-comments" href="/ru/companies/spring_aio/articles/833918/comments/"><!--[--><svg class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted" height="24" width="24"><title>Комментарии</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted"> Комментарии 14 </span><!--]--></a><!-- --></div><!--]--></div></div></div><!--[--><!--[--><!--]--><section class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header tm-block__header_variant-borderless"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title tm-block__title_variant-large">Публикации</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-condensed-slim"><!--[--><!--[--><div class="tm-tabs tm-tabs"><div class=""><!--[--><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link_active tm-tabs__tab-link_slim tm-tabs__tab-link">Лучшие за сутки</button></span><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link_slim tm-tabs__tab-link">Похожие</button></span><!--]--></div><!-- --></div><div class="similar-and-daily__tab-view"><div class="placeholder-wrapper"><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="tm-placeholder-article-cards"><!--[--><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><!--]--></div><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --></div><!-- --></div><!--]--><!--]--></div><!--]--><!-- --></section><!--[--><!--]--><!-- --><!--[--><!--]--><!--]--></div><!--]--><!--]--></div></div><!--]--><!--]--></div></div><div class="tm-page__sidebar"><!--[--><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div><div class="tm-sexy-sidebar_initial tm-sexy-sidebar" style="margin-top:0px;"><!--[--><!--]--><!-- --><div class="tm-layout-sidebar__placeholder_initial"></div><!--[--><section class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Информация</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body"><!--[--><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">Сайт</dt><dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body"><!--[--><a class="tm-company-basic-info__link" href="https://t.me/spring_aio" target="_blank">t.me</a><!--]--></dd></dl><dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">Дата регистрации</dt><dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body"><!--[--><time datetime="2024-05-27T07:08:22.000Z" title="2024-05-27, 10:08">27  мая  2024</time><!--]--></dd></dl><!-- --><dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">Численность</dt><dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body"><!--[-->11–30 человек<!--]--></dd></dl><!-- --><!-- --></div><!--]--></div><!--]--><!-- --></section><div class="tm-company-widgets"><!--[--><!--]--></div><!-- --><!-- --><!--]--><!-- --></div></div><!--]--></div></div><!-- --><!--]--></div></div></main><!-- --></div><div class="tm-footer-menu"><div class="tm-page-width"><!--[--><div class="tm-footer-menu__container"><!--[--><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Ваш аккаунт</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/companies/spring_aio/articles/833918/&amp;hl=ru" rel="nofollow" target="_self">Войти</a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/companies/spring_aio/articles/833918/&amp;hl=ru" rel="nofollow" target="_self">Регистрация</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Разделы</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/articles/">Статьи</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/news/">Новости</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/hubs/">Хабы</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/companies/">Компании</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/users/">Авторы</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/sandbox/">Песочница</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Информация</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/help/">Устройство сайта</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/authors/codex/">Для авторов</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/companies/corpblogs/">Для компаний</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/docs/transparency/">Документы</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement/?hl=ru_RU" target="_blank">Соглашение</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/?hl=ru_RU" target="_blank">Конфиденциальность</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Услуги</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/corporate-blogs/" target="_blank">Корпоративный блог</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/advertising/" target="_blank">Медийная реклама</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/native-special/" target="_blank">Нативные проекты</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/education-programs/" target="_blank">Образовательные программы</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/hello-startup/" target="_blank">Стартапам</a></li><!--]--></ul></div></div><!--]--></div><!--]--></div></div><div class="tm-footer"><div class="tm-page-width"><!--[--><div class="tm-footer__container"><!-- --><div class="tm-footer__social"><!--[--><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Facebook</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Twitter</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>VK</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-vk"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Telegram</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Youtube</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://dzen.ru/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Яндекс Дзен</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-dzen"></use></svg></a><!--]--></div><!--teleport start--><!--teleport end--><button class="tm-footer__link"><!-- --> Настройка языка</button><a class="tm-footer__link" href="/ru/feedback/">Техническая поддержка</a><div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2025, </span><span class="tm-copyright__name"><a class="tm-copyright__link" href="https://company.habr.com/" rel="noopener" target="_blank">Habr</a></span></span></div></div><!--]--></div></div><!-- --><!--]--></div><!-- --></div></div>
<div id="overlays"><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--></div>
</body>
</html>
