<!DOCTYPE html>

<html lang="ru">
<head>
<title>Kotlin Coroutines под капотом / Хабр</title>
</head>
<body>
<div id="mount"><div data-async-called="true" id="app"><div class="tm-layout__wrapper"><!--[--><!-- --><div></div><!-- --><header class="tm-header" data-test-id="header"><div class="tm-page-width"><!--[--><div class="tm-header__container"><!-- --><span class="tm-header__logo-wrap"><a class="tm-header__logo tm-header__logo_hl-ru tm-header__logo" href="/ru/"><svg class="tm-svg-img tm-header__icon" height="16" width="16"><title>Хабр</title><use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a><span class="tm-header__beta-sign" style="display:none;">β</span></span><!--[--><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><!--[--><button class="tm-header__dropdown-toggle"><svg class="tm-svg-img tm-header__icon tm-header__icon_dropdown" height="16" width="16"><title>Открыть список</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#arrow-down"></use></svg></button><!--]--></div><!-- --></div><a class="tm-header__become-author-btn" href="/ru/sandbox/start/">Как стать автором</a><div class="tm-feature tm-feature tm-feature_variant-inline tm-header__feature"><!-- --></div><!-- --><!--]--><!-- --></div><!--]--></div></header><div class="tm-layout"><div class="tm-page-progress-bar"></div><div class="tm-base-layout__header_is-sticky tm-base-layout__header" data-menu-sticky="true"><div class="tm-page-width"><!--[--><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/feed/">Моя лента</a><!--]--><!--[--><a class="tm-main-menu__item" href="/ru/articles/">Все потоки</a><!--]--><!--[--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/develop/">Разработка</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/admin/">Администрирование</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/design/">Дизайн</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/management/">Менеджмент</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/marketing/">Маркетинг</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/popsci/">Научпоп</a><!--]--><!--]--></nav></div></div><div class="tm-header-user-menu tm-base-layout__user-menu"><a class="tm-header-user-menu__item tm-header-user-menu__search" data-test-id="search-button" href="/ru/search/"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark" height="24" width="24"><title>Поиск</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#search"></use></svg></a><!-- --><!-- --><div class="tm-header-user-menu__item tm-header-user-menu__write"><div><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_write tm-header-user-menu__icon_dark" height="24" width="24"><title>Написать публикацию</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#write"></use></svg></div><!-- --></div><!--[--><div class="tm-header-user-menu__item"><button class="tm-header-user-menu__toggle" data-test-id="user-menu-settings"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_dark" height="24" width="24"><title>Настройки</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#page-settings"></use></svg></button></div><a class="tm-header-user-menu__item" href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/articles/827866/&amp;hl=ru" rel="nofollow"><!--[--><button class="btn btn_solid btn_small tm-header-user-menu__login" type="button"><!--[-->Войти<!--]--></button><!--]--></a><!--]--><!-- --><!--teleport start--><!--teleport end--><!-- --></div></div><!--]--></div></div><!-- --><div class="tm-page-width"><!--[--><!--]--></div><main class="tm-layout__container"><div class="tm-page" data-async-called="true" hl="ru" style="--0c809c5a:16px;--a086013e:100%;--7c457026:0;"><div class="tm-page-width"><!--[--><!-- --><div class="tm-page__wrapper"><div class="tm-page__main_has-sidebar tm-page__main"><div class="pull-down"><!-- --><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg class="tm-svg-img pull-down__icon pull-down__arrow" height="24" width="24"><title>Обновить</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#pull-arrow"></use></svg></div></div><!--[--><!--[--><!-- --><div class="tm-article-presenter"><!--[--><!--]--><div class="tm-article-presenter__body" data-test-id="article-body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><!--[--><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><!--[--><div class="tm-article-presenter__header"><!--[--><!--]--><div class="tm-article-snippet tm-article-snippet tm-article-presenter__snippet"><!--[--><!--]--><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a class="tm-user-info__userpic" data-test-id="user-info-pic" href="/ru/users/DmitryTsyvtsyn/" title="DmitryTsyvtsyn"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" height="24" src="//habrastorage.org/r/w48/getpro/habr/avatars/db6/bea/5ea/db6bea5ea945afec3614eae955a8f2b1.jpeg" width="24"/></div></a><span class="tm-user-info__user tm-user-info__user_appearance-default" data-test-id="user-info-description"><a class="tm-user-info__username" href="/ru/users/DmitryTsyvtsyn/">DmitryTsyvtsyn <!-- --></a><!--[--><span class="tm-article-datetime-published"><time datetime="2024-07-11T09:43:55.000Z" title="2024-07-11, 12:43">11  июл  2024 в 12:43</time></span><!--]--></span></span></div><!-- --></div><h1 class="tm-title tm-title_h1" data-test-id="articleTitle" lang="ru"><span>Kotlin Coroutines под капотом</span></h1><div class="tm-article-snippet__stats" data-test-id="articleStats"><!-- --><div class="tm-article-reading-time"><span class="tm-svg-icon__wrapper tm-article-reading-time__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Время на прочтение</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#clock"></use></svg></span><span class="tm-article-reading-time__label">36 мин</span></div><span class="tm-icon-counter tm-data-icons__item"><svg class="tm-svg-img tm-icon-counter__icon" height="24" width="24"><title>Количество просмотров</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-views"></use></svg><span class="tm-icon-counter__value" title="27319">27K</span></span></div><div class="tm-publication-hubs__container" data-test-id="articleHubsList"><div class="tm-publication-hubs"><!--[--><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/hubs/android_dev/"><!--[--><span>Разработка под Android</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/hubs/kotlin/"><!--[--><span>Kotlin</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><!--]--></div></div><!-- --><!-- --><!-- --></div></div><!--[--><!-- --><div class="tm-article-body" data-gallery-root="" lang="ru"><div><!--[--><!--]--></div><div id="post-content-body"><div><div class="article-formatted-body article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/f9a/4c7/60d/f9a4c760d78f8bdc7e799e5f9892ed21.png" height="960" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/f9a/4c7/60d/f9a4c760d78f8bdc7e799e5f9892ed21.png" width="1280"/></figure><p>Вероятнее всего у вас спрашивали на собесе «как работают корутины под капотом?», вы не долго думая выбрасывали что‑то в стиле «там под капотом стейт‑машина, она определяет какая suspend функция будет выполняться», но понимали ли вы на самом деле о чем говорили? Возможно, но если честно я плохо понимал собственные ответы на такие вопросы и даже после десятка пройденных собесов у меня не было полноценной картины как работает внутрянка этой поистине невероятной библиотеки «сладкой асинхронщины».</p><p>Ладно, вступление и так получилось слишком затянутым, как это бывает в непрофессиональных фильмах от которых ждешь экшена половину хронометража, а потом получаешь унылые бои на светящихся палках, погнали короче разбираться!</p><h2>Знакомство с крутыми перцами: CoroutineContext и CoroutineScope</h2><p>Начнём с простенького примера:</p><pre><code class="kotlin">fun main() = runBlocking {
    // запускаем новую корутину
    launch {
        println("Hello, I'm a Kotlin coroutine, how are you?")
    }
}</code></pre><p>Пока нас интересует только функция <code>launch</code>, которая чаще всего используется для создания корутин, давайте провалимся в её исходники:</p><pre><code class="kotlin">// (1) launch является Kotlin Extension функцией для CoroutineScope
fun CoroutineScope.launch(
    // (2) контекст похож на HashMap'у, также хранит всякие штуки по ключу
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; Unit
): Job {
    // (3) при создании новой корутины контекст может быть изменён
    val newContext = newCoroutineContext(context)
    // к остальной части кода вернёмся позже
}</code></pre><p>Пройдёмся подробнее по пунктам, которые я выделил в комментах к коду:</p><p>1) Чтобы создать новую корутину нужно вызвать <code>launch</code> в пределах <code>CoroutineScope</code>, никак иначе, так было сделано чтобы корутина смогла получить контекст и пробрасывать его в дочерние корутины, если глянуть исходник <code>CoroutineScope</code>, то всё станет очевидным:</p><pre><code class="kotlin">interface CoroutineScope {
    val coroutineContext: CoroutineContext
}</code></pre><p>При запуске корутины берётся текущий контекст из <code>CoroutineScope</code> в котором был вызван <code>launch</code>.</p><p>2) <code>CoroutineContext</code> не является хэш-таблицей, а реализован на основе <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%BE%D0%B2%D1%89%D0%B8%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" rel="noopener noreferrer nofollow">паттерна Компоновщик</a>:</p><pre><code class="kotlin">/*
основной прикол паттерна Компоновщик: создать дерево 
из вложенных друг в друга объектов

чтобы реализовать такой паттерн нужен общий родитель, 
которым в данном случае является CoroutineContext 
*/


/*
обычные элементы контекста, такие как Job, CoroutineName и тд являются 
простыми объектами, которые не содержат другие или в терминах паттерна 
листовыми узлами 
*/
interface Element : CoroutineContext {
    val key: Key&lt;*&gt;

    /*
    для удобного доступа к элементам контекста переопределён оператор get
    
    это позволяет делать такие штуки: 
    coroutineContext[Job] вместо coroutineContext.get(Job)
    */
    override operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? =
        if (this.key == key) this as E else null
}

/*
помимо листовых узлов есть комплексные наборы данных, 
которые могут в себя включать другие такие наборы 
и простые объекты
*/
class CombinedContext(
    val left: CoroutineContext, 
    val element: CoroutineContext.Element
) : CoroutineContext {

    override fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? {
        /*
        логика простая: проверяем сначала простой объект,
        если ключи не совпадают, смотрим left, если он является 
        комплексным узлом CombinedContext, рекурсивно повторяем
        */
        var currentContext = this
        while (true) {
            currentContext.element[key]?.let { return it }
            val next = currentContext.left
            if (next is CombinedContext) {
                currentContext = next
            } else {
                return currentContext.get(key)
            }
        }
    }
  
}

class CoroutineName(val name: String) : CoroutineContext.Element {
    /*
    в качестве ключей для обычных элементов CoroutineContext 
    используются названия самих классов, что очень удобно

    поле key требует наследника Key&lt;*&gt; который определён ниже 
    через companion object, это работает даже если на первый взгляд 
    выглядит сомнительно и неоднозначно
    */
    override val key: Key&lt;*&gt; = CoroutineName 

    companion object Key : Key&lt;CoroutineName&gt;
}

fun main() {
    // Job и CoroutineDispatcher являются элементами CoroutineContext
    val combinedContext = CombinedContext(
        CombinedContext(
            Job(),
            Dispatchers.Default
        ), 
        CoroutineName("My name's Kotlin coroutine")
    )

    /*
    в итоге мы можем положить в CoroutineContext то что нужно корутинам:
    Job, CoroutineName, CoroutineDispatcher, CoroutineExceptionHandler и тд,
    а затем прокидывать контекст через CoroutineScope в сами корутины
    */
    val job = combinedContext[Job]
}</code></pre><p>3) При создании новой корутины можно изменить <code>CoroutineContext</code>:</p><pre><code class="kotlin">launch(CoroutineName("I'm a parent coroutine")) {
    launch(CoroutineName("I'm  child coroutine"))) {
        // ...
    }
}</code></pre><p>Логика работы в таком случае следующая: корутина получает текущий контекст из <code>CoroutineScope</code> и складывает его с контекстом, переданным в качестве параметра функции <code>launch</code>, таким образом дочерняя корутина из примера содержит другое имя.</p><p><strong>Важный момент:</strong> не все элементы <code>CoroutineContext</code> могут быть корректно изменены, например при указании у дочерней корутины другой <code>Job</code> вы можете разрушить принцип <a href="https://kotlinlang.org/docs/coroutines-basics.html#structured-concurrency" rel="noopener noreferrer nofollow">Structured Concurrency</a>, который заключается в каскадной отмене всех корутин, покажу на примере:</p><pre><code class="kotlin">val topLevelJob = viewModelScope.launch {
    /*
    тут всё ок, при создании новой корутины 
    возьмётся Job'а из текущего контекста, в нашем случае это
    topLevelJob, затем корутина будет добавлена как дочерняя Job'а и
    связь родитель - ребёнок не нарушится
    */
    launch {
        println("I'm coroutine #1")
    }
    /*
    не ок, так как мы создаём Job'у которая не привязана
    к родительской, грубо говоря мы не сделали 
    parentJob.attachChild(childJob), который кстати нельзя
    сделать потому что это internal api библиотеки
    */
    launch(Job()) {
        println("I'm coroutine #2")
    }
}

// вторая дочерняя корутина не будет отменена
topLevelJob.cancel()</code></pre><p>Подведём итоги:</p><ul><li><p>корутина создаётся через Kotlin Extension функцию <code>CoroutineScope.launch</code></p></li><li><p><code>CoroutineScope</code> является простым интерфейсом, который предоставляет корутине контекст</p></li><li><p><code>CoroutineContext</code> нужен для хранения всяких полезных штук при выполнении корутины: <code>CoroutineName</code>, <code>CoroutineDispatcher</code>, <code>Job</code>, <code>CoroutineExceptionHandler</code> и тд, важно добавить что вы можете легко создать свой элемент контекста, унаследовав <code>CoroutineContext.Element</code> интерфейс.</p></li><li><p>при создании корутины можно передать новый контекст, это приведёт к созданию контекста, основанного на текущем с изменёнными элементами, взятыми из нового</p></li><li><p>не все элементы контекста можно адекватно изменить, например нужно быть осторожным при указании другой <code>Job</code>'ы, отличным решением будет придерживаться правила: менять <code>Job</code> только для самых высокоуровневых корутин, в идеале при создании <code>CoroutineScope</code></p></li></ul><h2>Continuation интерфейс и реализация suspend блока</h2><p>Возвращаемся снова к начальному примеру:</p><pre><code class="kotlin">fun main() = runBlocking {
    launch {
        println("Hello, I'm a Kotlin coroutine, how are you?")
    }
}

public fun CoroutineScope.launch(
    // ...
    block: suspend CoroutineScope.() -&gt; Unit
): Job {}</code></pre><p>Обратите внимание на ключевое слово <code>suspend</code>, именно благодаря тому что <code>launch</code> выполняет лямбду помеченную этим ключевым словом мы можем запускать <code>suspend</code> функции в пределах корутины, что ещё интереснее эта лямбда во время компиляции превращается в нечто интересное:</p><pre><code class="java">BuildersKt.launch$default($this$runBlocking, (CoroutineContext)null, (CoroutineStart)null, (Function2)(new Function2((Continuation)null) {
    int label = 0;

    public final Object invokeSuspend(Object var1) {
        Object var2 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
        switch (this.label) {
            case 0:
                ResultKt.throwOnFailure(var1);
                String var2 = "Some";
                System.out.println(var2);
                return Unit.INSTANCE;
            default:
                throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
        }
    }

    // этот метод будет использоваться для создания Continuation объекта
    public final Continuation create(@Nullable Object value, @NotNull Continuation completion) {
        Function2 var3 = new &lt;anonymous constructor&gt;(completion);
        return var3;
    }

}), 3, (Object)null);</code></pre><p>Ага, вот она та самая стейт-машина (switch блок), про которую на собесе вскользь упонимают, сейчас она ничего сложного не делает, кроме как выводит текст в консоль и возвращает пустой результат. </p><p>После достаточно долгих вечеров копания в исходниках и процесса дебага я всё таки выяснил, что сгенерированный выше код это ничто иное как реализация абстрактного класса <code>ContinuationImpl</code>, одного из наследников <code>Continuation</code>:</p><pre><code class="kotlin">/*
само название говорит за себя, что это "продолжение" после приостановки 
корутины, да та самая магическая приостановка или SUSPENDED состояние о
которой говорят постоянно, позже узнаем что никакой магии тут нет
*/
public interface Continuation&lt;in T&gt; {
    /*
    как мы выяснили в предыдущем разделе CoroutineContext содержит
    важные штуки для корутин, например CoroutineDispatcher, который
    может пригодиться для переключения потоков
    */
    public val context: CoroutineContext

    /* 
    вызов этого метода происходит после возвращения корутины из состояния
    приостановки, именно сюда кладутся результаты suspend функций, также
    дочерние корутины могут вызывать этот метод у родительских для
    продолжения работы последних
    */
    public fun resumeWith(result: Result&lt;T&gt;)
}</code></pre><p>Без такой штуки как <code>Continuation</code> корутины не могли бы возвращаться туда где произошла приостановка и следовательно мы не могли бы выполнять код на разных потоках, используя последовательную запись кода, напомню что одной из ключевых идей как раз и является выполнение асинхронного кода, как последовательного, небольшой пример:</p><pre><code class="kotlin">// создаём корутину на главном потоке
launch {
    // вызываем функцию fetchAndroidUnderTheHoodPosts() в background потоке
    val myPosts = fetchAndroidUnderTheHoodPosts()
    /* 
    чтобы следующий код получил результат нужно как минимум
    каким-то образом получить его и не забыть переключиться на главный поток,
    а так как fetchAndroidUnderTheHoodPosts() выполняется на другом потоке 
    и неизвестно когда функция закончит своё выполнение, 
    остаётся только вариант передачи в функцию callback'а, 
    который будет вызван когда она завершится,
    таким callback'ом является Continuation объект
    */
    println(myPosts)
}</code></pre><p>После того как функция <code>fetchAndroidUnderTheHoodPosts</code> завершит выполнение своего кода, результат будет передан через <code>Continuation.resumeWith()</code>, что приведёт к дальнейшему выполнение корутины, в текущем примере - вывод всех постов в консоль.</p><p>Окей, мы определились что без <code>Continuation</code> ничего не выйдет и даже узнали что suspend блок в <code>launch</code> функции на самом деле тоже является <code>Continuation</code> объектом и наследуется от <code>ContinuationImpl</code>, но основная реализация содержится в <code>BaseContinuationImpl</code> классе, от которого наследуется <code>ContinuationImpl</code>, сложно? Ничего, привыкайте, это хардкор, а не няшный мульт про поней.</p><p>Идём смотреть на реализацию <code>Continuation</code> для suspend блока:</p><pre><code class="kotlin">/* 
компилятор генерирует реализацию этого 
абстрактного класса для suspend блоков
*/
internal abstract class ContinuationImpl(
    completion: Continuation&lt;Any?&gt;?,
    // контекст берётся из корутины, дальше это увидим
    private val _context: CoroutineContext?
) : BaseContinuationImpl(completion) {
    constructor(completion: Continuation&lt;Any?&gt;?) : this(completion, completion?.context)

    public override val context: CoroutineContext
        get() = _context!!

    private var intercepted: Continuation&lt;Any?&gt;? = null

    /*
    ContinuationInterceptor это штука которая оборачивает 
    текущий Continuation объект в новый, например DispatchedContinuation 
    и возвращает его, такой механизм используется для переключения потоков 
    через CoroutineDispatcher, кстати оборачивание одного объекта
    в другой с общим интерфейсом (Continuation) ничто иное как 
    паттерн Декоратор
    */
    public fun intercepted(): Continuation&lt;Any?&gt; =
        intercepted
            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)
                .also { intercepted = it }

    // очистка обёрнутого Continuation объекта: 
    // зануление ненужных ссылок и тд
    protected override fun releaseIntercepted() {
        val intercepted = intercepted
        if (intercepted != null &amp;&amp; intercepted !== this) {
            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)
        }
        // корутина закончила своё выполнение
        this.intercepted = CompletedContinuation
    }
}

/*
если в ContinuationImpl реализована поддержка CoroutineDispatcher'ов,
то в BaseContinuationImpl содержится основная логика работы с состоянием
приостановки
*/
internal abstract class BaseContinuationImpl(
    public val completion: Continuation&lt;Any?&gt;?
) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable {и
    
    public final override fun resumeWith(result: Result&lt;Any?&gt;) {
        var current = this
        var param = result
        while (true) {
            with(current) {
                /*
                текущая реализация Continuation требует в качестве completion
                более высокоуровневый Continuation объект, обычно им является 
                сама корутина
                напоминаю что мы сейчас рассматриваем реализацию 
                suspend блока в launch функции, а не саму корутину
                */
                val completion = completion!!
                val outcome: Result&lt;Any?&gt; =
                    try {
                        /*
                        вот тут происходит самое интересное, invokeSuspend 
                        выполняет внутри себя тот самый сгенерированный код
                        в котором содержатся наши suspend функции и если одна 
                        из них перешла в состояние приостановки, 
                        метод тупо делает return, Continuation в данном
                        случае не продолжит своё выполнение пока
                        не будет снова вызван resumeWith()
                        */
                        val outcome = invokeSuspend(param)
                        /*
                        COROUTINE_SUSPENDED - зарезервированная константа,
                        сигнализирующая о том, что внутри invokeSuspend 
                        произошла приостановка
                        */
                        if (outcome === COROUTINE_SUSPENDED) return
                        // если invokeSuspend вернул результат получаем его
                        Result.success(outcome)
                    } catch (exception: Throwable) {
                        // если произошло исключение тоже получаем его
                        Result.failure(exception)
                    }
                /*
                так как текущий BaseContinuationImpl получил результат, 
                значит suspend блок в корутине завершился, поэтому 
                текущий объект BaseContinuationImpl больше не нужен,
                а следовательно всякие используемые штуки, 
                такие как CoroutineDispatcher'ы например должен быть очищены
                */
                releaseIntercepted()

                /*
                если мы запустили корутину в другой корутине, то в качестве
                completion будет suspend блок родительской корутины:
                  
                launch { родительский suspend блок BaseContinuationImpl
                  launch { дочерний suspend блок BaseContinuationImpl
                    
                  }
                }

                */
                if (completion is BaseContinuationImpl) {
                    current = completion
                    param = outcome
                } else {
                    /*
                    вызывается самый высокоуровневый Continuation объект, 
                    в большинстве случаев это сама корутина
                    */
                    completion.resumeWith(outcome)
                    return
                }
            }
        }
    }

    // тот самый метод, переопределённый в сгенерированном коде
    protected abstract fun invokeSuspend(result: Result&lt;Any?&gt;): Any?
}</code></pre><p>Суммируем: </p><ol><li><p>мы имеем <code>Continuation</code> интерфейс, позволяющий продолжить выполнение корутины после её приостановки</p></li><li><p> для suspend блока генерируется специальная реализация <code>ContinuationImpl</code> со стейт-машиной (switch или when конструкцией) в переопределённом методе <code>invokeSuspend()</code></p></li><li><p>когда suspend функция приостанавливается происходят следующие вещи: <br/>-<code>invokeSuspend()</code> возвращает специальное значение <code>COROUTINE_SUSPENDED</code> <br/>-<code>BaseContinuationImpl</code> завершается через return и ожидает следующего вызова <code>resumeWith()</code> </p></li><li><p>логика обработки состояния приостановки содержится в <code>BaseContinuationImpl</code>, а логика переключения потоков с помощью <code>CoroutineDispatcher</code>'ов происходит в наследнике <code>ContinuationImpl</code>.</p></li></ol><h2>Что же такое корутина?</h2><p>Теперь мы можем разобраться чем же на самом деле является корутина и как происходит выполнение suspend блока в ней, для этого снова возвращаемся к исходникам <code>launch</code> функции:</p><pre><code class="kotlin">public fun CoroutineScope.launch(
    // ...
    block: suspend CoroutineScope.() -&gt; Unit
): Job {
    val newContext = newCoroutineContext(context)
    /*
    мы не будем рассматривать LazyStandaloneCoroutine, так как эта штука
    очень похожа на базовую реализацию корутины StandaloneCoroutine,
    только запускается по требованию
    */
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    /*
    запускаем корутину, LazyStandaloneCoroutine не запустится таким образом,
    нужно будет вручную вызвать метод start() у объекта Job, 
    который возвращает launch
    */
    coroutine.start(start, coroutine, block)
    return coroutine
}</code></pre><p>Помните в <code>BaseContinuationImpl</code> был такой параметр как completion, я ещё говорил что им может быть сама корутина, так вот <code>StandaloneCoroutine</code> и есть реализация корутины, короче не будем тянуть, идём смотреть исходники:</p><pre><code class="kotlin">// корутина наследует Job, Continuation и CoroutineScope
class StandaloneCoroutine&lt;in T&gt;(
    parentContext: CoroutineContext,
    active: Boolean
) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope {

    init {
        /*
        кладёт Job текущей корутины в Job'у родительской
        это нужно чтобы родительские корутины знали о 
        дочерних и не завершались раньше них
        */
        initParentJob(parentContext[Job])
    }

    /* 
    так можно сделать потому что StandaloneCoroutine 
    является реализацией Job, а Job является одним из элементов 
    CoroutineContext'а
    */
    override val context: CoroutineContext = parentContext + this

    // вы уже знаете, что когда корутина выходит из состояния приостановки,
    // вызывается метод Continuation.resumeWith()
    override fun resumeWith(result: Result&lt;T&gt;) {
        // makeCompletingOnce пытается завершить Job'у корутины
        val state = makeCompletingOnce(result.toState())
        // если у текущей Job'ы есть дочерние и они не были завершены, 
        // корутина не может быть завершена
        if (state === COMPLETING_WAITING_CHILDREN) return
        afterResume(state)
    }

    /*
    запуск suspend блока в корутине происходит в CoroutineStart enum'е,
    
    в качестве параметра receiver передаётся сама корутина, это нужно
    чтобы suspend блок получил CoroutineContext, если уже забыли про это, 
    возвращайтесь к исходнику ContinuationImpl
    
    completion это как раз то самый высокоуровневый Continuation объект,
    вызываемый из сгенерированного Continuation объекта для suspend блока, 
    как я уже говорил ранее им является сама корутина
    */
    fun &lt;R&gt; start(
        start: CoroutineStart, 
        receiver: R, 
        block: suspend R.() -&gt; T
    ) {
        start(block = block, receiver = receiver, competion = this)
    }
}

// поначалу я долго искал где запускается корутина, так как не сразу
// заметил что у CoroutineStart переопределён invoke оператор
enum class CoroutineStart {

    // я опустил остальные варианты, оставил только базовый
    DEFAULT;

    operator fun &lt;R, T&gt; invoke(
        block: suspend R.() -&gt; T, 
        receiver: R, 
        completion: Continuation&lt;T&gt;
    ): Unit =
        when (this) {
            // для suspend блока будет сгенерированна ContinuationImpl
            // реализация, которая запустится при вызове launch функции
            DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion)
            else -&gt; Unit
        }

}</code></pre><p>Осталось только разобраться как все таки запускается suspend блок, для этого проваливаемся ещё на уровень ниже, в <code>startCoroutineCancellable()</code> функцию:</p><pre><code class="kotlin">// обратите внимание, что startCoroutineCancellable() является
// Kotlin Extension функцией для suspend блока
internal fun &lt;R, T&gt; (suspend (R) -&gt; T).startCoroutineCancellable(
    receiver: R, 
    completion: Continuation&lt;T&gt;,
    onCancellation: ((cause: Throwable) -&gt; Unit)? = null
) =
    // первым делом из suspend блока создаётся Continuation объект
    createCoroutineUnintercepted(receiver, completion)
        /*
        далее оборачивается в DispatchedContinuation, если используется
        CoroutineDispatcher, а он в большинстве случаев используется
        */
        .intercepted()
        /*
        ну и происходит вызов Continuation.resumeWith() 
        в зависимости от типа Continuation, чтобы блок в корутине
        начал выполняться, иначе ничего не произойдёт
        */
        .resumeCancellableWith(Result.success(Unit), onCancellation)

// создаёт Continuation из suspend блока
actual fun &lt;R, T&gt; (suspend R.() -&gt; T).createCoroutineUnintercepted(
    receiver: R,
    completion: Continuation&lt;T&gt;
): Continuation&lt;Unit&gt; {
    /* 
    в нашем случае suspend блок является объектом ContinuationImpl,
    а это наследник BaseContinuationImpl, поэтому выполняется 
    первая ветка
    */
    return if (this is BaseContinuationImpl)
        // метод create будет сгенерирован компилятором для ContinuationImpl
        // реализации, кстати ранее уже был пример сгенерированного кода
        create(receiver, completion)
    else
        ...
}

/*
делает вызов resumeWith в зависимости от типа Continuation:
1) DispatchedContinuation может передать вызов resumeWith() 
CoroutineDispatcher'у, который выполнит код на другом потоке
2) обычный вызов Continuation.resumeWith() произойдёт без
смены потоков и тд
*/
fun &lt;T&gt; Continuation&lt;T&gt;.resumeCancellableWith(
    result: Result&lt;T&gt;,
    onCancellation: ((cause: Throwable) -&gt; Unit)? = null
): Unit = when (this) {
    is DispatchedContinuation -&gt; resumeCancellableWith(result, onCancellation)
    else -&gt; resumeWith(result)
}</code></pre><p>Можно сказать что вы прошли джедайское обучение и готовы к настоящему бою, разберём самый первый пример:</p><pre><code class="kotlin">fun main() = runBlocking {
    // запускаем новую корутину
    launch {
        println("Hello, I'm a Kotlin coroutine, how are you?")
    }
}</code></pre><p>Если посмотреть на пример с точки зрения внутрянки корутин, то получим примерно следующий код:</p><pre><code class="kotlin">fun main() {
    SuspendLaunchBlock(
        // (2)
        completion = StandaloneCoroutine()
    ).resumeWith(Result.success(Unit)) // (3)
}

// (1)
class SuspendLaunchBlock(
    completion: StandaloneCoroutine&lt;Any?&gt;
) : ContinuationImpl(completion) {

    var label = 0

    // (5)
    fun resumeWith(result: Result&lt;Any?&gt;) {
        try {
            val newResult = invokeSuspend(result)
            if (newResult === COROUTINE_SUSPENDED) return
            Result.success(newResult)
        } catch (exception: Throwable) {
            Result.failure(exception)
        }
        completion.resumeWith(newResult)
    }

    // (4)
    fun invokeSuspend(result: Result&lt;Any?&gt;): Any? {
        when(label) {
            0 -&gt; {
                throwIfFailureResult(result)
                println("Hello, I'm a Kotlin coroutine, how are you?")
                return Unit
            }
            else -&gt; error("Illegal state")
        }
    }
  
}

class StandaloneCoroutine&lt;T&gt;(...) : Continuation&lt;T&gt; {

    // (6)
    fun resumeWith(result: Result&lt;T&gt;) {
        val state = makeCompletingOnce(result.toState())
        if (state === COMPLETING_WAITING_CHILDREN) return
        afterResume(state)
    }
  
}</code></pre><p>Давайте по порядку:</p><ol><li><p>Создаётся сгенерированная реализация <code>SuspendLaunchBlock</code> для suspend блока в <code>launch</code> функции со стейт-машиной или конкретнее when конструкцией.</p></li><li><p>Создаётся  <code>StandaloneCoroutine</code> и передаётся в качестве параметра completion в <code>SuspendLaunchBlock</code></p></li><li><p>Запускается корутина через вызов <code>SuspendLaunchBlock.resumeWith()</code> метода, который далее выполняет сгенерированный <code>invokeSuspend()</code> метод</p></li><li><p>В <code>invokeSuspend()</code> выполняется единственная ветка в when блоке - вывод в консоль и возвращение пустого результата</p></li><li><p>После завершения <code>invokeSuspend()</code> в <code>SuspendLaunchBlock.resumeWith()</code> происходит сначала проверка на состояние приостановки, в данном случае <code>invokeSuspend()</code> выполнилась без приостановки, поэтому сразу вызывается <code>completion.resumeWith()</code>, а так как completion это <code>StandaloneCoroutine</code>, то вызывается <code>StandaloneCoroutine.resumeWith()</code> реализация</p></li><li><p><code>StandaloneCoroutine.resumeWith()</code> проверяет нет ли незавершенных дочерних корутин, у нас их нет, и прекращает выполнение</p></li></ol><p>Вы практически магистр джедаев! Сделайте паузу, заварите чай или кофе, скушайте шоколадку и ещё раз пройдитесь по примеру, очень важно понять что механизм корутин заключается в переходах между состояниями приостановки через вызов <code>Continuation.resumeWith()</code> метода, а завершение происходит в корневом <code>Continuation</code> объекте и самое главное, что нет никакой магии.</p><h2>А если в корутине цепочка из suspend функций?</h2><p>Усложним пример из прошлого раздела, добавив две suspend функции:</p><pre><code class="kotlin">// опустим подробности реализации
suspend fun fetchAuthToken() = ...
suspend fun fetchProfileData(token: String) = ...

fun main() = runBlocking {
    // запускаем корутины с двумя suspend функциями
    launch {
        val token = fetchAuthToken()
        val profile = fetchProfileData(token = token)
        println(profile)
    }
}</code></pre><p>Интересно какой теперь будет код с точки зрения внутрянки корутин, смотрим:</p><pre><code class="kotlin">fun main() {
    SuspendLaunchBlock(
        // (2)
        completion = StandaloneCoroutine()
    ).resumeWith(Result.success(Unit)) // (3)
}

// (5)
suspend fun fetchAuthToken(continuation: SuspendLaunchBlock): Any? {
    /*
    любое асинхронное выполнение кода приводит к состоянию приостановки
    это необязательно использование многопоточности, дальше вы это увидите
    
    runCodeInBackground - магический метод, который выполняет 
    блок кода в фоновом потоке
    */
    runCodeInBackground {
        val token = ...
        runCodeInMain {
            // (6)
            // магический метод, который выполняет блок кода на главном потоке
            continuation.resumeWith(token)
        }
    }
  
    return COROUTINE_SUSPENDED
}

suspend fun fetchProfileData(token: String) = ...

// (1)
class SuspendLaunchBlock(
    completion: StandaloneCoroutine&lt;Any?&gt;
) : ContinuationImpl(completion) {

    var label = 0

    fun resumeWith(result: Result&lt;Any?&gt;) {
        try {
            val newResult = invokeSuspend(result)
            if (outcome === COROUTINE_SUSPENDED) return
            Result.success(newResult)
        } catch (exception: Throwable) {
            Result.failure(exception)
        } 
        // (9)
        completion.resumeWith(newResult)
    }

    fun invokeSuspend(result: Result&lt;Any?&gt;): Any? {
        // while(true) нужен чтобы выполнять ветки дальше, 
        // если suspend функция не перешла в состояние приостановки
        while (true) {
            when(label) {
                // (4)
                0 -&gt; {
                    throwIfFailureResult(result)
                    label = 1
                    // Continuation передаётся в качестве 
                    // аргумента suspend функции
                    val state = fetchAuthToken(this)
                    if (state == COROUTINE_SUSPENDED) {
                        return COROUTINE_SUSPENDED
                    }
                }
                // (7)
                1 -&gt; {
                    throwIfFailureResult(result)
                    label = 2
                    val token = result.unwrap()
                    val state = fetchProfileData(token, this)
                    if (state == COROUTINE_SUSPENDED) {
                        return COROUTINE_SUSPENDED
                    }
                }
                // (8)
                2 -&gt; {
                    throwIfFailureResult(result)
                    val profile = result.unwrap()
                    println(profile)
                    break
                }
                else -&gt; error("Illegal state")
            }
        }
        
        return Unit
    }
  
}

class StandaloneCoroutine&lt;T&gt;(...) : Continuation&lt;T&gt; {

    // (10)
    fun resumeWith(result: Result&lt;T&gt;) {
        val state = makeCompletingOnce(result.toState())
        if (state === COMPLETING_WAITING_CHILDREN) return
        afterResume(state)
    }
  
}</code></pre><p>Чтобы было поинтереснее будем считать, что обе suspend функции переходят в состояние приостановки, смотрим логику:</p><ol><li><p>Создаётся сгенерированная реализация <code>SuspendLaunchBlock</code> для suspend блока в <code>launch</code> функции со стейт-машиной или конкретнее when конструкцией.</p></li><li><p>Создаётся  <code>StandaloneCoroutine</code> и передаётся в качестве параметра completion в <code>SuspendLaunchBlock</code></p></li><li><p>Запускается корутина через вызов <code>SuspendLaunchBlock.resumeWith()</code> метода, который далее выполняет сгенерированный <code>invokeSuspend()</code> метод</p></li><li><p>В <code>invokeSuspend()</code> выполняется первая ветка (label == 0), где происходит вызов функции <code>fetchAuthToken()</code>, в качестве единственного параметра передаётся текущий <code>Continuation</code> объект, в данном случае это <code>SuspendLaunchBlock</code>, значение переменной label меняется на 1</p></li><li><p>Функция <code>fetchAuthToken()</code> возвращает значение <code>COROUTINE_SUSPENDED</code>, что свидетельствует о состоянии приостановки, важно что здесь нет никакой магии, выполнение кода происходит в другом потоке, а так как это асинхронное выполнение, внешнему коду можно только передать результат через callback, которым кстати является <code>SuspendLaunchBlock</code></p></li><li><p>После выполнение своего кода <code>fetchAuthToken()</code> вызывает метод <code>SuspendLaunchBlock.resumeWith()</code> с результатом своей работы, в примере это строка с токеном</p></li><li><p><code>SuspendLaunchBlock.resumeWith()</code> возобновляет своё выполение и повторно вызывает invokeSuspend(), где уже выполняется вторая ветка (label == 1), в ней происходит вызов fetchProfileData() метода, в качестве первого параметра он принимает токен от предыдущей suspend функции <code>fetchAuthToken()</code>, а в качестве второго ссылку на Continuation объект, которым как мы уже знаем является <code>SuspendLaunchBlock</code>, метод <code>fetchProfileData()</code> выполняется аналогично <code>fetchAuthToken()</code>, label становится равным 2</p></li><li><p>В последней ветке <code>invokeSuspend()</code>, где label == 2, происходит вывод в консоль результата функции <code>fetchProfileData()</code> и возвращение пустого значения</p></li><li><p>На этот раз возвращенное значение из <code>invokeSuspend()</code> не является <code>COROUTINE_SUSPENDED</code> , поэтому выполнение <code>SuspendLaunchBlock</code> завершается, дальнейшее управление передаётся <code>StandaloneCoroutine</code> через вызов <code>completion.resumeWith()</code></p></li><li><p><code>StandaloneCoroutine.resumeWith()</code> проверяет нет ли незавершенных дочерних корутин, у нас их нет, и прекращает выполнение</p></li></ol><p>Отлично, теперь вы знаете как происходят переходы между отдельными suspend функциями, поздравляю, вы можете смело умничать на собесах, но не забывайте что скромность красит человека)</p><h2>Переключение потоков, delay() и CoroutineDispatcher</h2><p>Мы забыли о самом важном ради чего в принципе используются корутины - выполнение suspend функций на других потоках, отсюда собственно и возникает потребность приостановить выполнение текущей корутины, как мы уже выяснили для этого нужно передать <code>Continuation</code> объект suspend функции и ждать пока она сама не вызовет <code>Continuation.resumeWith()</code> метод:</p><pre><code class="kotlin">fun fetchAuthToken(continuation: Continuation&lt;Any?&gt;): Any? {
    // магический метод, который выполняет блок кода в фоновом потоке
    runCodeInBackground {
        val token = ...
        // магический метод, который выполняет блок кода на главном потоке
        runCodeInMain {
            /* 
            чтобы сообщить корутине что suspend функция завершила
            своё выполнение нужно вызвать Continuation.resumeWith() 
            с результатом работы функции
            */
            continuation.resumeWith(token)
        }
    }
    // так как функция не может сразу вернуть результат, 
    // она переходит в состояние приостановки
    return COROUTINE_SUSPENDED
}</code></pre><p>Это достаточно упрощенная версия кода, но зато она отражают общий механизм, а самое главное показывает что состояние приостановки это ничто иное как выполнение некоторого кода на другом потоке и возвращение результата через <code>Continuation.resumeWith</code> как через обычный callback.</p><p>В прошлом разделе я вскользь упомянул, что любое асинхронное выполнение приводит к состоянию приостановки, но не раскрыл эту тему, давайте разбираться.</p><p>Что нужно чтобы код стал асинхронным? Правильно сделать его выполнение независимым от текущей точки выполнения, например создать новый поток:</p><pre><code class="kotlin">fun main() {
    // создаётся новый поток и сразу запускается
    Thread {
        val sum = 3 + 7
        println(sum)
    }.start()
    // код main() продолжает выполняться независимо от того,
    // выполнился ли весь код в Thread
    val mul = 3 * 7
    println(mul)
    // функция main() может завершиться раньше созданного потока
}</code></pre><p>Но давайте на минутку забудем про многопоточность и вспомним главный поток Android, он позволит нам выполнить код асинхронно? Конечно же да, можно это сделать через старый добрый <code>Handler</code>:</p><pre><code class="kotlin">// Handler поставит выполнение кода в очередь главного потока
handler.post {
    println("I'll run soon")
}</code></pre><p>Кстати <code>Handler</code> используется в реализации функции <code>delay</code> для главного потока Android, если забыли, то эта функция позволяет сделать задержку без блокировки текущего потока:</p><pre><code class="kotlin">fun delay(continuation: Continuation&lt;Any?&gt;): Any? {
    val block = Runnable {
        // после того как задержка пройдёт, выполнится этот блок кода
        // и корутина продолжит своё выполнение после приостановки
        continuation.resumeWith(Result.success(Unit))
    }
 
    // handler.postDelayed() выполняет block через указанный 
    // промежуток времени в миллисекундах
    if (handler.postDelayed(block, timeMillis.coerceAtMost(MAX_DELAY))) {
        // если корутина была отменена нужно отменить задержку
        continuation.invokeOnCancellation { handler.removeCallbacks(block) }
    } else {
        // отменяет текущую корутину, так как Handler для главного потока
        // был закрыт
        cancelOnRejection(continuation.context, block)
    }

    return COROUTINE_SUSPENDED
}</code></pre><p>Вот и вся суть асинхронного выполнения кода, им может быть любой механизм, позволяющий выполнить X код независимо от Y кода и если попробовать дать определение корутинам сейчас, то оно будет примерно такое:</p><blockquote><p><em>Корутина — это абстракция, которая оборачивает некоторую асинхронную работу, это может быть выполнение кода в другом потоке или использование очереди главного потока, например MessageQueue из Android, в удобный последовательный код с механизмами отмены и другими прикольными фишками.</em></p></blockquote><p>Ладно, вроде бы разобрались что такое приостановка корутины и асинхронное выполнение кода, можем переходить к более прикладным вещам, например к функции <code>withContext()</code>, чаще всего используемой для изменения <code>CoroutineDispatcher</code>'а:</p><pre><code class="kotlin">suspend fun &lt;T&gt; withContext(
    context: CoroutineContext,
    block: suspend CoroutineScope.() -&gt; T
): T {
    /*
    как мы знаем Continuation работает под капотом корутин и его нельзя
    получить явно в прикладном коде, поэтому была придумана inline функция
    suspendCoroutineUninterceptedOrReturn (и не одна кстати), 
    которая после компиляции подставит текущий Continuation объект
    */
    return suspendCoroutineUninterceptedOrReturn sc@ { uCont -&gt;
        val oldContext = uCont.context
        /*
        если вы ещё не забыли то новый контекст производится 
        путём сложения двух контекстов, в качестве результата 
        мы имеем контекст в котором старые элементы заменены новыми, 
        например Dispatchers.Main можно поменять на Dispatchers.Default
        */
        val newContext = oldContext.newCoroutineContext(context)

        // проверка что корутина все ещё выполняется
        newContext.ensureActive()

        // мы не будем рассматривать все ветки, нас интересует только
        // переключение потоков через CoroutineDispatcher
        if (newContext === oldContext) {
            ...
        }
        // CoroutineDispatcher является наследником ContinuationInterceptor
        if (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) {
            ...
        }
        
        // ну вот опять создаётся какая-то неизвестная нам корутина,
        // не беспокойтесь там достаточно простая логика
        val coroutine = DispatchedCoroutine(newContext, uCont)
        // стартуем также как и обычную корутину
        block.startCoroutineCancellable(coroutine, coroutine)
        /*
        если есть возможность сразу отдать результат без приостановки корутины
        то withContext сразу завершится, в противном случае корутина, 
        содержащая withContext() вызов перейдёт в состояние приостановки
        */
        coroutine.getResult()
    }
}</code></pre><p>Функция <code>withContext</code> делает 3 простые вещи:</p><ol><li><p>Получает текущий <code>Continuation</code> объект, он может быть взят из параметра suspend функции или из текущей корутины в которой была вызвана функция <code>withContext</code></p></li><li><p>Берёт контекст из <code>Continuation</code> объекта и складывает с контекстом, переданным в качестве параметра, в результате создаётся новый контекст</p></li><li><p>На основе нового контекста создаёт определённый вид корутин, например если был изменён <code>CoroutineDispatcher</code> будет создана корутина  <code>DispatchedCoroutine</code></p></li></ol><p>Что ж давайте теперь глянем исходники <code>DispatchedCoroutine</code>:</p><pre><code class="kotlin">/*
чаще всего в качестве continuation параметра выступает 
Continuation объект, который генерируется для suspend блока в корутине, 
если забыли, то это реализация абстрактного класса ContinuationImpl
*/
internal class DispatchedCoroutine&lt;in T&gt; internal constructor(
    context: CoroutineContext,
    continuation: Continuation&lt;T&gt;
) : ScopeCoroutine&lt;T&gt;(context, uCont) {

    /* 
    метод afterResume() вызывается перед завершением Continuation.resumeWith(),
    когда корутина закончила выполнять все свои suspend функции и 
    у неё больше нет дочерних корутин в состоянии выполнения
    */
    override fun afterResume(state: Any?) {
        /*
        метод afterResume() может быть вызван раньше getResult(), 
        например если блок кода в withContext() очень быстро выполнился
        в таком случае результат вернёт getResult()
        */
        if (tryResume()) return 
        /*
        Я уже вскользь упоминал что делает каждый метод в этой цепочке,
        когда мы рассматривали как стартует корутины, ещё раз повторим:
  
        intercepted() оборачивает continuation в DispatchedContinuation, 
        который реализует логику работы с CoroutineDispatcher'ами

        resumeCancellableWith() вызывает resumeWith() в зависимости от типа
        Continuation, в данном случае будет вызван метод
        DispatchedContinuation.resumeCancellableWith()
        */  
        continuation.intercepted().resumeCancellableWith(recoverResult(state, uCont))
    }

    internal fun getResult(): Any? {
        // если нельзя сразу вернуть результат корутина приостанавливается
        if (trySuspend()) return COROUTINE_SUSPENDED

        // результат выполнения withContext()
        val state = ...
        return state as T
    }
}</code></pre><p>Суммируем, <code>DispatchedCoroutine</code> выполняет две ключевые задачи:</p><ol><li><p>Добавляет возможность вернуть результат без перехода в состояние приостановки, если такая возможность есть, для этого используется <code>getResult()</code> метод.</p></li><li><p>Переключает <code>Continuation</code> объект, в котором был вызван <code>withContext()</code>, на родной поток, например если ваша корутина выполняется на главном потоке, затем вызывает <code>withContext()</code> на фоновом, то результат должен вернуться снова на главный. </p></li></ol><p>Ладно, с <code>DispatchedCoroutine</code> более менее разобрались, чтобы понять как на самом деле происходит переключение потоков в корутинах провалимся в <code>DispatchedContinuation</code>, в который оборачиваются другие <code>Continuation</code> объекты:</p><pre><code class="kotlin">/*
DispatchedContinuation принимает на вход:

dispatcher - выполняет блок кода, чаще всего на другом потоке 
или с использованием очереди, например Handler / MessageQueue из Android 
continuation - Continuation объект, работа с которым будет происходить
через указанный диспатчер
*/
internal class DispatchedContinuation&lt;in T&gt;(
    val dispatcher: CoroutineDispatcher,
    val continuation: Continuation&lt;T&gt;
) : Continuation&lt;T&gt; by continuation {

    /*
    логика resumeWith() идентична resumeCancellableWith() с отличием только
    в разных режимах resumeMode, обычно чаще всего вызывается 
    именно resumeCancellableWith, так как режим MODE_CANCELLABLE 
    позволяет прокинуть CancellationException для отмены корутины
    */
    override fun resumeWith(result: Result&lt;T&gt;) { ... }

    internal inline fun resumeCancellableWith(
        result: Result&lt;T&gt;,
        noinline onCancellation: ((cause: Throwable) -&gt; Unit)?
    ) {
        val state = result.toState(onCancellation)
        /*
        CoroutineDispatcher имеет два логически связанных метода:
        
        isDispatchNeeded() решает выполнять код в диспатчере или нет
        dispatch() выполняет код в диспатчере: код может выполниться на
        другом потоке, поставлен в очередь и тд
        */
        if (dispatcher.isDispatchNeeded(context)) {
            _state = state
            resumeMode = MODE_CANCELLABLE
            // для наглядности я упростил блок кода и написал его здесь
            val block = Runnable {
                continuation.resumeWith(state)
            }
            dispatcher.dispatch(context, block)
        } else {
            /*
            если диспатчер не хочет выполнять код, а такое может быть
            например если диспатчер переключает на главный поток, а мы уже
            на главном потоке и внутри диспатчера реализована проверка, 
            то isDispatchNeeded() вернёт false, в таком случае выполнение
            корутины будет добавлено в EventLoop
            */
            executeUnconfined(state, MODE_CANCELLABLE) {
                if (!resumeCancelled(state)) {
                    resumeUndispatchedWith(result)
                }
            }
        }
    }

}</code></pre><p>Как видите логика <code>CoroutineDispatcher</code>'а достаточно простая:</p><ol><li><p>Вызывается метод <code>isDispatchNeeded()</code> чтобы понять отдавать выполнение кода диспатчеру или нет, это нужно чтобы избежать лишних вызовов <code>dispatch()</code>, например не делать переключение на главный поток, если мы уже находимся на нём</p></li><li><p>Если <code>isDispatchNeeded()</code> вернул true разумеется отдаём выполнение кода диспатчеру, вызвав метод <code>dispatch()</code></p></li><li><p>Если <code>isDispatchNeeded()</code> вернул false запускаем корутину на <code>EventLoop</code>'е, об этом в следующем разделе</p></li></ol><p>В качестве примера рассмотрим такие интересные диспатчеры из Android, как <code>Dispatchers.Main</code> и <code>Dispatchers.Main.immediate</code>:</p><pre><code class="kotlin">val mainLooper = Looper.getMainLooper()
val handler = Handler(mainLooper)

// реализация для Dispatchers.Main
override fun isDispatchNeeded(...) = true

// реализация для Dispatchers.Main.immediate
override fun isDispatchNeeded(...): Boolean {
    // сравнивает Looper текущего потока с главным
    return Looper.myLooper() != mainLooper
}

override fun dispatch(
    context: CoroutineContext, 
    block: Runnable
) {
    // handler.post() выполняет блок кода на главном потоке
    handler.post(block)
}</code></pre><p>Вот и вся разница между ними: <code>Dispatchers.Main</code> всегда переключает выполнение кода на главный поток через <code>Handler.post()</code>, а <code>Dispatchers.Main.immediate</code> только, если код не выполняется на главном потоке.</p><p>Для закрепления знаний попробуем собрать всё воедино и описать логику для следующего примера:</p><pre><code class="kotlin">// примерно такой код можно встретить в рабочих проектах 
viewModelScope.launch {
    // я не стал выносить в отдельную функцию, чтобы не усложнять пример
    val posts = withContext(Dispatchers.IO) {
        try {
            // получаем список постов в background потоке
            apiService.fetchPosts()
        } catch (exception: Exception) {
            // важно прокидывать CancellationException дальше 
            // так как это часть механизма отмены корутины
            if (exception is CancellationException) throw exception
            emptyList()
        }
    }
    // отображаем данные на главном потоке
    println(posts)
}</code></pre><p>Под капотом весь этот код будет выглядить примерно как-то так:</p><pre><code class="kotlin">// (1)
class ViewModelScopeLaunchBlock(
    completion: Continuation&lt;Any?&gt;
) : ContinuationImpl(completion) {

    var label = 0

    // (5)
    fun resumeWith(result: Result&lt;Any?&gt;) {
        try {
            val newResult = invokeSuspend(result)
            if (outcome === COROUTINE_SUSPENDED) return
            Result.success(newResult)
        } catch (exception: Throwable) {
            Result.failure(exception)
        }
        // (17)
        completion.resumeWith(newResult)
    }

    fun invokeSuspend(result: Result&lt;Any?&gt;): Any? {
        // while(true) нужен чтобы выполнять ветки дальше, 
        // если suspend функция не перешла в состояние приостановки
        while (true) {
            when(label) {
                // (5)
                0 -&gt; {
                    throwIfFailureResult(result)
                    label = 1
                    // Continuation передаётся в качестве 
                    // аргумента suspend функции
                    val state = fetchPosts(this)
                    // (10)
                    if (state == COROUTINE_SUSPENDED) {
                        return COROUTINE_SUSPENDED
                    }
                }
                // (16)
                1 -&gt; {
                    throwIfFailureResult(result)
                    val profile = result.unwrap()
                    println(profile)
                    break
                }
                else -&gt; error("Illegal state")
            }
        }
        
        return Unit
    }
  
}

class StandaloneCoroutine(...) {

    // (18)
    fun resumeWith(result: Result&lt;T&gt;) {
        val state = makeCompletingOnce(result.toState())
        if (state === COMPLETING_WAITING_CHILDREN) return
        afterResume(state)
    }
  
}

// (6)
class WithContextBlock(
    completion: DispatchedCoroutine
) : ContinuationImpl(completion) {

    var label = 0

    // (12)
    fun resumeWith(result: Result&lt;Any?&gt;) {
        try {
            val newResult = invokeSuspend(result)
            if (outcome === COROUTINE_SUSPENDED) return
            Result.success(newResult)
        } catch (exception: Throwable) {
             Result.failure(exception)
        }
        // (12)
        completion.resumeWith(newResult)
    }

    // (11)
    fun invokeSuspend(result: Result&lt;Any?&gt;): Any? {
        try {
            val posts = apiService.fetchPosts()
            return posts
        } catch (exception: Exception) {
            // важно прокидывать CancellationException дальше так как это часть
            // механизма отмены корутины, вспомните resumeCancellableWith
            if (exception is CancellationException) throw exception
            return emptyList()
        }
    }

}

class DispatchedCoroutine(
    ...
    // (7)
    val continuation: ViewModelScopeLaunchBlock
): ScopeCoroutine(context, continuation) {

    // (13)
    fun resumeWith(result: Result&lt;T&gt;) {
        val state = makeCompletingOnce(result.toState())
        if (state === COMPLETING_WAITING_CHILDREN) return
        afterResume(state)
    }

    // (14)
    override fun afterResume(state: Any?) {
        if (tryResume()) return 
        continuation.intercepted().resumeCancellableWith(recoverResult(state, uCont))
    }
  
}

class DispatchedContinuation&lt;in T&gt;(
    val dispatcher: CoroutineDispatcher,
    val continuation: Continuation&lt;T&gt;
) : Continuation&lt;T&gt; by continuation {

    // (4, 9, 15)
    inline fun resumeCancellableWith(
        result: Result&lt;T&gt;,
        noinline onCancellation: ((cause: Throwable) -&gt; Unit)?
    ) {
        val state = result.toState(onCancellation)
        if (dispatcher.isDispatchNeeded(context)) {
            _state = state
            resumeMode = MODE_CANCELLABLE
            val block = Runnable {
                continuation.resumeWith(state)
            }
            // (9, 15)
            dispatcher.dispatch(context, block)
        } else {
            // (4)
            continuation.resumeWith(state)
        }
    }

}

// (2)
val topLevelCoroutine = StandaloneCoroutine(...)

val viewModelScopeLaunchBlock = ViewModelScopeLaunchBlock(
    // (2)
    completion = topLevelCoroutine
)

// (3)
DispatchedContinuation(
  dispatcher = Dispachers.Main.immediate
  continuation = viewModelScopeLaunchBlock
).resumeCancellableWith(Result.success(Unit))

val withContextBlock = WithContextBlock(
    // (7)
    completion = DispatchedCoroutine(viewModelScopeLaunchBlock)
)

// (8)
DispatchedContinuation(
    dispatcher = Dispatchers.IO,
    continuation = withContextBlock
).resumeCancellableWith(Result.success(Unit))
</code></pre><p>Очень запутанно? Согласен, давайте по порядку:</p><ol><li><p>Генерируется реализация <code>ViewModelScopeLaunchBlock</code> для suspend блока в <code>viewModelScope.launch()</code> функции со стейт-машиной или конкретнее when конструкцией.</p></li><li><p>Создаётся <code>StandaloneCoroutine</code> и передаётся в качестве параметра completion в <code>ViewModelScopeLaunchBlock</code> </p></li><li><p><code>ViewModelScopeLaunchBlock</code>  оборачивается в <code>DispatchedContinuation</code>, в качестве диспатчера передаётся тот, что был указан в <code>viewModelScope</code>, для Android этим диспатчером будет <code>Dispatchers.Main.immediate</code> </p></li><li><p>Вызывается <code>DispatchedContinuation.resumeCancellableWith()</code> для <code>ViewModelScopeLaunchBlock</code>, где происходит проверка на главный поток, но так как <code>viewModelScope.launch()</code> и так выполняется на главном потоке, то не будет никакого переключения через диспатчер, а метод <code>ViewModelScopeLaunchBlock.resumeWith()</code> будет вызван напрямую</p></li><li><p> В <code>ViewModelScopeLaunchBlock.resumeWith()</code> происходит вызов <code>invokeSuspend()</code>, где начинает выполняться первая ветка (label == 0), в которой вызывается <code>fetchPosts()</code>, в качестве первого параметра передаётся ссылка на текущий <code>Continuation</code> объект, в данном случае это <code>ViewModelScopeLaunchBlock</code>, переменная label становится равной 1</p></li><li><p>В функции <code>fetchPosts()</code> вызывается <code>withContext()</code>, который также как и <code>viewModelScope.launch()</code> принимает suspend блок, поэтому генерируется реализация <code>WithContextBlock</code></p></li><li><p>Создаётся <code>DispatchedCoroutine</code> и передаётся в качестве параметра completion в <code>WithContextBlock</code>.<br/>Обратите внимание, что <code>DispatchedCoroutine</code> в качестве объекта <code>Continuation</code> принимает <code>ViewModelScopeLaunchBlock</code>, блок из которого вызывается функция <code>withContext()</code>, так как нам нужно каким-то образом вернуть результат обратно.</p></li><li><p><code>WithContextBlock</code> запускается аналогично <code>ViewModelScopeLaunchBlock</code>, также оборачивается в <code>DispatchedContinuation</code>, только теперь в качестве диспатчера передаётся <code>Dispatchers.IO</code>.</p></li><li><p>Вызывается <code>DispatchedContinuation.resumeCancellableWith()</code> для <code>WithContextBlock</code>, где происходит переключение главного потока на background поток через <code>Dispatchers.IO</code> диспатчер,  <code>WithContextBlock.resumeWith()</code> теперь будет выполняться на background потоке</p></li><li><p><code>DispatchedCoroutine</code> не может отдать сразу результат запроса и поэтому <code>fetchPosts()</code> в <code>ViewModelScopeLaunchBlock.invokeSuspend()</code> возвращает <code>COROUTINE_SUSPENDED</code>, что приводит к приостановке корутины </p></li><li><p>Метод <code>WithContextBlock.invokeSuspend()</code> выполняет единственную ветку кода - запрос в сеть и получение ответа на background потоке.</p></li><li><p>Когда запрос завершится метод <code>WithContextBlock.invokeSuspend()</code> вернёт результат в <code>WithContextBlock.resumeWith()</code>, где произойдёт дальнейшая отправка результата через вызов <code>completion.resumeWith()</code> в объект корутины, в данном случае это <code>DispatchedCoroutine</code> </p></li><li><p>В <code>DispatchedCoroutine.resumeWith()</code> сначала произойдёт проверка на дочерние корутины в состоянии выполнения и если их нет, как в данном примере, выполнится код <code>DispatchedCoroutine.afterResume()</code></p></li><li><p>Метод <code>DispatchedCoroutine.afterResume()</code> должен вернуть результат в <code>ViewModelScopeLaunchBlock</code>, но здесь есть проблема: <code>WithContextBlock</code> сейчас выполняется на background потоке, который предоставил <code>Dispatchers.IO</code>, а <code>ViewModelScopeLaunchBlock</code> должен получить результат на главном, поэтому вызывается цепочка <code>continuation.intercepted().resumeCancellableWith()</code>, метод <code>intercepted()</code> не будет повторно оборачивать <code>ViewModelScopeLaunchBlock</code> в <code>DispatchedContinuation</code>, это сделано для оптимизации</p></li><li><p>Снова вызывается <code>DispatchedContinuation.resumeCancellableWith()</code> для <code>ViewModelScopeLaunchBlock</code>, но только теперь происходит переключение на главный поток через диспатчер <code>Dispatchers.Main.immediate</code>, если вы не забыли там под капотом <code>Handler.post()</code> вызов, в итоге  <code>ViewModelScopeLaunchBlock.resumeWith()</code> выполняется на главном потоке, а в качестве результата передаётся список постов</p></li><li><p>В  <code>ViewModelScopeLaunchBlock.resumeWith()</code> происходит второй вызов <code>ViewModelScopeLaunchBlock.invokeSuspend()</code>, теперь уже выполняется вторая ветка (label == 1), которая берёт список постов и выводит его в консоль.</p></li><li><p>Метод <code>ViewModelScopeLaunchBlock.invokeSuspend()</code> завершается успешно без приостановки, поэтому <code>ViewModelScopeLaunchBlock.resumeWith()</code> заканчивает своё выполнение и делает вызов <code>completion.resumeWith()</code>, где в качестве completion выступает корутина <code>StandaloneCoroutine</code></p></li><li><p>В <code>StandaloneCoroutine.resumeWith()</code> происходит проверка на дочерние корутины в состоянии выполнения, их в данном примере нет, корутина завершается.</p></li></ol><p>Если вы дошли до этого момента, то вы явно не простой перец, обязательно сделайте перерыв с шоколадкой и попробуйте аналогичным образом проследить путь выполнение корутин в своём коде.</p><p>К сожалению это ещё не конец, корутины могут запускаться в других корутинах и не по одной, а целыми пачками, здесь работает похожий механизм с диспатчерами, но помимо него есть ещё и <code>EventLoop</code>, если вы уже отдохнули и готовы сделать последний рывок, продолжаем!</p><h2>Дочерние корутины, EventLoop и runBlocking</h2><p>Выполнение дочерних корутин важно разграничивать на два вида:</p><ol><li><p>Дочерняя корутина запускается через диспатчер</p></li><li><p>Дочерняя корутина выполняется на <code>EventLoop</code>'е</p></li></ol><p>Первый случай возникает, когда диспатчер всегда переключает выполнение корутины, даже если она выполняется на правильном потоке, например <code>Dispatchers.Main</code>, второй же свойственен для диспатчеров, где переключение происходит только по необходимости, яркий пример из Android: <code>Dispatchers.Main.immediate</code>, который переключает выполнение корутины на главный поток, только если она не выполняется на нём.</p><p>Что ж, рассмотрим по порядку оба случая, начнём с первого:</p><pre><code class="kotlin">/*
Dispatchers.Main всегда переключает выполнение корутины 
на главный поток через Handler.post() механизм, 
даже если корутина и так выполняется на главном
*/
val uiScope = CoroutineScope(Dispatchers.Main + Job())
uiScope.launch {
    launch {
        println("I'm child coroutine #1")
    }
    launch {
        println("I'm child coroutine #2")
    }
    println("I'm parent coroutine")
}

// примерно во что всё это превратится

class UiScopeParentBlock(
    completion: StandaloneCoroutine
) : ContinuationImpl(completion) {

    var label = 0

    fun resumeWith(result: Result&lt;Any?&gt;) {
        try {
            val newResult = invokeSuspend(result)
            if (outcome === COROUTINE_SUSPENDED) return
            Result.success(newResult)
        } catch (exception: Throwable) {
            Result.failure(exception)
        }
        completion.resumeWith(newResult)
    }

    fun invokeSuspend(result: Result&lt;Any?&gt;): Any? {
        when(label) {
            0 -&gt; {
                throwIfFailureResult(result)
                println("I'm parent coroutine")
                return Unit
            }
            else -&gt; error("Illegal state")
        }
    }
  
}

class UiScopeChild1Block(
    completion: UiScopeParentBlock
) : ContinuationImpl(completion) {

    var label = 0

    fun resumeWith(result: Result&lt;Any?&gt;) {
        try {
            val newResult = invokeSuspend(result)
            if (outcome === COROUTINE_SUSPENDED) return
            Result.success(newResult)
        } catch (exception: Throwable) {
            Result.failure(exception)
        }
        completion.resumeWith(newResult)
    }

    fun invokeSuspend(result: Result&lt;Any?&gt;): Any? {
        when(label) {
            0 -&gt; {
                throwIfFailureResult(result)
                println("I'm child coroutine #1")
                return Unit
            }
            else -&gt; error("Illegal state")
        }
    }
  
}

class UiScopeChild2Block(
    completion: UiScopeParentBlock
) : ContinuationImpl(completion) {

    var label = 0

    fun resumeWith(result: Result&lt;Any?&gt;) {
        try {
            val newResult = invokeSuspend(result)
            if (outcome === COROUTINE_SUSPENDED) return
            Result.success(newResult)
        } catch (exception: Throwable) {
            Result.failure(exception)
        }
        completion.resumeWith(newResult)
    }

    fun invokeSuspend(result: Result&lt;Any?&gt;): Any? {
        when(label) {
            0 -&gt; {
                throwIfFailureResult(result)
                println("I'm child coroutine #2")
                return Unit
            }
            else -&gt; error("Illegal state")
        }
    }
  
}

class StandaloneCoroutine(...) {

    fun resumeWith(result: Result&lt;T&gt;) {
        val state = makeCompletingOnce(result.toState())
        /*
        resumeWith() не завершится полностью пока 
        дочерние корутины не закончат своё выполнение

        когда мы рассматривали код StandaloneCoroutine, то можно было
        увидеть как происходит добавление Job'ы дочерней корутины в Job'у
        родительской, поэтому родительская корутина знает состояния 
        своих дочерних корутин
        */
        if (state === COMPLETING_WAITING_CHILDREN) return
        afterResume(state)
    }
  
}

// родительская корутина
val parentCoroutine = StandaloneCoroutine(...)

val uiScopeParentBlock = UiScopeParentBlock(
    completion = parentCoroutine
)

DispatchedContinuation(
  dispatcher = Dispachers.Main
  continuation = uiScopeParentBlock
).resumeCancellableWith(Result.success(Unit))

// первая дочерняя корутина
val childCoroutine1 = StandaloneCoroutine(...)

val uiScopeChild1Block = UiScopeChild1Block(
    completion = childCoroutine1
)

DispatchedContinuation(
  dispatcher = Dispachers.Main
  continuation = uiScopeChild1Block
).resumeCancellableWith(Result.success(Unit))

// вторая дочерняя корутина
val childCoroutine2 = StandaloneCoroutine(...)

val uiScopeChild1Block = UiScopeChild1Block(
    completion = childCoroutine2
)

DispatchedContinuation(
  dispatcher = Dispachers.Main
  continuation = uiScopeChild1Block
).resumeCancellableWith(Result.success(Unit))</code></pre><p>Я не буду расписывать отдельные шаги, как это было в прошлом разделе, вы сами прекрасно можете справиться с этим, к тому же это будет хорошей практикой для закрепления знаний, вкратце основная суть: </p><ol><li><p>Родительская корутина <code>StandaloneCoroutine</code> не будет завершена до тех пор пока все её дочерние корутины не выполнились. При создании новой корутины её объект <code>Job</code> добавляется в качестве дочернего элемента в объект <code>Job</code> родительской корутины, благодаря этому корутины могут отслеживать состояния своих детей.</p></li><li><p>suspend блоки дочерних корутин <code>UiScopeChild1Block</code> и <code>UiScopeChild2Block</code> будут обёрнуты в <code>DispatchedContinuation</code> и переключены на главный поток через <code>Handler.post()</code> в не зависимости была ли родительская корутина изначательно на главном потоке или нет, <code>Dispatchers.Main</code> в отличии от <code>Dispatchers.Main.immediate</code> всегда делает переключение.</p></li><li><p>Объект <code>Continuation</code> родительской корутины никак не связан с <code>Continuation</code> объектами дочерних корутин, поэтому когда завершатся последние результат не будет проброшен обратно в <code>UiScopeParentBlock</code>, да и в этом особо нет смысла, как например с <code>withContext()</code>, который гарантирует последовательный порядок выполнения с возвращением результата.</p></li><li><p>Диспатчеры в принципе не могут гарантировать порядок выполнения, так как выполняют код асинхронно, тот же метод <code>Handler.post()</code> из Android не даёт 100% уверенности, что код всегда будет выполняться в том порядке, который мы запланировали.</p></li></ol><p>С запуском дочерних корутин через диспатчеры в целом разобрались, но что произойдёт если например у нас диспатчер <code>Dispatchers.Main.immediate</code> и все корутины выполняются на главном потоке, дочерние корутины ведь не будут переключаться снова через <code>Handler.post()</code> как это было с <code>Dispatchers.Main</code>, в таком случае начинает работать так называемый <code>EventLoop</code>:</p><pre><code class="kotlin">// метод из DispatchedContinuation
internal inline fun resumeCancellableWith(
    result: Result&lt;T&gt;,
    noinline onCancellation: ((cause: Throwable) -&gt; Unit)?
) {
    val state = result.toState(onCancellation)
    if (dispatcher.isDispatchNeeded(context)) {
        // ...
    } else {
        /*
        executeUnconfined делает одну из двух вещей:
        
        1) выполняет лямбду на EventLoop'е
        2) ставит лямбду в очередь EventLoop'а
        */
        executeUnconfined(state, MODE_CANCELLABLE) {
            continuation.resumeWith(result)
        }
    }
}

private inline fun DispatchedContinuation&lt;*&gt;.executeUnconfined(
    contState: Any?, mode: Int, doYield: Boolean = false,
    block: () -&gt; Unit
): Boolean {
    // EventLoop - штука куда кладутся лямбды в очередь на исполнение
    val eventLoop = ThreadLocalEventLoop.eventLoop

    // isUnconfinedLoopActive изначательно равен false поэтому для
    // родительской корутины срабатывает вторая ветка, а для дочерних - первая
    return if (eventLoop.isUnconfinedLoopActive) {
        _state = contState
        resumeMode = mode
        // выполнение дочерних корутин ставится в очередь EventLoop'а
        eventLoop.dispatchUnconfined(this)
        true
    } else {
        /*
        выполняет Continuation.resumeWith() для родительской корутины,
        дочерние в этот момент создаются и кладутся в очередь EventLoop'а, 
        после завершения инициализация родительской корутины дочерние
        по очереди берутся из EventLoop'а и выполняются
        */
        runUnconfinedEventLoop(eventLoop, block = block)
        false
    }
}
</code></pre><p>Считайте что <code>EventLoop</code> это простая очередь задач или лямбд как в нашем случае, куда кладутся запросы на выполнение дочерних корутин, затем они выполняются в том порядке, в котором были добавлены в очередь, как раз такая организация обеспечивает последовательное выполнение корутин:</p><pre><code class="kotlin">/*
viewModelScope под капотом использует Dispatchers.Main.immediate,
который не будет переключать дочерние корутины, так как они и так
находятся на главном потоке, поэтому будет задействован 
механизм EventLoop'а
*/
viewModelScope.launch {
    launch {
        println("I'm the second!")
    }
    launch {
        println("I'm the third!")
    }
    /*
    весь блок кода в родительской корутине выполняется 
    до момента выполнения дочерних корутин, это необходимо
    чтобы поставить дочерние корутины в очередь, 
    а потом начать их выполнять
    */
    println("I'm the first!")
}</code></pre><p>В качестве дополнения приведу ещё парочку интересных особенностей <code>EventLoop</code>'а:</p><ol><li><p><code>EventLoop</code> наследуется от <code>CoroutineDispatcher</code> и может быть использован в корутинах, например так работает <code>runBlocking()</code></p></li><li><p><code>EventLoop</code> создаётся для каждого потока чере механизм <code>ThreadLocal</code> переменных, как например экземпляр <code>Looper</code> класса из Android</p></li><li><p>Под капотом <code>EventLoop</code> лежит <code>ArrayDeque</code> из Kotlin коллекций для формирования очереди задач.</p></li></ol><p>Напоследок рассмотрим как <code>runBlocking()</code> ждёт завершения своих корутин и соблюдает их порядок, хотя ответ очевиден - используется <code>EventLoop</code>:</p><pre><code class="kotlin">/*
EventLoop создаётся на основе переданного CoroutineContext'а и кладётся 
в специальную корутину BlockingCoroutine, затем вызывается 
метод joinBlocking(), который ждёт пока все дочерние корутины 
не выполнятся
*/
actual fun &lt;T&gt; runBlocking(
    context: CoroutineContext, 
    block: suspend CoroutineScope.() -&gt; T
): T {  
    val currentThread = Thread.currentThread()
    val eventLoop: EventLoop = ...
    val newContext: CoroutineContext = ...
    val coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)
    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)
    return coroutine.joinBlocking()
}

private class BlockingCoroutine&lt;T&gt;(
    parentContext: CoroutineContext,
    private val blockedThread: Thread,
    private val eventLoop: EventLoop?
) : AbstractCoroutine&lt;T&gt;(parentContext, true, true) {

    /*
    ожидание происходит в while(true) цикле, а любой бесконечный цикл 
    как вы уже догадываетесь блокирует текущий поток, отсюда 
    и название runBlocking
    чтобы завершить цикл ожидания нужно поменять isCompleted на false,
    это произойдет только когда все дочерние корутины завершатся
    */
    fun joinBlocking(): T {
        registerTimeLoopThread()
        try {
            eventLoop?.incrementUseCount()
            try {
                while (true) {
                    eventLoop?.processNextEvent()
                    if (isCompleted) break
                }
            } finally { // paranoia
                eventLoop?.decrementUseCount()
            }
        } finally { // paranoia
            unregisterTimeLoopThread()
        }
        val state = this.state.unboxState()
        (state as? CompletedExceptionally)?.let { throw it.cause }
        return state as T
    }
}</code></pre><p>Именно благодаря бесконечному циклу <code>runBlocking()</code> дожидается выполнения всех дочерних корутин, при этом блокируя текущий поток.</p><p>Хотелось бы добавить что порядок в <code>runBlocking()</code> будет гарантироваться только когда корутины выполняются без каких либо асинхронных вызовов и переключений на другие диспатчеры, например здесь порядок не будет соблюдён:</p><pre><code class="kotlin">fun main() = runBlocking&lt;Unit&gt; {
    launch {
        val result = withContext(Dispatchers.IO) {
            delay(500)
            "I'm the second!"
        }
        println(result)
    }
    launch {
        println("I'm the first!")
    }
}</code></pre><h2>Заключение</h2><p>Не думал что и сам дотяну до этого момента, статья получилась очень объёмной и без капли самоуверенности заявляю охренительно полезной!</p><p>В качестве последних слов я собрал парочку фактов:</p><ol><li><p>Корутина - это всего лишь удобная абстракция над асинхронным выполнением кода. Примером асинхронного выполнения может быть переключение на другой поток, использование очереди главного потока (MessageQueue из Android) и тд.</p></li><li><p><code>Continuation</code> — кирпичик на котором построена практически вся библиотека корутин, является простейшим интерфейсом с единственным методом <code>resumeWith()</code>, данный метод вызывается когда происходит переход между состоянием приостановки корутины и состоянием её выполнения.</p></li><li><p>Состояние приостановки - так как корутины позволяют писать асинхронный код в последовательном стиле, то необходим механизм возвращения к точкам выполнения этого кода, в большинстве случаев такой механизм реализуется с помощью callback'ов, которыми как раз и являются <code>Continuation</code> реализации.</p></li><li><p>К реализациям <code>Continuation</code> интерфейса относятся: обычная корутина <code>StandaloneCoroutine</code>, сгенерированный suspend блок на базе <code>ContinuationImpl</code>, реализация для работы диспатчеров <code>DispatchedContinuation</code>, корутина используемая в <code>runBlocking()</code> методе - <code>BlockingCoroutine</code> и другие.</p></li><li><p><code>DispatchedContinuation</code> оборачивает другие <code>Continuation</code> объекты, это нужно для того чтобы выполнить <code>Continuation.resumeWith()</code> метод на <code>CoroutineDispatcher'е</code>.</p></li><li><p><code>CoroutineDispatcher</code> в большинстве случаев используется для переключения корутины на другой / другие потоки, но и есть и исключения, такие как <code>EventLoop</code> например, который позволяет выполнить корутины в правильном порядке.</p></li><li><p><code>EventLoop</code> - это простая очередь задач, куда кладутся запросы на выполнение корутин, а затем они выполняются в том порядке, в котором были добавлены в очередь, такая организация обеспечивает правильный порядок выполнения, но это работает только если ни в одной корутине не будет переключений через диспатчеры.</p></li></ol><p>Полезные ссылки:</p><ol><li><p><a href="https://t.me/android_under_the_hood" rel="noopener noreferrer nofollow">Мой телеграм канал</a></p></li><li><p><a href="https://www.youtube.com/watch?v=1kgnUDq_Xss" rel="noopener noreferrer nofollow">Доклад от Яндекса ШМР 2024</a></p></li><li><p><a href="https://www.youtube.com/watch?v=YD2GeSEJQtI" rel="noopener noreferrer nofollow">Курс по корутинам от Android Broadcast</a></p></li><li><p><a href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener noreferrer nofollow">Официальная дока</a></p></li><li><p><a href="https://www.youtube.com/watch?v=rB5Q3y73FTo" rel="noopener noreferrer nofollow">Крутой доклад от создателя библиотеки</a></p></li><li><p><a href="https://github.com/Kotlin/kotlinx.coroutines" rel="noopener noreferrer nofollow">Репозиторий библиотеки на Github'е</a></p></li></ol><p>Пишите в комментах ваше мнение и всем хорошего кода!</p><p></p></div></div></div><!-- --><!-- --></div><!-- --><!-- --></div><!--]--><!-- --><div class="tm-article-presenter__meta" data-test-id="article-meta-links"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[kotlin]"><span>kotlin</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[kotlin+coroutines]"><span>kotlin coroutines</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[android]"><span>android</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[android+development]"><span>android development</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[internals]"><span>internals</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[coroutines]"><span>coroutines</span></a><!--]--></li><!--]--><!-- --></ul></div><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/hubs/android_dev/"><!--[--><span>Разработка под Android</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/hubs/kotlin/"><!--[--><span>Kotlin</span><!--]--></a><!--]--></li><!--]--><!-- --></ul></div></div><!-- --><!--]--></article><!--]--></div><!-- --></div><div class="tm-article-sticky-panel" data-test-id="article-sticky-panel" style=""><div class="tm-data-icons tm-data-icons tm-data-icons_space-big tm-article-sticky-panel__icons" data-test-id="article-stats-icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon tm-votes-meter__icon_appearance-article" height="24" width="24"><title>Всего голосов 30: ↑30 и ↓0</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-rating"></use></svg><span class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating tm-votes-meter__value" data-test-id="votes-meter-value" title="Всего голосов 30: ↑30 и ↓0">+36</span></div><!--teleport start--><!--teleport end--><!-- --></div><!-- --><!-- --><button class="bookmarks-button tm-data-icons__item" title="Добавить в закладки" type="button"><span class="tm-svg-icon__wrapper bookmarks-button__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Добавить в закладки</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-favorite"></use></svg></span><span class="bookmarks-button__counter" title="Количество пользователей, добавивших публикацию в закладки">212</span></button><div class="tm-sharing tm-data-icons__item" title="Поделиться"><button class="tm-sharing__button" type="button"><svg class="tm-sharing__icon" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z" fill="currentColor"></path></svg></button><!--teleport start--><!--teleport end--></div><div class="tm-article-comments-counter-link tm-data-icons__item" title="Читать комментарии"><a class="tm-article-comments-counter-link__link" data-test-id="counter-comments" href="/ru/articles/827866/comments/"><!--[--><svg class="tm-svg-img tm-article-comments-counter-link__icon" height="24" width="24"><title>Комментарии</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value">8</span><!--]--></a><!-- --></div><!--[--><!--[--><!--[--><!-- --><!--]--><!--]--><!--]--><!--teleport start--><!--teleport end--><!-- --></div></div></div><!--[--><!--]--><div class="tm-article-presenter__footer"><!--[--><!--[--><div class="tm-article-blocks"><!-- --><!--[--><section class="tm-block tm-block tm-block_spacing-bottom"><!-- --><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-balanced"><!--[--><div class="tm-article-author" data-test-id="article-author-info"><!--[--><!--]--><div class="tm-user-card tm-user-card tm-user-card_variant-article tm-article-author__user-card" data-async-called="true"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a class="tm-user-card__userpic tm-user-card__userpic_size-40" href="/ru/users/DmitryTsyvtsyn/"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" src="//habrastorage.org/getpro/habr/avatars/db6/bea/5ea/db6bea5ea945afec3614eae955a8f2b1.jpeg"/></div></a><div class="tm-user-card__meta"><div class="tm-counter-container tm-karma tm-karma" title=" 24 голоса "><div class="tm-counter-container__header"><!--[--><div class="karma-display positive" data-v-7635202e="">20</div><!-- --><!--]--></div><div class="tm-counter-container__footer"><!--[--><div class="tm-karma__text">Карма</div><!--teleport start--><!--teleport end--><!--]--></div></div><div class="tm-counter-container" title="Рейтинг пользователя"><div class="tm-counter-container__header"><!--[--><!--[--><!--]--><div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating"><!-- --><div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score"><!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">4</span></span><!--]--></div><!-- --></div><!--]--></div><div class="tm-counter-container__footer"><!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]--></div></div></div></div></div><div class="tm-user-card__info tm-user-card__info_variant-article tm-user-card__info"><div class="tm-user-card__title tm-user-card__title_variant-article tm-user-card__title"><span class="tm-user-card__name tm-user-card__name_variant-article tm-user-card__name">Dmitry Tsyvtsyn</span><a class="tm-user-card__nickname tm-user-card__nickname tm-user-card__nickname_variant-article" href="/ru/users/DmitryTsyvtsyn/"> @DmitryTsyvtsyn</a><!-- --></div><p class="tm-user-card__short-info tm-user-card__short-info_variant-article tm-user-card__short-info" data-test-id="user-card-speciality">Android developer, photographer and traveler</p></div></div><div class="tm-user-card__buttons tm-user-card__buttons_variant-article tm-user-card__buttons"><!-- --><div class="tm-user-card__button"><div class="tm-button-follow tm-user-card__button-follow"><!-- --><button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button></div></div><!-- --><div class="tm-user-card__button tm-user-card__button_write" data-test-id="user-card-conversations"><svg class="tm-svg-img tm-user-card__button-icon" height="16" width="16"><title>Отправить сообщение</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#mail"></use></svg></div><!-- --></div><!-- --></div><!-- --></div><!--]--></div><!--]--><!-- --></section><!-- --><!--[--><div class="banner-wrapper leaderboard tm-page-article__banner" data-v-ad758baa="" style="--467224fc:200px;--58ff5eba:auto;"><!--[--><div class="placeholder-wrapper placeholder" data-v-ad758baa=""><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="adfox-banner-placeholder leaderboard" data-v-12f7bcca=""><div class="image loads" data-v-12f7bcca=""></div><div class="lines" data-v-12f7bcca=""><div class="line loads" data-v-12f7bcca=""></div><div class="line loads" data-v-12f7bcca=""></div><div class="line loads" data-v-12f7bcca=""></div></div></div><!-- --></div><div class="tm-adfox-banner" data-v-ad758baa="" id="adfox_164725660339535756"></div><!--]--></div><!--]--><!--]--><div class="tm-article-blocks__comments"><div class="tm-article-page-comments" id="publication-comments"><div><!--[--><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style" data-test-id="counter-comments" href="/ru/articles/827866/comments/"><!--[--><svg class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted" height="24" width="24"><title>Комментарии</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted"> Комментарии 8 </span><!--]--></a><!-- --></div><!--]--></div></div></div><!--[--><!--[--><!--]--><section class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header tm-block__header_variant-borderless"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title tm-block__title_variant-large">Публикации</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-condensed-slim"><!--[--><!--[--><div class="tm-tabs tm-tabs"><div class=""><!--[--><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link_active tm-tabs__tab-link_slim tm-tabs__tab-link">Лучшие за сутки</button></span><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link_slim tm-tabs__tab-link">Похожие</button></span><!--]--></div><!-- --></div><div class="similar-and-daily__tab-view"><div class="daily-articles-list"><ul class="tm-article-card-list"><!--[--><!--]--><div class="tm-bordered-card"><!-- --><!--[--><!--]--></div></ul><div class="daily-articles-block__button-container"><button class="btn btn_transparent btn_small tm-button tm-button_color-horizon" type="button"><!--[--><!--[-->Показать лучшие за всё время<!--]--><!--]--></button></div></div><!-- --></div><!--]--><!--]--></div><!--]--><!-- --></section><!--[--><div><div class="placeholder-wrapper"><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="tm-placeholder-promo"><div class="tm-placeholder-promo__header"><div class="tm-placeholder__line tm-placeholder__line_promo-title"></div></div><div class="tm-placeholder-promo__body"><div class="tm-placeholder-promo__posts"><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div></div><div class="tm-placeholder-promo__dots"><div class="tm-placeholder-promo__dot"></div><div class="tm-placeholder-promo__dot"></div><div class="tm-placeholder-promo__dot"></div></div></div></div><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --></div></div><div class="placeholder-wrapper"><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="tm-placeholder-inset tm-placeholder-vacancies"><div class="tm-placeholder-inset__header"><div class="tm-placeholder__line tm-placeholder__line_inset-header loads"></div></div><div class="tm-placeholder-inset__body"><ul class="tm-placeholder-list"><!--[--><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><!--]--></ul></div><div class="tm-placeholder-inset__footer"><div class="tm-placeholder__line tm-placeholder__line_inset-footer loads"></div></div></div><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --></div><!--]--><!-- --><!--[--><!--]--><!--]--></div><!--]--><!--]--></div></div><!--]--><!--]--></div></div><div class="tm-page__sidebar"><!--[--><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div><div class="tm-sexy-sidebar_initial tm-sexy-sidebar" style="margin-top:0px;"><!--[--><!--]--><!-- --><div class="tm-layout-sidebar__ads_initial tm-layout-sidebar__ads"><div class="banner-wrapper half-page tm-layout-sidebar__banner tm-layout-sidebar__banner_top" data-v-ad758baa="" style="--467224fc:600px;--58ff5eba:auto;"><!--[--><div class="placeholder-wrapper placeholder" data-v-ad758baa=""><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="adfox-banner-placeholder half-page" data-v-12f7bcca=""><div class="image loads" data-v-12f7bcca=""></div><div class="lines" data-v-12f7bcca=""><div class="line loads" data-v-12f7bcca=""></div><div class="line loads" data-v-12f7bcca=""></div><div class="line loads" data-v-12f7bcca=""></div></div></div><!-- --></div><div class="tm-adfox-banner" data-v-ad758baa="" id="adfox_164725680533065327"></div><!--]--></div></div><!--[--><!-- --><section class="tm-block tm-block tm-block_spacing-around tm-stories-block" data-async-called="true" data-navigatable="" tabindex="0"><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Истории</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-equal"><!--[--><div class="tm-stories-empty"><!--[--><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><!--]--></div><!-- --><!--]--></div><!--]--><!-- --></section><section class="tm-block tm-block tm-block_spacing-around" data-async-called="true"><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Работа</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body"><!--[--><!--[--><div class="tm-vacancies-block__item"><a class="tm-vacancies-block__vacancy-title" href="https://career.habr.com/vacancies/android_developer" target="_blank">Android разработчик </a><div class="tm-vacancies-block__vacancies-count">10
    вакансий</div></div><!--]--><!--]--></div><!--]--><footer class="tm-block__footer"><!--[--><a class="tm-block-extralink" href="https://career.habr.com/catalog">Все вакансии</a><!--]--></footer></section><section class="tm-block tm-block tm-block_spacing-around block" data-async-called="true" data-v-ebf6a21b=""><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Ближайшие события</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body"><!--[--><div class="swiper-container slider" data-v-ebf6a21b="" style="--swiper-space-between:22px;"><div class="swiper-wrapper"><!--[--><!--[--><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="588" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/588/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/f79/1fc/79d/f791fc79d0d9fdda84397ed0c0717764.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/f79/1fc/79d/f791fc79d0d9fdda84397ed0c0717764.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/f79/1fc/79d/f791fc79d0d9fdda84397ed0c0717764.png, https://habrastorage.org/getpro/habr/upload_files/f79/1fc/79d/f791fc79d0d9fdda84397ed0c0717764.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>17  февраля   – 24  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/588/"><span>Конкурс «Снежный код» от Хекслета. Три гранта на бесплатное 10-месячное обучение</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#588">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="596" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/596/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/b14/cd3/772/b14cd3772bc67698c8fbfd846e23824a.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/b14/cd3/772/b14cd3772bc67698c8fbfd846e23824a.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/b14/cd3/772/b14cd3772bc67698c8fbfd846e23824a.png, https://habrastorage.org/getpro/habr/upload_files/b14/cd3/772/b14cd3772bc67698c8fbfd846e23824a.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>20  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/596/"><span>Офлайн-конференция Хабр х K-team: как удерживать таланты в 2025 году</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#596">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="604" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/604/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/733/9ef/194/7339ef1945f3ee6906daf89db79829d4.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/733/9ef/194/7339ef1945f3ee6906daf89db79829d4.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/733/9ef/194/7339ef1945f3ee6906daf89db79829d4.png, https://habrastorage.org/getpro/habr/upload_files/733/9ef/194/7339ef1945f3ee6906daf89db79829d4.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>20  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/604/"><span>IX HappyWorkForum | Аутентичность и ментальное здоровье персонала</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><span class="tm-event-card__places-separator"> • </span></span><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#604">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="612" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/612/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/38f/10d/f4c/38f10df4c7f9d7c5d4610fe426af0ab4.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/38f/10d/f4c/38f10df4c7f9d7c5d4610fe426af0ab4.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/38f/10d/f4c/38f10df4c7f9d7c5d4610fe426af0ab4.png, https://habrastorage.org/getpro/habr/upload_files/38f/10d/f4c/38f10df4c7f9d7c5d4610fe426af0ab4.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>20  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/612/"><span>Вебинар «Мастерская бюджета: как управлять затратами на облачные ресурсы»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#612">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-admin"><span>Администрирование</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="616" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/616/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/523/7fb/13a/5237fb13ad7fb6fb483c49691aaec836.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/523/7fb/13a/5237fb13ad7fb6fb483c49691aaec836.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/523/7fb/13a/5237fb13ad7fb6fb483c49691aaec836.png, https://habrastorage.org/getpro/habr/upload_files/523/7fb/13a/5237fb13ad7fb6fb483c49691aaec836.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>21  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/616/"><span>Бизнес-конференция «Digital Brand Day 2025: Орбита 2025»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#616">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-marketing"><span>Маркетинг</span></div><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="606" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/606/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/400/0cb/fb8/4000cbfb86e5b97097f11d84cc50f089.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/400/0cb/fb8/4000cbfb86e5b97097f11d84cc50f089.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/400/0cb/fb8/4000cbfb86e5b97097f11d84cc50f089.png, https://habrastorage.org/getpro/habr/upload_files/400/0cb/fb8/4000cbfb86e5b97097f11d84cc50f089.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>24  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/606/"><span>Серия вебинаров «DevOps Middle: AvitoTech vs X5 Tech»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#606">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-admin"><span>Администрирование</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="608" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/608/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/8fd/e04/ddd/8fde04ddd9ba3f6bcd515aa6209f96b7.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/8fd/e04/ddd/8fde04ddd9ba3f6bcd515aa6209f96b7.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/8fd/e04/ddd/8fde04ddd9ba3f6bcd515aa6209f96b7.png, https://habrastorage.org/getpro/habr/upload_files/8fd/e04/ddd/8fde04ddd9ba3f6bcd515aa6209f96b7.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>27  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/608/"><span>Вебинар «Контент-маркетинг здорового человека: как привлечь внимание аудитории»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#608">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-marketing"><span>Маркетинг</span></div><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="618" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/618/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/f76/0f9/a82/f760f9a827b851a5eeca4802c643a91d.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/f76/0f9/a82/f760f9a827b851a5eeca4802c643a91d.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/f76/0f9/a82/f760f9a827b851a5eeca4802c643a91d.png, https://habrastorage.org/getpro/habr/upload_files/f76/0f9/a82/f760f9a827b851a5eeca4802c643a91d.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>3  апреля  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/618/"><span>Реалити для разработчиков: узнайте, как строится новое публичное облако MWS</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#618">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="620" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/620/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/eba/c37/879/ebac378793b959ebce42f41713e7b67f.jpg" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/eba/c37/879/ebac378793b959ebce42f41713e7b67f.jpg" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/eba/c37/879/ebac378793b959ebce42f41713e7b67f.jpg, https://habrastorage.org/getpro/habr/upload_files/eba/c37/879/ebac378793b959ebce42f41713e7b67f.jpg 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>3  апреля  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/620/"><span>Открытая встреча «System Analysis Meetup SberHealth»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><span class="tm-event-card__places-separator"> • </span></span><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#620">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-analytics"><span>Аналитика</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="590" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/590/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/31b/e68/295/31be6829578e7934fbc944396eb330b1.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/31b/e68/295/31be6829578e7934fbc944396eb330b1.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/31b/e68/295/31be6829578e7934fbc944396eb330b1.png, https://habrastorage.org/getpro/habr/upload_files/31b/e68/295/31be6829578e7934fbc944396eb330b1.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>10  апреля  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/590/"><span>«GoCloud 2025» — масштабная IT-конференция про облака и AI</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><span class="tm-event-card__places-separator"> • </span></span><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#590">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-admin"><span>Администрирование</span></div><div class="event-category__label event-category__label_type-management"><span>Менеджмент</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="516" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/516/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/0e9/3a8/3ec/0e93a83ecea09f806d1df907ddb036a4.jpg" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/0e9/3a8/3ec/0e93a83ecea09f806d1df907ddb036a4.jpg" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/0e9/3a8/3ec/0e93a83ecea09f806d1df907ddb036a4.jpg, https://habrastorage.org/getpro/habr/upload_files/0e9/3a8/3ec/0e93a83ecea09f806d1df907ddb036a4.jpg 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>25 – 26  апреля  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/516/"><span>IT-конференция Merge Tatarstan 2025</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Казань</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#516">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-marketing"><span>Маркетинг</span></div><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="610" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/610/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/652/12d/998/65212d998fb4939d9787bd9c726d2acb.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/652/12d/998/65212d998fb4939d9787bd9c726d2acb.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/652/12d/998/65212d998fb4939d9787bd9c726d2acb.png, https://habrastorage.org/getpro/habr/upload_files/652/12d/998/65212d998fb4939d9787bd9c726d2acb.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>20 – 22  июня  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/610/"><span>Летняя айти-тусовка Summer Merge</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Ульяновская область</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#610">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><!--]--><!--]--></div><!-- --><!--[--><button class="swiper-button-prev"><span class="tm-svg-icon__wrapper swiper-button-icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Влево</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#arrow-back"></use></svg></span></button><button class="swiper-button-next"><span class="tm-svg-icon__wrapper swiper-button-icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Вправо</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#arrow-back"></use></svg></span></button><!--]--></div><!--]--></div><!--]--><!-- --></section><!--]--><div class="banner-wrapper medium-rectangle tm-layout-sidebar__banner tm-layout-sidebar__banner_bottom" data-v-ad758baa="" style="--467224fc:250px;--58ff5eba:auto;"><!--[--><div class="placeholder-wrapper placeholder" data-v-ad758baa=""><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="adfox-banner-placeholder medium-rectangle" data-v-12f7bcca=""><div class="image loads" data-v-12f7bcca=""></div><div class="lines" data-v-12f7bcca=""><div class="line loads" data-v-12f7bcca=""></div><div class="line loads" data-v-12f7bcca=""></div><div class="line loads" data-v-12f7bcca=""></div></div></div><!-- --></div><div class="tm-adfox-banner" data-v-ad758baa="" id="adfox_164725691003361602"></div><!--]--></div></div></div><!--]--></div></div><!-- --><!--]--></div></div></main><!-- --></div><div class="tm-footer-menu"><div class="tm-page-width"><!--[--><div class="tm-footer-menu__container"><!--[--><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Ваш аккаунт</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/articles/827866/&amp;hl=ru" rel="nofollow" target="_self">Войти</a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/articles/827866/&amp;hl=ru" rel="nofollow" target="_self">Регистрация</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Разделы</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/articles/">Статьи</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/news/">Новости</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/hubs/">Хабы</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/companies/">Компании</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/users/">Авторы</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/sandbox/">Песочница</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Информация</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/help/">Устройство сайта</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/authors/codex/">Для авторов</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/companies/corpblogs/">Для компаний</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/docs/transparency/">Документы</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement/?hl=ru_RU" target="_blank">Соглашение</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/?hl=ru_RU" target="_blank">Конфиденциальность</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Услуги</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/corporate-blogs/" target="_blank">Корпоративный блог</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/advertising/" target="_blank">Медийная реклама</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/native-special/" target="_blank">Нативные проекты</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/education-programs/" target="_blank">Образовательные программы</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/hello-startup/" target="_blank">Стартапам</a></li><!--]--></ul></div></div><!--]--></div><!--]--></div></div><div class="tm-footer"><div class="tm-page-width"><!--[--><div class="tm-footer__container"><!-- --><div class="tm-footer__social"><!--[--><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Facebook</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Twitter</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>VK</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-vk"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Telegram</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Youtube</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://dzen.ru/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Яндекс Дзен</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-dzen"></use></svg></a><!--]--></div><!--teleport start--><!--teleport end--><button class="tm-footer__link"><!-- --> Настройка языка</button><a class="tm-footer__link" href="/ru/feedback/">Техническая поддержка</a><div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2025, </span><span class="tm-copyright__name"><a class="tm-copyright__link" href="https://company.habr.com/" rel="noopener" target="_blank">Habr</a></span></span></div></div><!--]--></div></div><!-- --><!--]--></div><!-- --></div></div>
<div id="overlays"><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--></div>
</body>
</html>
