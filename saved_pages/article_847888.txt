<!DOCTYPE html>

<html lang="ru">
<head>
<title>Новый подход к безопасному управлению состояниями в Kotlin-приложениях / Хабр</title>
</head>
<body>
<div id="mount"><div data-async-called="true" id="app"><div class="tm-layout__wrapper"><!--[--><!-- --><div></div><!-- --><header class="tm-header" data-test-id="header"><div class="tm-page-width"><!--[--><div class="tm-header__container"><!-- --><span class="tm-header__logo-wrap"><a class="tm-header__logo tm-header__logo_hl-ru tm-header__logo" href="/ru/"><svg class="tm-svg-img tm-header__icon" height="16" width="16"><title>Хабр</title><use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a><span class="tm-header__beta-sign" style="display:none;">β</span></span><!--[--><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><!--[--><button class="tm-header__dropdown-toggle"><svg class="tm-svg-img tm-header__icon tm-header__icon_dropdown" height="16" width="16"><title>Открыть список</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#arrow-down"></use></svg></button><!--]--></div><!-- --></div><a class="tm-header__become-author-btn" href="/ru/sandbox/start/">Как стать автором</a><div class="tm-feature tm-feature tm-feature_variant-inline tm-header__feature"><!-- --></div><!-- --><!--]--><!-- --></div><!--]--></div></header><div class="tm-layout"><div class="tm-page-progress-bar"></div><div class="tm-base-layout__header_is-sticky tm-base-layout__header" data-menu-sticky="true"><div class="tm-page-width"><!--[--><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/feed/">Моя лента</a><!--]--><!--[--><a class="tm-main-menu__item" href="/ru/articles/">Все потоки</a><!--]--><!--[--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/develop/">Разработка</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/admin/">Администрирование</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/design/">Дизайн</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/management/">Менеджмент</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/marketing/">Маркетинг</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/popsci/">Научпоп</a><!--]--><!--]--></nav></div></div><div class="tm-header-user-menu tm-base-layout__user-menu"><a class="tm-header-user-menu__item tm-header-user-menu__search" data-test-id="search-button" href="/ru/search/"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark" height="24" width="24"><title>Поиск</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#search"></use></svg></a><!-- --><!-- --><div class="tm-header-user-menu__item tm-header-user-menu__write"><div><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_write tm-header-user-menu__icon_dark" height="24" width="24"><title>Написать публикацию</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#write"></use></svg></div><!-- --></div><!--[--><div class="tm-header-user-menu__item"><button class="tm-header-user-menu__toggle" data-test-id="user-menu-settings"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_dark" height="24" width="24"><title>Настройки</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#page-settings"></use></svg></button></div><a class="tm-header-user-menu__item" href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/companies/otus/articles/847888/&amp;hl=ru" rel="nofollow"><!--[--><button class="btn btn_solid btn_small tm-header-user-menu__login" type="button"><!--[-->Войти<!--]--></button><!--]--></a><!--]--><!-- --><!--teleport start--><!--teleport end--><!-- --></div></div><!--]--></div></div><!-- --><div class="tm-page-width"><!--[--><!--]--></div><main class="tm-layout__container"><div class="tm-page" companyname="otus" data-async-called="true" hl="ru" style="--0c809c5a:16px;--a086013e:100%;--7c457026:0;"><div class="tm-page-width"><!--[--><div class="tm-page__header"><!--[--><!--]--></div><div class="tm-page__wrapper"><div class="tm-page__main_has-sidebar tm-page__main"><div class="pull-down"><!-- --><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg class="tm-svg-img pull-down__icon pull-down__arrow" height="24" width="24"><title>Обновить</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#pull-arrow"></use></svg></div></div><!--[--><!--[--><div class="tm-article-presenter"><!--[--><!--[--><!-- --><div class="tm-company-profile-card tm-company-article__profile-card"><div class="tm-company-card tm-company-profile-card__info"><div class="tm-company-card__header"><a class="tm-company-card__avatar" href="/ru/companies/otus/profile/"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" height="48" src="//habrastorage.org/getpro/habr/company/a65/525/4fe/a655254feebb0b25a027b5e276ea6489.png" width="48"/></div></a><!--[--><!-- --><div class="tm-counter-container tm-company-card__rating"><div class="tm-counter-container__header"><!--[--><!--[--><!--]--><div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating"><!-- --><div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score_no-margin tm-votes-lever__score"><!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">694.26</span></span><!--]--></div><!-- --></div><!--]--></div><div class="tm-counter-container__footer"><!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]--></div></div><!-- --><!--]--></div><div class="tm-company-card__info"><a class="tm-company-card__name" href="/ru/companies/otus/profile/"><span>OTUS</span></a><div class="tm-company-card__description">Цифровые навыки от ведущих экспертов</div></div></div><div class="tm-company-profile-card__buttons"><div class="tm-button-follow tm-company-profile-card__button tm-company-profile-card__button_follow"><!-- --><button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button></div><!-- --><!-- --><!-- --></div></div><!-- --><!--]--><!--]--><div class="tm-article-presenter__body" data-test-id="article-body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><!--[--><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><!--[--><div class="tm-article-presenter__header"><!--[--><!--]--><div class="tm-article-snippet tm-article-snippet tm-article-presenter__snippet"><!--[--><!--]--><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a class="tm-user-info__userpic" data-test-id="user-info-pic" href="/ru/users/MaxRokatansky/" title="MaxRokatansky"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" height="24" src="//habrastorage.org/r/w48/getpro/habr/avatars/b9f/baf/5f9/b9fbaf5f96ae52973706a0716bd9216e.jpg" width="24"/></div></a><span class="tm-user-info__user tm-user-info__user_appearance-default" data-test-id="user-info-description"><a class="tm-user-info__username" href="/ru/users/MaxRokatansky/">MaxRokatansky <!-- --></a><!--[--><span class="tm-article-datetime-published"><time datetime="2024-10-03T10:35:17.000Z" title="2024-10-03, 13:35">3  окт  2024 в 13:35</time></span><!--]--></span></span></div><!-- --></div><h1 class="tm-title tm-title_h1" data-test-id="articleTitle" lang="ru"><span>Новый подход к безопасному управлению состояниями в Kotlin-приложениях</span></h1><div class="tm-article-snippet__stats" data-test-id="articleStats"><!-- --><div class="tm-article-reading-time"><span class="tm-svg-icon__wrapper tm-article-reading-time__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Время на прочтение</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#clock"></use></svg></span><span class="tm-article-reading-time__label">20 мин</span></div><span class="tm-icon-counter tm-data-icons__item"><svg class="tm-svg-img tm-icon-counter__icon" height="24" width="24"><title>Количество просмотров</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-views"></use></svg><span class="tm-icon-counter__value" title="2916">2.9K</span></span></div><div class="tm-publication-hubs__container" data-test-id="articleHubsList"><div class="tm-publication-hubs"><!--[--><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/companies/otus/articles/"><!--[--><span>Блог компании OTUS</span><!-- --><!--]--></a></span><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/hubs/android_dev/"><!--[--><span>Разработка под Android</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/hubs/kotlin/"><!--[--><span>Kotlin</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><!--]--></div></div><div class="tm-article-labels" data-test-id="articleLabels"><div class="tm-article-labels__container"><!-- --><!--[--><div class="tm-publication-label tm-publication-label_variant-translation"><span>Перевод</span></div><!--]--></div></div><!-- --><!-- --></div></div><!--[--><div class="tm-article-presenter__origin"><a class="tm-article-presenter__origin-link" href="https://proandroiddev.com/how-to-safely-update-state-in-your-kotlin-apps-bf51ccebe2ef" target="_blank">Автор оригинала: <span>Nek.12</span></a></div><div class="tm-article-body" data-gallery-root="" lang="ru"><div><!--[--><!--]--></div><div id="post-content-body"><div><div class="article-formatted-body article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>Вот уже несколько лет я занимаюсь разработкой высокопроизводительных, полностью асинхронных, реактивных, мультиплатформенных приложений. За это время я успел наткнуться на несколько довольно тонких и трудно отлаживаемых проблем с управлением состояниями. В этой статье я хотел бы поделиться с вами своим опытом, который поможет вам сэкономить множество часов и нервных клеток, и предложить новый подход к управлению состояниями, который лично я никогда раньше не встречал и который навсегда избавит вас от этих проблем.</p><p>Итак, эта история началась примерно в то время, когда обрели свою популярность реактивные приложения с использованием MVI / MVVM+, и я начал делать свои первые шаги в их разработке. В этой статье я буду говорить в основном о MVI, потому что управление состояниями в MVI чуть более продвинутое, поэтому и примеры будут более наглядными, но те же проблемы и решения применимы и к MVVM (в котором также есть состояния).</p><p>Помните, как в одно время мы все помешались на однонаправленном потоке данных (UDF) и начали пихать его везде, куда только можно? В некоторых приложениях это породило отдельную категорию багов, получившую название "inconsistent state problem" (ICS или проблема несогласованного состояния). Позвольте мне продемонстрировать ее на реальном примере:</p><figure class="full-width"><img data-blurred="true" data-src="https://habrastorage.org/getpro/habr/upload_files/edc/4bc/d86/edc4bcd86771fe51302b6b094d7119d0.jpeg" height="492" src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/edc/4bc/d86/edc4bcd86771fe51302b6b094d7119d0.jpeg" width="875"/></figure><p>Заметили? Приложение одновременно отображает состояния "Загрузка", "Ошибка" и "Успех". Упс! Я уверен, что вы уже сталкивались, либо вам еще предстоит столкнуться с чем-то подобным при работе с UDF.</p><p>В этой статье мы решим эту проблему <strong>раз и навсегда.</strong></p><h2>Перед тем как начать: Что такое состояние? Что такое переход состояния?</h2><p>Для начала давайте разберемся, что такое состояние (state) в контексте этой статьи и что такое "переходы состояний" (state transactions).</p><p>Я определяю состояние приложения следующим образом:</p><p>Это объект или группа объектов, хранящихся <strong>в памяти</strong>, которые представляют состояние приложения в определенный момент времени и служат для хранения срезов данных, необходимых для работы приложения.</p><p>Если говорить простым языком, то я определяю состояние как:</p><p>Класс, представляющий самые последние данные, полученные приложением из его множества источников достоверных данных (sources of truth).</p><p>Самый распространенный пример состояния, с которым вы, скорее всего, хорошо знакомы, — это состояние пользовательского интерфейса (UI):</p><pre><code class="kotlin">data class UIState(
   val isLoading: Boolean = true,
   val error: Exception? = null,
   val items: List&lt;Item&gt;? = null,
)</code></pre><p>Обычно каждая страница (экран) нашего приложения имеет свое собственное состояние UI. Иногда состояние может быть разделено между различными компонентами (например, виджетами) приложения. Но что же такое "переход" состояния?</p><p>Переход (транзакция) состояния — это атомарная операция, которая изменяет текущее состояние приложения.</p><p>Переходы состояния происходят постоянно. Например, когда вам нужно загрузить какие-либо элементы из интернета или базы данных, вы должны сделать следующие три шага:</p><ol><li><p>Установить состояние для отображения индикатора загрузки.</p></li><li><p>Запросить элементы из источника данных и дождаться их поступления.</p></li><li><p>Установить состояние для отображения этих элементов.</p></li></ol><p>Минимальное количество операций, которые необходимо здесь выполнить, — <strong>две</strong>: одна для установки состояния загрузки и еще одна для установки состояния отображения элементов.</p><p>Причина, по которой мы должны выполнять переходы состояний, заключается в том, что наше состояние по умолчанию <strong>не зависит </strong>от состояния источника данных. Это означает, что в таблицу базы данных могут поступать новые элементы, но ваше состояние не будет изменяться, и вы будете показывать старые данные, если сами специально что-нибудь с этим не сделаете. О том, как решить эту проблему, я расскажу чуть позже.</p><p>Теперь давайте разберемся, в чем разница между <strong>постоянными</strong> (persistent) и <strong>временными </strong>(transient)<strong> </strong>состояниями.</p><p>Я определяю <strong>постоянное</strong> (или персистентное) состояние как:</p><p>Состояние приложения, которое не зависит от жизненного цикла приложения.</p><p>Типичными примерами могут послужить базы данных, сетевые серверы, соединения веб-сокетов, SavedStateHandles (в Android) и файлы. Все они имеют одну общую черту — они переживут жизненный цикл нашего работающего приложения.</p><p>Соответственно, <strong>временное</strong> состояние<strong> </strong>— это:</p><p>Состояние приложения, которое существует, пока процесс приложения жив, т.е. состояние, хранящееся <strong>в памяти</strong>.</p><p>Типичными примерами временного состояния могут послужить видимость индикатора загрузки, состояния ввода текста или сессии и соединения клиент&lt;&gt;бэкенд.</p><p>Согласно моему определению, <strong>приложения могут рассчитывать на постоянный доступ только ко временными состояниям</strong>. Это означает, что мы не можем использовать состояние базы данных напрямую — мы должны наблюдать за ним и реагировать на его изменения, надеясь, что наше временное состояние будет синхронизировано с состоянием базы данных. Уже догадываетесь, где тут могут возникнуть проблемы?</p><p>Прежде чем мы продолжим, последнее, что нам нужно прояснить, это то, как мы можем определять временные состояния в нашем коде.</p><p>Первый способ, используемый в MVI, заключается в создании <strong>единого объекта состояния</strong>, который представляет собой совокупность различных источников данных и временных подсостояний. Проще говоря, у нас есть только <strong>один </strong>объект состояния для каждого компонента бизнес-логики. Пример такого состояния был продемонстрирован выше.</p><p>Второй способ используется в MVVM — это <strong>несколько независимых </strong>объектов состояния, которые изменяются отдельно, в рамках одного блока бизнес-логики. Примером может быть:</p><pre><code class="kotlin">val isLoading = MutableStateFlow&lt;Boolean&gt;(true)
val error = MutableStateFlow&lt;Exception?&gt;(null)
val items = MutableStateFlow&lt;List&lt;Item&gt;?&gt;(null)</code></pre><p>Не поймите меня неправильно — нам всегда приходится декомпозировать состояния, будь то MVI или MVVM. Просто в MVI мы делаем это менее раздроблено, <strong>объединяя состояния в рамках компонента бизнес-логики</strong>. Объяснение того<em>, почему </em>мы могли бы хотеть делать именно так, вы найдете чуть дальше.</p><h2></h2><h2>Шаг 1: Делаем состояние реактивным</h2><p>В рамках UDF нашей целью является сделать состояние приложения <strong>зависимым </strong>от состояния источника данных.</p><p>Например, вместо того чтобы вручную устанавливать состояние для отображения элементов (шаг 3), мы можем сделать наше состояние <strong>подчиненным компонентом </strong>по отношению к состоянию источника данных. Это означает, что мы будем следить за изменениями в состоянии базы данных, и когда поступят новые данные, мы <strong>автоматически </strong>обновим состояние этими данными. В нашем примере мы можем сделать это с помощью триггеров базы данных, которые обычно предоставляются ORM. Мы подпишемся на наблюдаемый поток данных в нашей бизнес-логике, чтобы следить за этими изменениями. Но важно отметить, что мы не устранили переход состояния из приведенного выше примера, мы просто сделали его автоматическим, отделенным от нашей логики.</p><p>Итак, с точки зрения клиента (разработчика), наш поток сейчас:</p><ol><li><p>Установит состояние для отображения индикатора загрузки.</p></li></ol><p>"Подождите, а где же все остальное?" — спросите вы. По-моему, это самое большое обещание UDF — мы полагаемся на то, что наше состояние всегда будет поступать из надежного источника данных, так что нам не придется управлять им самостоятельно. В нашем случае мы просто должны "начать" с индикатора загрузки, а наш триггер базы данных сделает все остальное, запрашивая новые данные и наблюдая за их изменениями. Когда данные будут загружены, другая часть нашего кода установит наше временное состояние в соответствие с постоянным. То же самое можно проделать с сетевыми запросами, обернув их в реактивные потоки, такие как Cold Flows (холодные потоки) Coroutines:</p><pre><code class="kotlin">val items = flow {
   api.getLatestItems()
}</code></pre><p>Проще говоря, если мы подпишемся на поток, фреймворк лениво выполнит наш запрос и получит данные единожды, а затем будет повторно использовать их до тех пор, пока не завершится жизненный цикл компонента бизнес-логики.</p><p>В случае состояния, которое не подкреплено источником данных (оно <strong>изначально и всецело временное</strong>), мы можем просто создать наблюдаемый объект, например горячий поток (Hot Flow), и мутировать его при изменении данных вручную. Наши клиенты получат уведомление об изменении точно так же, как и в случае с постоянным состоянием. Мы как бы сами становимся своего рода триггером базы данных в данном случае.</p><pre><code class="kotlin">val username = MutableStateFlow&lt;String&gt;("")

fun onUsernameChanged(value: String) = username.value = value</code></pre><p>Вместо того чтобы изменять состояние напрямую, мы изменяем значение наблюдаемого потока, отслеживая действия пользователя в пользовательском интерфейсе и делегируя хранение изменений в наше свойство username.</p><h2></h2><h2>Шаг 2: Унификация состояний</h2><p>А теперь позвольте мне порассуждать о том, зачем нам может понадобиться унифицировать наше состояние и когда этого делать не стоит.</p><p>Обычно состояние унифицируется в рамках MVI, и делается это из следующих соображений:</p><ol><li><p>Мы предоставляем единую, четко определенную точку доступа к состоянию нашего приложения, готовую к потреблению клиентами.</p></li><li><p>Мы явно определяем все связанные изменения состояния в рамках одной транзакции (и, как следствие, в рамках одного легко понимаемого блока кода).</p></li><li><p>Мы сокращаем количество переходов состояния в случае, когда изменяется множество переменных, что повышает производительность.</p></li><li><p>Мы упрощаем использование и изменение связанных состояний, группируя их свойства вместе.</p></li><li><p>Мы защищаем себя от доступа к данным, к которым у нас не должно быть доступа во время компиляции.</p></li></ol><p>На мой взгляд, самое большое преимущество здесь — пятое. Если мы правильно унифицируем наши состояния, мы можем быть <strong>уверены</strong>, что не получим доступ к тому, к чему не должны были, еще до компиляции нашего приложения.</p><p>Посмотрите на предыдущий пример с MVVM:</p><pre><code class="kotlin">val isLoading = MutableStateFlow&lt;Boolean&gt;(true)
val error = MutableStateFlow&lt;Exception?&gt;(null)
val items = MutableStateFlow&lt;List&lt;Item&gt;?&gt;(null)</code></pre><p>Теперь увидели проблему? Мы должны объявить кучу переменных, которые являются null или "пустыми", потому что очень часто их просто нет. Мы также должны учитывать тот факт, что список элементов может быть не только пустым, но и вообще отсутствовать.</p><p>По моему скромному мнению, это значительно усложняет нашу бизнес-логику:</p><ol><li><p>Мы должны всегда проверять, присутствует ли значение, даже если мы уверены, что оно <strong>будет </strong>присутствовать в каком-то конкретном месте.</p></li><li><p>Мы всегда должны сохранять ссылки на значения, несмотря на то, что они могут быть не всегда нужны.</p></li><li><p>Мы всегда должны быть уверены, что очищаем каждое значение во время каждой манипуляции с состоянием, чтобы уведомить наш код о том, что значение пропало, и это было соответствующим образом отражено в пользовательском интерфейсе.</p></li><li><p>Мы должны передать все эти значения в наш пользовательский интерфейс и работать с ними там, что усложняет наш код. Кроме того, нам придется управлять полученным в итоге шаблоном.</p></li></ol><p>Это основные причины, по которым я предпочитаю унифицировать состояния до определенной (разумной) степени при использовании MVI. Это также, вероятно, причина, по которой Google (и большинство коммерческих современных приложений) отходят от традиционного MVVM и переходят к MVVM+ (то же самое, но с унифицированными состояниями).</p><p>Вы можете возразить: "Но я могу создать единый класс, и у него все равно останутся все те же проблемы!", ссылаясь на мой первый пример:</p><pre><code class="kotlin">data class UIState(
   val isLoading: Boolean = true,
   val error: Exception? = null,
   val items: List&lt;Item&gt;? = null,
)</code></pre><p>Вот здесь я и предлагаю новую парадигму для описания состояния, которая полагается на возможности языка, — мы перейдем к, как я их называю, <strong>семействам состояний</strong> (State Families).</p><h2>Шаг 3: Согласуем наши состояния, группируя их в семейства</h2><p>По сути, термин "семейство состояний" подразумевает следующее:</p><p>Мы определяем состояние приложения как <strong>закрытый </strong>список <strong>отдельных</strong>, несвязанных объектов, представляющих текущий <strong>тип </strong>состояния нашего приложения.</p><p>Если говорить о Kotlin, то это означает, что мы определим наше состояние как sealed interface и удалим из результирующего объекта все свойства, которых не должно быть, когда приложение имеет это состояние:</p><pre><code class="kotlin">internal sealed interface EditProfileState {


   data object Loading : EditProfileState
  
   data class Error(val e: Exception?) : EditProfileState
  
   data object Success : EditProfileState
  
   data object DisplayingAccountDeleted : EditProfileState
  
   data class EditingProfile(
       val email: String, // данные из хранилища
       val name: Input, // значение, введенное пользователем
   ) : EditProfileState
}</code></pre><p>Я называю это "полустейт-машинами" или "семействами состояний" потому, что, в отличие от полноценных стейт-машин, мы <strong>не определяем переходы </strong>между состояниями, поскольку их может быть слишком много. Но очень часто в клиентских приложениях это и не нужно. Ну как, уже видите преимущества такого подхода?</p><ol><li><p>Когда мы отображаем состояние Loading, мы уверены, что в нем нет и никогда не будет никаких данных, а следовательно и ошибок. Мы просто не можем получить доступ к этим значениям, чтобы ошибочно отобразить их для наших пользователей или манипулировать ими.</p></li><li><p>Когда мы отображаем состояние Error или EditingProfile, у нас больше нет необязательных (nullable) полей, которые не служат никакой цели. Находясь в состоянии Error, мы на 100% уверены, что отображается именно ошибка и <strong>ничего больше</strong>.</p></li><li><p>Наше состояние сгруппировано в одном месте, строго определено, как оно может выглядеть, и имеет четко определенный контракт на то, что должно присутствовать, что должно отсутствовать и что является необязательным, когда мы представляем определенное состояние.</p></li><li><p>У нас может быть столько состояний, сколько мы захотим, возможны "вложенные состояния", и мы можем создавать семейство состояний, используя любую комбинацию источников данных (даже наш старый код с кучей потоков!).</p></li></ol><p>Посмотрите, насколько мы продвинулись! Вот чего мы достигли благодаря смене парадигмы:</p><ol><li><p>Во-первых, мы значительно сократили количество состояний и переходов благодаря использованию UDF и реактивных потоков, что избавило нас от ряда проблем со сменой состояний.</p></li><li><p>Затем мы унифицировали наше состояние, упростив тем самым бизнес-логику, сделав наш код более понятным и расширяемым, а также сократив количество ошибок за счет удаления всех точек доступа к состоянию приложения и связанным с ним переходам, кроме одной.</p></li><li><p>Наконец, мы определили наше состояние как закрытое семейство типов, устранив все риски обращения к конкретным значениям, когда этого делать не следует, как в бизнес-, так и в клиентской (т.е. пользовательской) логике. Мы также получили наглядную, простую для понимания структуру кода и единое место, где мы можем хранить и управлять всеми нашими переходами и значениями состояния.</p></li></ol><p>К сожалению, этот подход не лишен недостатков. Теперь перед нами возникли две новые проблемы...</p><h2>Решение проблемы №1: Потерянная информация</h2><p>Поскольку теперь у нас есть единственный источник истины и отдельное семейство состояний, мы больше не можем "сохранять" наши предыдущие значения при изменении состояния.</p><p>Например, наше состояние Loading не содержит электронной почты или того, что пользователь ввел в качестве нового имени пользователя. Всякий раз, когда мы хотим показать индикатор загрузки, например, для проверки нового имени пользователя, мы <strong>теряем всю информацию о предыдущем состоянии </strong>приложения.</p><p>Эту проблему можно легко решить, передав состояние в код, которому может понадобиться восстановить предыдущее состояние или использовать его для своих нужд, но это требует небольшого сдвига парадигмы нашего мышления. Если мы захотим проверить пароль пользователя, нам нужно будет передавать предыдущее состояние вниз по иерархии вызовов:</p><pre><code class="kotlin">val state = MutableStateFlow&lt;EditProfileState&gt;(Loading)


fun onSaveChangesClicked(state: EditingProfile) {
   state.value = Loading
   validateNameAsync(state)
}


fun showValidationError(e: Exception) { /* отображаем снэкбар и т.д. */ } 


fun validateNameAsync(previous: EditingProfile) = launch {
   try {
       repository.verifyNameIsUnique(previous.name)
       state.value = Success
   } catch (e: Exception) {
       state.value = previous
       showValidationError(e)
   }
}</code></pre><p>Видите? Теперь мы захватываем состояние при запуске операции, запускаем ее асинхронно, а <strong>затем </strong>устанавливаем состояние в Loading. Наша операция в зависимости от результата может либо отобразить Success, либо вывести ошибку проверки и восстановить предыдущее (previous) состояние с помощью переданного параметра.</p><p>Код теперь выглядит немного иначе — создается впечатление, что мы и не восстанавливаем состояние и не показываем сообщение об успехе (сейчас это может показаться странным, но через пару минут я объясню, почему здесь такой странный порядок).</p><h2>Решение проблемы №2: Управление типом объекта</h2><p>Kotlin — статически типизированный язык, и поэтому нам нужно безопасно приводить состояние к определенному значению, чтобы приложение не крашилось. Приведение нужно потому, что иногда нам может понадобиться доступ к некоторым свойствам предыдущего состояния, если они присутствуют.</p><p>Например, всякий раз, когда мы хотим обновить текущее состояние новыми данными из внешнего источника (помните про UDF?), мы на самом деле не знаем, каково <strong>текущее </strong>состояние. Синтаксис Kotlin в этом случае не самый удобный, но, проделывая все это, мы явно следуем нашему контракту во время компиляции и, таким образом, получаем оговоренные выше преимущества. Например:</p><pre><code class="kotlin">class EditProfileContainer(
   private val repo: UserRepository,
) {
   val state = MutableStateFlow&lt;EditProfileState&gt;(Loading)
  
   override suspend fun onSubscribed() { // (1)
       repo.getUserProfileFlow().collect { user: User -&gt;
           state.update { state: EditProfileState -&gt; // (2)
               val current = state as? EditingProfile // (3)
               EditingProfile( // (4)
                   email = user.email,
                   name = current?.name ?: Input.Valid(user.name ?: ""), // (5)
               )
           }
       }
   }
  
   // в демонстрационных целях мы не используем функцию "update()"
   fun onNameChange(value: String) {
       state.value = (state.value as? EditingProfile)?.let {
           it.copy(name = Input.Valid(value))
       } ?: state.value // (6)
   }
}</code></pre><p>1. Это важно: мы должны следить за изменениями постоянного состояния только тогда, когда пользователь видит страницу, <strong>а не вообще все время</strong>. В противном случае мы тратим ресурсы впустую, а пользователь может даже не увидеть изменений. Это новое требование появилось потому, что наше состояние теперь является <strong>горячим </strong>потоком данных и требует от нас реализации обработки его жизненного цикла. Если бы мы использовали <strong>холодный </strong>поток (например, с помощью combine()), нам бы это не понадобилось. Но мы хотим использовать текущее значение состояния, когда захотим, и приостанавливать его для обновления, поэтому я решил использовать здесь горячий поток. Возросшая сложность — это цена, которую мы должны заплатить за отказ от нескольких потоков в пользу объединения их в один. Однако эта проблема не является неразрешимой. При желании можно разработать подход, в котором свойство state является обычным полем и может быть собрано из нескольких потоков, как в MVVM, если вам так больше нравится.</p><p>2. Каждый раз, когда приходит обновление из нашего источника данных, мы хотим использовать эти данные для перехода из состояния загрузки в новое состояние EditingProfile. Почему? Потому что поступили новые данные и больше нет смысла показывать индикатор загрузки. В любом случае, мы не знаем, <strong>есть</strong> ли смысл в данный момент.</p><p>3. Мы проверяем тип текущего состояния, чтобы узнать, содержит ли оно <strong>уже </strong>какие-либо данные. В нашем примере это поле формы "Name". Теперь нам нужно безопасно обработать оба случая — когда значение есть и когда его нет.</p><p>4. Мы собрали состояние, в котором мы больше не загружаем данные и должны отображать их, но теперь нам нужно предоставить необходимые значения. Иначе, если наше состояние будет невалидным, мы не сможем скомпилировать приложение.</p><p>5. Теперь мы вынуждены для начала проверять, не вносил ли пользователь изменения в свое имя.</p><ul><li><p>Если да, то мы просто используем предыдущее значение. Мы успешно сохранили изменения, внесенные пользователем.</p></li><li><p>Если нет, то сначала мы проверяем, задал ли пользователь значение в удаленном объекте пользователя. Хорошим UX было бы показать пользователю его предыдущее имя, если он хочет сделать небольшое изменение.</p></li><li><p>В противном случае мы предлагаем пользователю добавить имя пользователя и заполняем форму ввода пустой строкой.</p></li></ul><p>6. Если состояние не того типа, который нам нужен, мы просто пропускаем операцию. Возможно, пользователь беспорядочно нажимал на кнопки или процессы выполняются параллельно, и состояние меняется.</p><p>Я осознаю, что код выше выглядит немного сложнее, но я считаю, что мы можем легко решить и эту проблему:</p><ul><li><p>Мы можем абстрагировать логику вызовов onSubscribe, используя готовый или создав собственный структурный шаблон.</p></li><li><p>Мы можем упростить внешний вид и шаблон этих приведений типов, создав хороший DSL, который будет делать всю проверку типов за нас.</p></li><li><p>Для каждого конкретного случая мы можем создать простые расширения, которые будут за нас генерировать “шаблонный код”, если нам не нравится, как выглядит наш собственный код. Например, мы можем создать функцию:</p></li></ul><pre><code class="kotlin">fun Input?.input(default: String? = null) = this ?: Input.Valid(default ?: "")


// использование:


EditingProfile(
  name = current?.name.input(user.name),
)</code></pre><p>Вот как выглядит мой код для этой функции после некоторого рефакторинга:</p><pre><code class="kotlin">val store = store&lt;EditProfileState&gt;(Loading) {


   whileSubscribed {
       repo.user.collect { user -&gt;
           updateState {
               val current = typed&lt;EditingProfile&gt;()
               EditingProfile(
                   email = user.email,
                   name = current?.name.input(user.name),
               )
           }
       }
   }
  
   fun onNameChanged(value: String) = updateState&lt;EditingProfile, _&gt; { // this: EditingProfile
       copy(name = value.input())
   }
}</code></pre><p>Уже не так страшно? Я считаю, что это не только дает все преимущества, о которых мы говорили ранее, но и выглядит и читается как английский язык, что в долгосрочной перспективе очень полезно для наших коллег и для нас самих.</p><p>Осталось решить последнюю проблему, самую коварную, о которой вы, возможно, до сих пор даже не подозревали.</p><h2></h2><h2>Шаг 4: Параллельное обновление состояния</h2><p>В современном реактивном мире, когда мы создаем приложения, наши пользователи ожидают от них только одного: чтобы их работа всегда была <strong>плавной, последовательной, производительной и стабильной.</strong> С ростом требований к качеству клиентских приложений нам, разработчикам, приходится прилагать все больше усилий, чтобы создать наилучший пользовательский интерфейс с помощью анимации, прогрессивной загрузки контента, кэширования баз данных и реактивной передачи данных. Это требует от нас выполнения четырех задач:</p><ol><li><p>Мы делаем наши приложения полностью реактивными и многопоточными.</p></li><li><p>Мы выполняем операции параллельно и в фоновом режиме.</p></li><li><p>Мы обеспечиваем обработку ошибок и освобождение ресурсов при выполнении параллельных операций.</p></li><li><p>Мы постоянно поддерживаем для пользователя надлежащую обратную связь.</p></li></ol><p>Помните времена, когда мы могли просто прилепить пустой экран во время загрузки данных и вывести ошибку на весь экран, если она не удавалась, и пользователи не сильно возражали? Мне кажется, что те времена давно прошли, и теперь появление пустого экрана даже на секунду может легко стать причиной отзыва на 1⭐️, а полноэкранный индикатор загрузки вызовет праведный гнев UX-дизайнера в вашей команде, жалующегося на показатели удержания.</p><p>Обеспечение соответствия всем четырем критериям является чрезвычайно сложной задачей и требует глубоких знаний о параллелизме, принципах синхронизации потоков и асинхронных фреймворках, таких как Coroutines.</p><p>В качестве практического примера предположим, что мы заставили наш EditProfileContainer работать в фоновом потоке и добавили проверку ввода, которая выявляет, является ли имя пользователя уникальным.</p><pre><code class="kotlin">fun onNameChanged(value: String) = updateState&lt;EditingProfile, _&gt; { // this: EditingProfile
   val new = copy(name = value.input())
   launchValidateUsername(new)
   new
}


fun launchValidateUsername(state: EditingProfile) = launch {
   val unique = repo.verifyUsernameIsUnique(state.name.value)
   if (!unique) updateState {
       state.copy(name = Input.Error(name.value, "Username is not unique")
   }
}</code></pre><p>Проблема в том, что когда пользователь вводит свое имя и останавливается, имя пользователя отправляется на проверку, но затем, если он нажимает кнопку "Submit", <strong>порядок перехода состояния теперь не определен</strong>, потому что теперь они параллельны, и мы <strong>захватили состояние</strong>, которое вышло за рамки транзакции.</p><p>Это приводит к следующему (и это лишь один из примеров, который можно привести):</p><ol><li><p>Пользователь изменяет свое имя, и оно является уникальным.</p></li><li><p>Мы начинаем проверять имя пользователя, но эта операция выполняется довольно медленно.</p></li><li><p>Пользователь сразу же нажимает кнопку "Submit".</p></li><li><p>Мы отправляем значение для сохранения и устанавливаем состояние Loading.</p></li><li><p>Пока мы пытаемся сохранить изменения, приходит результат проверки!</p></li><li><p>Мы обновляем состояние, чтобы <strong>восстановить предыдущее значение</strong>.</p></li><li><p>Экран пользователя мерцает, а индикатор загрузки исчезает.</p></li><li><p>Пользователь, не понимая, что произошло и почему нет никакой обратной связи, снова нажимает кнопку "Submit".</p></li><li><p>Мы начинаем обновлять состояние и снова показываем индикатор загрузки.</p></li><li><p>Предыдущий результат сохранения завершился успешно, и пользователь увидел сообщение о том, что его изменения были сохранены.</p></li><li><p>Приходит следующий результат отправки имени пользователя. Имя больше не является уникальным, и функция выбрасывает ошибку.</p></li><li><p>Экран мерцает, и пользователь видит сообщение о том, что его изменения не удалось сохранить, хотя на самом деле оно было успешно сохранено, всего через секунду после появления сообщения об успешном изменении.</p></li></ol><p>С точки зрения пользователя это все выглядит просто ужасно! А ведь мы просто пытались выполнить работу в фоновом потоке. Причина этого в том, что переходы наших состояний <strong>не являются сериализуемыми</strong>.</p><h2>Шаг 5: Сериализуемые переходы состояний</h2><p>Термин "сериализуемый" происходит из терминологии архитектуры баз данных (DBA) и не имеет ничего общего с REST или JSON-структурами.</p><p>Если вы не знакомы с тонкостями DBA, то та же проблема, с которой мы только что столкнулись, давным-давно существовала и в базах данных, поскольку их транзакции также параллельны. Одна транзакция может считывать данные, а другая, пока выполняется первая, может эти данные изменять, что приводит к гонке между двумя транзакциями и, как следствие, неопределенному результату.</p><p>Существует множество способов, с помощью которых фреймворки баз данных решают эту проблему (и они очень сложны), поэтому мы не будем сейчас глубоко погружаться в них. Если вам все-таки интересно узнать больше, поищите "изоляция транзакций в базе данных". Вместо этого давайте разберемся, как мы можем решить эту проблему в нашем приложении.</p><p>Но прежде я должен отметить, что никогда раньше не видел, чтобы эта тема хоть раз поднималась в сообществе разработчиков Kotlin, так что то, что я делаю здесь, — это либо что-то совершенно новое (либо довольно специфический случай изобретения велосипеда, решать вам), и это главная причина, по которой я пишу эту статью.</p><p>Я самостоятельно исследовал этот вопрос и пришел к выводу, что большинство клиентских приложений и архитектурных фреймворков используют следующие подходы:</p><ol><li><p>Делают все операции последовательными<br/>— Например, в MVI мы определяем наши намерения как очередь команд (например, с помощью канала), и в результате они обрабатываются последовательно. Мы уже говорили, что такой подход не подойдет для нашего высокопараллельного реактивного приложения.</p></li><li><p>Используют только основной (или единственный) поток для обновления состояния<br/>— Такие фреймворки, как MVIKotlin, Orbit MVI и большинство других, используют эту стратегию, запрещая обновление состояния в фоновом потоке. Как мы уже говорили, наша цель — сделать полностью асинхронное, высокопроизводительное приложение</p></li><li><p>Разделяют состояния на несколько потоков (streams), обновляемых атомарно между потоками (threads)<br/>— Это подход MVVM / MVVM+, но, вернувшись к нему, мы потеряем все остальные преимущества, которые только что получили.</p></li><li><p>Делают все состояния постоянными<br/>— Этот пункт не требует пояснений, но мы не можем охватить все возможные варианты его использования. Существует довольно много императивных/stateful платформенных API, с которыми нужно иметь дело, как в нашем примере.</p></li><li><p>Используют различные флаги в состоянии для индикации хода выполнения операций, постоянно управляя ими.<br/>— Например, мы можем добавить флаг в наше состояние isValidatingUsername и проверять его, чтобы решить, переводить ли пользователя в следующее состояние или нет, и/или отменить задачу обновления, когда мы отправляем данные<br/>— Лично мне не нравится это решение не только потому, что мы возвращаемся к тому, с чего начали, пытаясь избавиться от бессмысленных значений, но и потому, что сложность таких решений может возрастать в геометрической прогрессии.</p></li><li><p>Вручную синхронизируют каждый параллельный источник данных с помощью таких примитивов, как семафоры и мьютексы.<br/>— Этот вариант на самом деле достаточно хорош и (спойлер) служит основой нашего решения, но это очень громоздко — создавать и управлять блокировками для всего, что у нас есть, а также перекладывать ответственность за атомарность на бизнес-логику, которая не хочет иметь ничего общего с состояниями нашего презентационного слоя.<br/> — Кроме того, это в конечном итоге замедлит работу нашего приложения, когда мы столкнемся с обычными проблемами синхронизированного кода, такими как взаимные блокировки, лайвлоки и голодание потоков.</p></li></ol><p>Я предлагаю нечто иное — почему бы нам не перенять опыт баз данных и не <strong>сделать наши переходы состояний сериализуемыми</strong>? Реализация этого решения также проста:</p><pre><code class="kotlin">private val _states = MutableStateFlow(initial)
val states: StateFlow&lt;S&gt; = _states.asStateFlow()
private val stateMutex = Mutex()


suspend fun withState(
   block: suspend S.() -&gt; Unit
) = stateMutex.withReentrantLock { block(states.value) }


suspend fun updateState(
   transform: suspend S.() -&gt; S
) = stateMutex.withReentrantLock { _states.update { transform(it) } }</code></pre><p>Мы можем извлечь этот код в отдельный интерфейс и навсегда забыть об этой проблеме.</p><p>P.S. Для тех, кто разбирается в DBA, это делает наши переходы состояния соответствующими уровню изоляции транзакций SERIALIZABLE в Postgres.</p><p>Должен отметить, что использование <strong>реентерабельной </strong>блокировки здесь очень важно, так как мы хотим поддерживать вложенные переходы состояний для нескольких пограничных случаев. Если вам интересно, почему мы просто не используем _states.update { } без блокировки, то вам нужно прочитать документацию к этому методу, чтобы понять, что функция может вызвать вашу лямбду <strong>несколько раз</strong>, если полученное и предыдущее значения не совпадут. Мы не хотим этого, например, для критических вызовов API, и в то же время мы не хотим, чтобы состояние менялось во время выполнения длительной задачи. Таким образом, блокировка — это лучшее решение для нашего случая, когда нужно сделать обновления состояния сериализуемыми.</p><p>"И это все?" — спросите вы.</p><p>К этому решению есть одна небольшая оговорка: вы должны понимать, что мы внедрили в наш код логику синхронизации, которая сделает обновления состояния по своей природе последовательными. Блокировка вносит некоторые накладные расходы на производительность каждый раз, когда мы пытаемся обновить состояние, поэтому вы можете рассмотреть возможность создания "запасного" подхода или опции отключения сериализуемых переходов состояния для данной операции обновления или всего блока бизнес-логики, чтобы предотвратить трату ресурсов на синхронизацию, когда обновления состояния происходят очень часто. По моему личному опыту, эти замедления редко заметны и не приводят к подвисаниям, если выполняются в основном потоке.</p><h2></h2><h2>Послесловие</h2><p>Самое большое преимущество этого подхода, на мой взгляд, заключается не в решении какой-то одной проблемы или заботе о паре каких-нибудь пограничных случаев, а в том, что нам больше никогда не придется думать о проблемах управления состояниями, просто изменив парадигму, в которой мы работаем. Мы можем писать полностью асинхронный код, запускать сколько угодно параллельных процессов, создавать сколь угодно сложные иерархии состояний и функций — и все это, не задумываясь ни на секунду о том, всегда ли наш код будет вести себя так, как мы от него ожидаем. Использование такого подхода при создании приложений освобождает огромное количество моих когнитивных ресурсов, и это, в конечном счете, то, что я ценю больше всего. Я считаю, что написание кода должно быть легким, плавным процессом, где в идеале вам не нужно надолго останавливаться, чтобы обдумать еще один пограничный случай или возможную проблему.</p><p>Я надеюсь, что, вооружившись знаниями из этой статьи, вы сможете составить обоснованное мнение и взять на вооружение описанные здесь практики или реализовать идеи, которые помогут вашим приложениям стать лучше, а рабочему процессу — более плавным.</p><p>После прочтения этой статьи у вас может остаться пара вопросов:</p><ol><li><p>Где можно увидеть этот подход в действии?</p></li><li><p>Где можно посмотреть пример реализации?</p></li><li><p>Что если я не хочу делать все вышеперечисленное самостоятельно, а просто хочу иметь готовое решение, которое можно будет кастомизировать?</p></li></ol><p>Не переживайте. Все, о чем мы говорили в этой статье, я полностью реализовал в архитектурном фреймворке, который использую я и мои команды — <a href="https://github.com/respawn-app/FlowMVI"><u>FlowMVI</u></a>.</p><p>Этот фреймворк:</p><ul><li><p>Делает переходы состояний полностью сериализуемыми с реентерабельными блокировками и возможностью отключить сериализацию для отдельного перехода или целого блока бизнес-логики.</p></li><li><p>Имеет хороший DSL, подобный приведенному выше, который упрощает проверку типов и безопасное обновление состояния.</p></li><li><p>Управляет жизненным циклом подписки для запуска, остановки и повторного запуска заданий по обновлению состояния.</p></li><li><p>Позволяет сделать бизнес-логику полностью асинхронной и переключаться на любое количество потоков.</p></li><li><p>Реализован с помощью корутин как первоклассный продукт.</p></li><li><p>Обеспечивает согласованность состояний и позволяет легко объединить их в единый источник истины.</p></li><li><p>Обрабатывает все ошибки за вас и позволяет обновлять состояние соответствующим образом без неудобных try/catches для каждой функции.</p></li><li><p>Абстрагирует от всех тонкостей обновления состояний и параллельной обработки, чтобы вам не нужно было тратить на это свои нервы.</p></li><li><p>Управляет фоновыми заданиями за вас и автоматически высвобождает ресурсы в нужный момент.</p></li><li><p>Поддерживает кэширование, атомарную, последовательную и параллельную обработку команд и декомпозиции бизнес-логики на асинхронные источники данных.</p></li><li><p>Поддерживает сохранение состояния по мере необходимости в качестве дополнительного уровня безопасности.</p></li></ul><p>Я буду рад, если вы <a href="https://opensource.respawn.pro/FlowMVI/#/quickstart"><u>попробуете</u></a> его и дадите мне знать, что вы думаете об этом новом подходе к управлению состояниями!</p><p>Обновление от 5 апреля 2024: Я добавил в статью дополнительные пояснения по поводу горячих и холодных потоков и использования мьютекса, основываясь на отзывах читателей.</p><hr/><p>Прокачать все необходимые навыки разработки Android-приложений до уровня Middle/Senior можно в рамках <a href="https://otus.pw/Bnvl/">курса "Android Developer. Professional".</a></p><p></p></div></div></div><!-- --><!-- --></div><!-- --><!-- --></div><!--]--><!-- --><div class="tm-article-presenter__meta" data-test-id="article-meta-links"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[mvi]"><span>mvi</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[Kotlin]"><span>Kotlin</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[android]"><span>android</span></a><!--]--></li><!--]--><!-- --></ul></div><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/companies/otus/articles/"><!--[--><span>Блог компании OTUS</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/hubs/android_dev/"><!--[--><span>Разработка под Android</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/hubs/kotlin/"><!--[--><span>Kotlin</span><!--]--></a><!--]--></li><!--]--><!-- --></ul></div></div><!-- --><!--]--></article><!--]--></div><!-- --></div><div class="tm-article-sticky-panel" data-test-id="article-sticky-panel" style=""><div class="tm-data-icons tm-data-icons tm-data-icons_space-big tm-article-sticky-panel__icons" data-test-id="article-stats-icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon tm-votes-meter__icon_appearance-article" height="24" width="24"><title>Всего голосов 6: ↑6 и ↓0</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-rating"></use></svg><span class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating tm-votes-meter__value" data-test-id="votes-meter-value" title="Всего голосов 6: ↑6 и ↓0">+9</span></div><!--teleport start--><!--teleport end--><!-- --></div><!-- --><!-- --><button class="bookmarks-button tm-data-icons__item" title="Добавить в закладки" type="button"><span class="tm-svg-icon__wrapper bookmarks-button__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Добавить в закладки</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-favorite"></use></svg></span><span class="bookmarks-button__counter" title="Количество пользователей, добавивших публикацию в закладки">28</span></button><div class="tm-sharing tm-data-icons__item" title="Поделиться"><button class="tm-sharing__button" type="button"><svg class="tm-sharing__icon" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z" fill="currentColor"></path></svg></button><!--teleport start--><!--teleport end--></div><div class="tm-article-comments-counter-link tm-data-icons__item" title="Читать комментарии"><a class="tm-article-comments-counter-link__link" data-test-id="counter-comments" href="/ru/companies/otus/articles/847888/comments/"><!--[--><svg class="tm-svg-img tm-article-comments-counter-link__icon" height="24" width="24"><title>Комментарии</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value">0</span><!--]--></a><!-- --></div><!--[--><!--[--><!--[--><!-- --><!--]--><!--]--><!--]--><!--teleport start--><!--teleport end--><!-- --></div></div></div><!--[--><!--]--><div class="tm-article-presenter__footer"><!--[--><!--[--><div class="tm-article-blocks"><!-- --><!--[--><section class="tm-block tm-block tm-block_spacing-bottom"><!-- --><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-balanced"><!--[--><div class="tm-article-author" data-test-id="article-author-info"><!--[--><!--[--><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a class="tm-company-snippet__logo-link" href="/ru/companies/otus/profile/"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" height="40" src="//habrastorage.org/getpro/habr/company/a65/525/4fe/a655254feebb0b25a027b5e276ea6489.png" width="40"/></div></a><div class="tm-company-snippet__info"><a class="tm-company-snippet__title" data-test-id="company-title" href="/ru/companies/otus/profile/"><span>OTUS</span></a><div class="tm-company-snippet__description">Цифровые навыки от ведущих экспертов</div></div></div><div class="tm-article-author__buttons"><!-- --><!-- --></div></div><div class="tm-article-author__company-contacts"><!--[--><a class="tm-article-author__contact" href="https://otus.ru" rel="noopener" target="_blank">Сайт</a><a class="tm-article-author__contact" href="https://vk.com/club145052891" rel="noopener" target="_blank">ВКонтакте</a><a class="tm-article-author__contact" href="https://telegram.me/Otusjava" rel="noopener" target="_blank">Telegram</a><!--]--></div><div class="tm-article-author__separator"></div></div><!--]--><!--]--><div class="tm-user-card tm-user-card tm-user-card_variant-article tm-article-author__user-card" data-async-called="true"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a class="tm-user-card__userpic tm-user-card__userpic_size-40" href="/ru/users/MaxRokatansky/"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" src="//habrastorage.org/getpro/habr/avatars/b9f/baf/5f9/b9fbaf5f96ae52973706a0716bd9216e.jpg"/></div></a><div class="tm-user-card__meta"><div class="tm-counter-container tm-karma tm-karma" title=" 1052 голоса "><div class="tm-counter-container__header"><!--[--><div class="karma-display positive" data-v-7635202e="">114</div><!-- --><!--]--></div><div class="tm-counter-container__footer"><!--[--><div class="tm-karma__text">Карма</div><!--teleport start--><!--teleport end--><!--]--></div></div><div class="tm-counter-container" title="Рейтинг пользователя"><div class="tm-counter-container__header"><!--[--><!--[--><!--]--><div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating"><!-- --><div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score"><!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">33.5</span></span><!--]--></div><!-- --></div><!--]--></div><div class="tm-counter-container__footer"><!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]--></div></div></div></div></div><div class="tm-user-card__info tm-user-card__info_variant-article tm-user-card__info"><div class="tm-user-card__title tm-user-card__title_variant-article tm-user-card__title"><span class="tm-user-card__name tm-user-card__name_variant-article tm-user-card__name">OTUS</span><a class="tm-user-card__nickname tm-user-card__nickname tm-user-card__nickname_variant-article" href="/ru/users/MaxRokatansky/"> @MaxRokatansky</a><!-- --></div><p class="tm-user-card__short-info tm-user-card__short-info_variant-article tm-user-card__short-info" data-test-id="user-card-speciality">Редактор</p></div></div><div class="tm-user-card__buttons tm-user-card__buttons_variant-article tm-user-card__buttons"><!-- --><div class="tm-user-card__button"><div class="tm-button-follow tm-user-card__button-follow"><!-- --><button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button></div></div><!-- --><div class="tm-user-card__button tm-user-card__button_write" data-test-id="user-card-conversations"><svg class="tm-svg-img tm-user-card__button-icon" height="16" width="16"><title>Отправить сообщение</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#mail"></use></svg></div><!-- --></div><!-- --></div><!-- --></div><!--]--></div><!--]--><!-- --></section><!-- --><!--[--><!--]--><!--]--><div class="tm-article-blocks__comments"><div class="tm-article-page-comments" id="publication-comments"><div><!--[--><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style" data-test-id="counter-comments" href="/ru/companies/otus/articles/847888/comments/"><!--[--><svg class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted" height="24" width="24"><title>Комментарии</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted"> Комментировать </span><!--]--></a><!-- --></div><!--]--></div></div></div><!--[--><!--[--><!--]--><section class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header tm-block__header_variant-borderless"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title tm-block__title_variant-large">Публикации</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-condensed-slim"><!--[--><!--[--><div class="tm-tabs tm-tabs"><div class=""><!--[--><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link_active tm-tabs__tab-link_slim tm-tabs__tab-link">Лучшие за сутки</button></span><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link_slim tm-tabs__tab-link">Похожие</button></span><!--]--></div><!-- --></div><div class="similar-and-daily__tab-view"><div class="placeholder-wrapper"><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="tm-placeholder-article-cards"><!--[--><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><!--]--></div><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --></div><!-- --></div><!--]--><!--]--></div><!--]--><!-- --></section><!--[--><!--[--><div career-alias="otus" class="placeholder-wrapper"><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="tm-placeholder-inset tm-placeholder-company_courses"><div class="tm-placeholder-inset__header"><div class="tm-placeholder__line tm-placeholder__line_inset-header loads"></div></div><div class="tm-placeholder-inset__body"><ul class="tm-placeholder-list"><!--[--><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__company-avatar"></div><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__company-avatar"></div><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__company-avatar"></div><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__company-avatar"></div><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><li class="tm-placeholder-list__item tm-placeholder-list__item_inset"><div class="tm-placeholder-list__title-container"><div class="tm-placeholder__company-avatar"></div><div class="tm-placeholder__line tm-placeholder__line_item-title loads"></div></div><div class="tm-project-block-items__properties"><!--[--><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><span class="tm-project-block-items__property-item"><span class="tm-placeholder__line loads" style="width:100px;"></span></span><!--]--></div></li><!--]--></ul></div><div class="tm-placeholder-inset__footer"><div class="tm-placeholder__line tm-placeholder__line_inset-footer loads"></div></div></div><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --></div><!--]--><!--]--><!-- --><!--[--><!--]--><!--]--></div><!--]--><!--]--></div></div><!--]--><!--]--></div></div><div class="tm-page__sidebar"><!--[--><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div><div class="tm-sexy-sidebar_initial tm-sexy-sidebar" style="margin-top:0px;"><!--[--><!--]--><!-- --><div class="tm-layout-sidebar__placeholder_initial"></div><!--[--><section class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Информация</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body"><!--[--><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">Сайт</dt><dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body"><!--[--><a class="tm-company-basic-info__link" href="https://otus.ru" target="_blank">otus.ru</a><!--]--></dd></dl><dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">Дата регистрации</dt><dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body"><!--[--><time datetime="2017-03-22T08:17:26.000Z" title="2017-03-22, 11:17">22  марта  2017</time><!--]--></dd></dl><dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">Дата основания</dt><dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body"><!--[--><time datetime="2017-03-31T21:00:00.000Z" title="2017-04-01, 00:00">1  апреля  2017</time><!--]--></dd></dl><dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">Численность</dt><dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body"><!--[-->101–200 человек<!--]--></dd></dl><dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">Местоположение</dt><dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body"><!--[-->Россия<!--]--></dd></dl><dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">Представитель</dt><dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body"><!--[--><a class="tm-company-basic-info__link" href="/ru/users/MaxRokatansky/">OTUS</a><!--]--></dd></dl></div><!--]--></div><!--]--><!-- --></section><div class="tm-company-widgets"><!--[--><!--]--></div><!-- --><!-- --><!--]--><!-- --></div></div><!--]--></div></div><!-- --><!--]--></div></div></main><!-- --></div><div class="tm-footer-menu"><div class="tm-page-width"><!--[--><div class="tm-footer-menu__container"><!--[--><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Ваш аккаунт</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/companies/otus/articles/847888/&amp;hl=ru" rel="nofollow" target="_self">Войти</a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/companies/otus/articles/847888/&amp;hl=ru" rel="nofollow" target="_self">Регистрация</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Разделы</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/articles/">Статьи</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/news/">Новости</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/hubs/">Хабы</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/companies/">Компании</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/users/">Авторы</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/sandbox/">Песочница</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Информация</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/help/">Устройство сайта</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/authors/codex/">Для авторов</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/companies/corpblogs/">Для компаний</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/docs/transparency/">Документы</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement/?hl=ru_RU" target="_blank">Соглашение</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/?hl=ru_RU" target="_blank">Конфиденциальность</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Услуги</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/corporate-blogs/" target="_blank">Корпоративный блог</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/advertising/" target="_blank">Медийная реклама</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/native-special/" target="_blank">Нативные проекты</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/education-programs/" target="_blank">Образовательные программы</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/hello-startup/" target="_blank">Стартапам</a></li><!--]--></ul></div></div><!--]--></div><!--]--></div></div><div class="tm-footer"><div class="tm-page-width"><!--[--><div class="tm-footer__container"><!-- --><div class="tm-footer__social"><!--[--><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Facebook</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Twitter</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>VK</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-vk"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Telegram</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Youtube</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://dzen.ru/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Яндекс Дзен</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-dzen"></use></svg></a><!--]--></div><!--teleport start--><!--teleport end--><button class="tm-footer__link"><!-- --> Настройка языка</button><a class="tm-footer__link" href="/ru/feedback/">Техническая поддержка</a><div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2025, </span><span class="tm-copyright__name"><a class="tm-copyright__link" href="https://company.habr.com/" rel="noopener" target="_blank">Habr</a></span></span></div></div><!--]--></div></div><!-- --><!--]--></div><!-- --></div></div>
<div id="overlays"><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--></div>
</body>
</html>
