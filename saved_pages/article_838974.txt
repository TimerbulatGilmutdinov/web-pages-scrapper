<!DOCTYPE html>

<html lang="ru">
<head>
<title>Kotlin Coroutines. От А до Я / Хабр</title>
</head>
<body>
<div id="mount"><div data-async-called="true" id="app"><div class="tm-layout__wrapper"><!--[--><!-- --><div></div><!-- --><header class="tm-header" data-test-id="header"><div class="tm-page-width"><!--[--><div class="tm-header__container"><!-- --><span class="tm-header__logo-wrap"><a class="tm-header__logo tm-header__logo_hl-ru tm-header__logo" href="/ru/"><svg class="tm-svg-img tm-header__icon" height="16" width="16"><title>Хабр</title><use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a><span class="tm-header__beta-sign" style="display:none;">β</span></span><!--[--><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><!--[--><button class="tm-header__dropdown-toggle"><svg class="tm-svg-img tm-header__icon tm-header__icon_dropdown" height="16" width="16"><title>Открыть список</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#arrow-down"></use></svg></button><!--]--></div><!-- --></div><a class="tm-header__become-author-btn" href="/ru/sandbox/start/">Как стать автором</a><div class="tm-feature tm-feature tm-feature_variant-inline tm-header__feature"><!-- --></div><!-- --><!--]--><!-- --></div><!--]--></div></header><div class="tm-layout"><div class="tm-page-progress-bar"></div><div class="tm-base-layout__header_is-sticky tm-base-layout__header" data-menu-sticky="true"><div class="tm-page-width"><!--[--><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/feed/">Моя лента</a><!--]--><!--[--><a class="tm-main-menu__item" href="/ru/articles/">Все потоки</a><!--]--><!--[--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/develop/">Разработка</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/admin/">Администрирование</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/design/">Дизайн</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/management/">Менеджмент</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/marketing/">Маркетинг</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/popsci/">Научпоп</a><!--]--><!--]--></nav></div></div><div class="tm-header-user-menu tm-base-layout__user-menu"><a class="tm-header-user-menu__item tm-header-user-menu__search" data-test-id="search-button" href="/ru/search/"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark" height="24" width="24"><title>Поиск</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#search"></use></svg></a><!-- --><!-- --><div class="tm-header-user-menu__item tm-header-user-menu__write"><div><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_write tm-header-user-menu__icon_dark" height="24" width="24"><title>Написать публикацию</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#write"></use></svg></div><!-- --></div><!--[--><div class="tm-header-user-menu__item"><button class="tm-header-user-menu__toggle" data-test-id="user-menu-settings"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_dark" height="24" width="24"><title>Настройки</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#page-settings"></use></svg></button></div><a class="tm-header-user-menu__item" href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/articles/838974/&amp;hl=ru" rel="nofollow"><!--[--><button class="btn btn_solid btn_small tm-header-user-menu__login" type="button"><!--[-->Войти<!--]--></button><!--]--></a><!--]--><!-- --><!--teleport start--><!--teleport end--><!-- --></div></div><!--]--></div></div><!-- --><div class="tm-page-width"><!--[--><!--]--></div><main class="tm-layout__container"><div class="tm-page" data-async-called="true" hl="ru" style="--0c809c5a:16px;--a086013e:100%;--7c457026:0;"><div class="tm-page-width"><!--[--><!-- --><div class="tm-page__wrapper"><div class="tm-page__main_has-sidebar tm-page__main"><div class="pull-down"><!-- --><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg class="tm-svg-img pull-down__icon pull-down__arrow" height="24" width="24"><title>Обновить</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#pull-arrow"></use></svg></div></div><!--[--><!--[--><!-- --><div class="tm-article-presenter"><!--[--><!--]--><div class="tm-article-presenter__body" data-test-id="article-body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><!--[--><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><!--[--><div class="tm-article-presenter__header"><!--[--><!--]--><div class="tm-article-snippet tm-article-snippet tm-article-presenter__snippet"><!--[--><!--]--><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a class="tm-user-info__userpic" data-test-id="user-info-pic" href="/ru/users/E-Coding/" title="E-Coding"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" height="24" src="//habrastorage.org/r/w48/getpro/habr/avatars/06f/0d8/bbd/06f0d8bbd16af532b0e1ed5246fee330.jpg" width="24"/></div></a><span class="tm-user-info__user tm-user-info__user_appearance-default" data-test-id="user-info-description"><a class="tm-user-info__username" href="/ru/users/E-Coding/">E-Coding <!-- --></a><!--[--><span class="tm-article-datetime-published"><time datetime="2024-08-27T13:26:02.000Z" title="2024-08-27, 16:26">27  авг  2024 в 16:26</time></span><!--]--></span></span></div><!-- --></div><h1 class="tm-title tm-title_h1" data-test-id="articleTitle" lang="ru"><span>Kotlin Coroutines. От А до Я</span></h1><div class="tm-article-snippet__stats" data-test-id="articleStats"><div class="tm-article-complexity tm-article-complexity_complexity-low"><span class="tm-svg-icon__wrapper tm-article-complexity__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Уровень сложности</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#complexity-low"></use></svg></span><span class="tm-article-complexity__label">Простой</span></div><div class="tm-article-reading-time"><span class="tm-svg-icon__wrapper tm-article-reading-time__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Время на прочтение</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#clock"></use></svg></span><span class="tm-article-reading-time__label">28 мин</span></div><span class="tm-icon-counter tm-data-icons__item"><svg class="tm-svg-img tm-icon-counter__icon" height="24" width="24"><title>Количество просмотров</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-views"></use></svg><span class="tm-icon-counter__value" title="32988">33K</span></span></div><div class="tm-publication-hubs__container" data-test-id="articleHubsList"><div class="tm-publication-hubs"><!--[--><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/hubs/kotlin/"><!--[--><span>Kotlin</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/hubs/android_dev/"><!--[--><span>Разработка под Android</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><!--]--></div></div><div class="tm-article-labels" data-test-id="articleLabels"><div class="tm-article-labels__container"><!-- --><!--[--><div class="tm-publication-label tm-publication-label_variant-sandbox"><a class="" href="/ru/sandbox/">Из песочницы</a></div><!--]--></div></div><!-- --><!-- --></div></div><!--[--><!-- --><div class="tm-article-body" data-gallery-root="" lang="ru"><div><!--[--><!--]--></div><div id="post-content-body"><div><div class="article-formatted-body article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><figure class="full-width"><img alt="Превью статьи" data-blurred="true" data-src="https://habrastorage.org/getpro/habr/upload_files/6fe/f33/555/6fef335554569db3e77e70cee33936a2.jpg" height="754" src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/6fe/f33/555/6fef335554569db3e77e70cee33936a2.jpg" title="Превью статьи" width="1328"/><div><figcaption>Превью статьи</figcaption></div></figure><p>Всем привет!</p><p>В этой статье я бы хотел осветить загадочный мир корутин перед своим читателем, рассказав о них от А до Я. </p><p>Я старался написать эту статью таким образом, чтобы она была полностью понятна новичкам и могла использоваться как шпаргалка на собеседовании для тех, кому уже знаком этот асинхронный мир. Для лучшего понимания, я буду периодически ссылаться на исходники библиотеки kotlinx.coroutines версии 1.7.1, так как уверен, что это поможет развеять загадочность всех корутинных мифов. </p><p>Статья получилась весьма подробной, поэтому запасайтесь кружчекой чая, и давайте начнем!</p><h2>Оглавление</h2><ol><li><p><a href="https://habr.com/ru/sandbox/224070/#fast_guide_coroutines" rel="noopener noreferrer nofollow">Шпаргалка по корутинам</a></p></li><li><p><a href="https://habr.com/ru/sandbox/224070/#when_should_use_coroutines" rel="noopener noreferrer nofollow">Зачем нужны корутины?</a></p></li><li><p><a href="https://habr.com/ru/sandbox/224070/#suspend" rel="noopener noreferrer nofollow">Suspend в Котлин</a></p></li><li><p><a href="https://habr.com/ru/sandbox/224070/#kotlinx_coroutines" rel="noopener noreferrer nofollow">Библиотека kotlinx.corourines</a></p></li><li><p><a href="https://habr.com/ru/sandbox/224070/#runBlocking" rel="noopener noreferrer nofollow">Три способа войти в корутинный мир. runBlocking, CoroutineScope и suspend main</a></p></li><li><p><a href="https://habr.com/ru/sandbox/224070/#coroutine_scope" rel="noopener noreferrer nofollow">Область видимости корутины. CoroutineScope и GlobalScope</a></p></li><li><p><a href="https://habr.com/ru/sandbox/224070/#coroutine_context" rel="noopener noreferrer nofollow">CoroutineContext или как настроить свою корутину. withContext</a></p></li><li><p><a href="https://habr.com/ru/sandbox/224070/#job" rel="noopener noreferrer nofollow">Работа не Job, или все таки Job? Разбираемся в Job и Deferred</a></p></li><li><p><a href="https://%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA%20%D0%BA%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B%20%D1%81%20%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E%20Coroutine%20Builders.%20launch%20%D0%B8%20async%20https://habr.com/ru/sandbox/224070/#coroutine_builder" rel="noopener noreferrer nofollow">Запуск корутины с помощью Coroutine Builders. launch и async</a></p></li><li><p><a href="https://habr.com/ru/sandbox/224070/#dispatchers" rel="noopener noreferrer nofollow">Dispatchers. Основные виды диспетчеров в корутинах и область их применения</a></p></li><li><p><a href="https://habr.com/ru/sandbox/224070/#error" rel="noopener noreferrer nofollow">Способы обработок ошибок в корутинах. try-catch, runCatching, CoroutineExceptionHandler, SupervisorJob / supervisorScope</a></p></li><li><p><a href="https://habr.com/ru/sandbox/224070/#cancel" rel="noopener noreferrer nofollow">Отмена корутин</a></p></li><li><p><a href="https://habr.com/ru/sandbox/224070/#custom_scope" rel="noopener noreferrer nofollow">Создание своего пользовательского CoroutineScope</a></p></li></ol><a class="anchor" id="fast_guide_coroutines" name="fast_guide_coroutines"></a><h2>1. Шпаргалка по корутнам</h2><p>Этот раздел - обобщающий для всех последующих. Если вы только открыли статью и не до конца понимаете, что изображено на этой схеме - не переживайте, так как я тоже ниже обо всем это подробно расписано</p><figure class="full-width"><img alt="Шпаргалка по корутинам" data-src="https://habrastorage.org/getpro/habr/upload_files/627/e92/b42/627e92b42209137aea9cff9800884226.png" height="665" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/627/e92/b42/627e92b42209137aea9cff9800884226.png" title="Шпаргалка по корутинам" width="894"/><div><figcaption>Шпаргалка по корутинам</figcaption></div></figure><a class="anchor" id="when_should_use_coroutines" name="when_should_use_coroutines"></a><h2>2. Зачем нужны корутины?</h2><p>Корутины нужны для управления асинхронностью в вашем коде. Прежде чем коснемся этого понятия, давайте представим такой пример:</p><p>Вы пишите свое собственное приложение для просмотра картинок из Интернета, которое то и дело общается  с сервером, посылая на него различные сетевые запросы. И проблема в том, что длительность таких запросов порой занимает секунды, в течение которых пользователь не может ничего сделать, так как его главный поток ожидает ответ от сервера и не способен далее обрабатывать код, пока не получит ответ.</p><figure class="full-width"><img alt="Ожидание загрузки фото на главном потоке в течение 3 секунд" data-blurred="true" data-src="https://habrastorage.org/getpro/habr/upload_files/715/ae1/c74/715ae1c749fa7664fdf1c647bef54a7f.jpg" height="1024" src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/715/ae1/c74/715ae1c749fa7664fdf1c647bef54a7f.jpg" title="Ожидание загрузки фото на главном потоке в течение 3 секунд" width="2862"/><div><figcaption>Ожидание загрузки фото на главном потоке в течение 3 секунд</figcaption></div></figure><p>Код такого сетевого запроса можно представить примерно так:</p><pre><code class="kotlin">fun loadImage() {
    println("Начало загрузки фото")
    Thread.sleep(3000) // Ожидание сервера
    println("Фотография загружена")
}

fun main(args: Array&lt;String&gt;) {
    println("Программа начинает работу")
    loadImage()
    println("Продолжение работы программы...")
}</code></pre><p>Метод <code>loadImage()</code> запрашивает у сервера фотографию и ждёт ее в течение 3 секунд (сейчас мы сделали это ожидание искусственно, чтобы упростить код для понимания), прежде чем сервер вернёт ответ. И только после этого наш код возвращает ответ и продолжает свое выполнение:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><p>Программа начинает работу <br/>Начало загрузки фото <br/>// 3 секунды паузы <br/>Фотография загружена <br/>Продолжение работы программы...</p></div></details><p>Все бы ничего, но в течение этих 3 секунд пользователь не способен никак взаимодействовать с приложением, что несет в себе плохой user experience для вашего приложения, и нам бы хотелось убрать это ожидание ответа с главного потока, чтобы пользователь дальше смог продолжить работать с вашей программой.</p><p>Но как это сделать?</p><p>Есть, как минимум, два варианта:</p><ol><li><p>Сделать сетевой запрос в отдельном потоке, тем самым выполняя его параллельно</p></li><li><p>Поместить этот запрос внутри корутин, сделав его асинхронным в нашей программе</p></li></ol><p>Давайте подробнее остановимся на этом моменте.</p><p>Создавая новый поток, вы запускаете код в нем параллельно вашему основному потоку. Схематично это можно представить так:</p><figure class="full-width"><img alt="Загрузка фото после добавления потоков" data-blurred="true" data-src="https://habrastorage.org/getpro/habr/upload_files/2c3/443/04d/2c344304d7d2ea497a7c128e943fe113.jpg" height="1622" src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/2c3/443/04d/2c344304d7d2ea497a7c128e943fe113.jpg" title="Загрузка фото после добавления потоков" width="2862"/><div><figcaption>Загрузка фото после добавления потоков</figcaption></div></figure><p>Код такого подхода выглядел примерно бы так:</p><pre><code class="kotlin">class BackgroundThread() : Thread() {
    override fun run() {
        loadImage()
    }
}

fun loadImage() {
    println("Начало загрузки фото")
    Thread.sleep(3000) // Ожидание сервера
    println("Фотография загружена")
}

fun main(args: Array&lt;String&gt;) {
    println("Программа начинает работу")

    //Создание нового потока для загрузки фото
    val newThread = BackgroundThread()
    newThread.start()

    println("Продолжение работы программы...")
}</code></pre><p>Таким образом пользователю теперь не нужно ждать 3 секунды в ожидание ответа от сервера, так как теперь эта работа происходит параллельно (фоново) в другом потоке. Как результат, мы увидим в консоли следующее:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><p>Программа начинает работу<br/> Продолжение работы программы...<br/> Начало загрузки фото<br/> Фотография загружена</p></div></details><p>Схематично, данный код можно визуализировать следующим образом:</p><figure class="full-width"><img alt="Многопоточная загрузка фотографии" data-blurred="true" data-src="https://habrastorage.org/getpro/habr/upload_files/ff8/b91/107/ff8b91107b5f1585050d84e5df679b60.jpg" height="1024" src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/ff8/b91/107/ff8b91107b5f1585050d84e5df679b60.jpg" title="Многопоточная загрузка фотографии" width="2862"/><div><figcaption>Многопоточная загрузка фотографии</figcaption></div></figure><p>Но у такого подхода есть существенный недостаток: создание потоков в программировании далеко небесплатная штука с точки зрения производительности, и потому <strong>создание любого нового потока</strong> - это <u>накладные ресурсы</u> для вашего программы. Да, иногда без потока не обойтись, когда речь идёт о тяжёлых вычислениях, и они реально сильно ускорят вашу программу, сделав затраты на создание нового потока незначительными. Но в случае сетевого запроса это может быть избыточным, так как такой сетевой запрос не несёт большой нагрузки на процессор, ведь все время ожидания приходится на транспортировку вашего запроса по всемирной паутине туда и обратно, где устройство пользователя просто ждёт ответ, вообще ничего не делая.</p><p>В таких случаях лучше воспользоваться корутинами, которые в отличие от потоков не несут больших затрат на свое создание, и добавляют в код асинхронность.</p><p>Но что же такое асинхронность?</p><p><u>Асинхронность</u> в программировании - это парадигма программирования, которая позволяет выполнять и обрабатывать операции или задачи без ожидания их завершения. То есть вместо последовательного выполнения задач (как мы это делали в привычном для нас синхронном коде, где каждая операция вызывается друз за другом) асинхронное программирование позволяет коду продолжать выполняться, пока некоторые асинхронные задачи выполняются в фоновом режиме (такие методы мы будем звать suspend, но об этом позже), и обрабатывать их результаты по мере их готовности.</p><p>Это достигается за счет использования неблокирующих операций, которые не приостанавливают поток выполнения текущей задачи, а продолжают выполнять код, пока асинхронная операция не завершается, уведомив нас об этом через механизм колбэков.</p><p>Наглядно пример асинхронности может продемонстрировать следующий рисунок:</p><figure class="full-width"><img alt="Пример загрузки фото с асинхронностью" data-blurred="true" data-src="https://habrastorage.org/getpro/habr/upload_files/57b/25a/075/57b25a0759d63ef2b06e27159c9cb1d3.jpg" height="1024" src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/57b/25a/075/57b25a0759d63ef2b06e27159c9cb1d3.jpg" title="Пример загрузки фото с асинхронностью" width="2862"/><div><figcaption>Пример загрузки фото с асинхронностью</figcaption></div></figure><p>Как видно из рисунка, когда у нас происходит сетевой вызов, мы не ждём его все 3 секунды на нашем потоке, заблокировав его, а выполняем наш код дальше. Но как только нам вернётся ответ, мы продолжим выполнять код, следующий после получения ответа от нашего сервера.</p><p>В этом и заключается главная фишка асинхронности - она не блокирует основной поток, а как бы нарезает его кусочками, что создаёт иллюзию перед пользователем параллельного выполнения кода, хотя по настоящему параллельный код не создаётся (в отличие от потоков).</p><p>Причем, если операций много и они ничего не ожидают (как в случае с ответом от сервера), то асинхронность будет достигаться за счет очень быстрого переключения между задачами:</p><figure class="full-width"><img alt="Выполнение 3 задач в асинхронном режиме" data-blurred="true" data-src="https://habrastorage.org/getpro/habr/upload_files/80b/bf5/5a3/80bbf55a31b1eb865a89cc24683d8613.jpg" height="1024" src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/80b/bf5/5a3/80bbf55a31b1eb865a89cc24683d8613.jpg" title="Выполнение 3 задач в асинхронном режиме" width="2862"/><div><figcaption>Выполнение 3 задач в асинхронном режиме</figcaption></div></figure><p>Но за счёт быстрого переключения между этими операциями пользователь также не замечает разницы, что создаёт то самое впечатление выполнения асинхронности. Классно, да? И создать такой асинхронный код нам позволяют те самые корутины</p><a class="anchor" id="suspend" name="suspend"></a><h2>3. Suspend в Kotlin</h2><p>Для того, чтобы сказать нашей программе, что не нужно блокировать поток, дожидаясь ответа от определенного метода, используется ключевое слово suspend. Этим словом помечается тот метод, который как раз и способен заблокировать наш поток на длительное время (например, таким примером может послужить тот самый метод сетевого вызова, длительность которого составляет 3 секунды). Но давайте разберемся, как именно работает этот метод под капотом.</p><p>Вызывая suspend-метод в своем коде, Котлин под капотом создаёт нарезку из колбэков, примерно следующим образом.</p><p>Допустим у нас есть два suspend-метода сетевых вызовов <code>getData1()</code> и <code>getData2()</code>, который мы будем вызывать в нашем методе main():</p><pre><code class="kotlin">fun main() = runBlocking {
    val data1: Int = getData1()
    println(data1)

    val data2: String = getData2(data1, "name")
    println(data2)
}

suspend fun getData1(): Int {
    delay(1000)
    return 42
}

suspend fun getData2(data1: Int, name: String): String {
    delay(500)
    return "Результат: $data1, имя: $name"
}</code></pre><p>Ключевые слова <code>suspend</code> в этом коде - сигнал котлину о том, что нужно создать некоторый объект типа <strong>Continuation</strong>, который содержит в себе обратный вызов определенного кода (колбэк), после завершения выполнения suspend-метода.</p><p>Упрощённо, этот код преобразится в следующий, создав нарезку из двух колбэков с помощью <strong>Continuation</strong>:</p><pre><code class="kotlin">fun main() = runBlocking {
    val continuation1 = Continuation&lt;Int&gt; { data1 -&gt;
        println(data1) // Вывод data1 после завершения getData1

        val continuation2 = Continuation&lt;String&gt; { data2 -&gt;
            println(data2) // Вывод data2 после завершения getData2
        }
        getData2(data1, "name", continuation2) // Запускаем getData2
    }
    getData1(continuation1) // Запускаем getData1
}

fun getData1(continuation: Continuation&lt;Int&gt;): Unit {
    if (continuation.isCompleted) {
        return
    }
    delayCallback(1000) {
        continuation.resume(42)
    }
}

fun getData2(data1: Int, name: String, continuation: Continuation&lt;String&gt;): Unit {
    if (continuation.isCompleted) {
        return
    }
    delayCallback(500) {
        continuation.resume("Результат: $data1, имя: $name")
    }
}

fun delayCallback(delay: Long, callback: () -&gt; Unit) {
    Thread.sleep(delay)
    callback()
}</code></pre><p>Как видно из кода, наши suspend-методы стали обычным методами, которые дополнительно принимают к себе на вход объект типа <strong>Continuation</strong>, который в свою очередь в конце метода просто вызывает метод <code>resume()</code>, возвращая результат выполнения suspend-метода. Этот возврат с помощью метода <code>resume()</code> - самый обыкновенный колбэк, который позволяет нам выполнять код дальше, после получения результата.</p><p>То есть вызывая метод <code>getData1()</code>, мы передаём ему некоторый объект <strong>Continuation</strong> вместе с колбэком, который говорит что <u>после</u> получения результата из <code>getData1()</code>, нашему коду необходимо вывести этот результат в консоль с помощью команды <code>println()</code> и запустить второй метод <code>getData2()</code>, который на вход примет 2 параметра и ещё один объект <strong>Continuation</strong> вместе с ещё одним колбэком:</p><pre><code class="kotlin">  //...
  val continuation1 = Continuation&lt;Int&gt; { data1 -&gt;
      println(data1) // Вывод data1 после завершения getData1
  
      val continuation2 = Continuation&lt;String&gt; { data2 -&gt;
          //... Колбэк для getData2()
      }
  }
  
  getData1(continuation1) // Запускаем getData1</code></pre><p><code>getData2()</code> в свою очередь сделает аналогичным образом вызов колбэка, который запустит код колбэка (передаваемый в объект <strong>Continuation</strong>) только после окончания выполнения всего suspend-метода с помощью метода <code>resume()</code>.</p><p>Вот и всё, никакой магии в suspend нет. С помощью механизма колбэков, которые неявно передаются в <strong>Continuation</strong> (который в свою очередь создаётся при вызове suspend метода), Котлин искусственно дожидается ответа от долгих suspend-методов, и получая эти результаты передает их дальше, вызывая колбэк с помощью метода resume(). На самом деле все немного сложнее, чем представлено в коде выше, однако этим примером я захотел подчеркнуть принцип работы suspend, для понимания, как он вообще работает, чтобы вы могли грамотно использовать его в своем коде, не помечая все подряд suspend'ом</p><p>Кстати, как вы могли заметить, <code>delay()</code>, который создаёт задержку на определенное число миллисекунд в коде - это тоже обыкновенный suspend-метод, работающий аналогичным образом. Под капотом у него тоже есть свой Continuation</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><pre><code class="kotlin">public suspend fun delay(timeMillis: Long) {
    if (timeMillis &lt;= 0) return // don't delay
    return suspendCancellableCoroutine sc@ { cont: CancellableContinuation&lt;Unit&gt; -&gt;
        // if timeMillis == Long.MAX_VALUE then just wait forever like awaitCancellation, don't schedule.
        if (timeMillis &lt; Long.MAX_VALUE) {
            cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)
        }
    }
}</code></pre><p></p></div></details><p>И да, именно потому что delay является suspend методом, вы не сможете запустить его вне coroutineScope, о которых мы поговорим чуть дальше.</p><p>Стоит при этом отметить, что ключевое слово suspend встроено прямо в язык Котлин, что позволяет им пользоваться без подключения дополнительных зависимостей к вашему проекту. Это сделано в основном для совместимости вашего кода с другими библиотеками, которым может понадобиться вся мощь корутин, а без suspend её добиться невозможно. Однако многий другой функционал, облегчающий работу с асинхронным миром включен в другие библиотеки, которые предоставили нам в виде отдельных зависимостей разработчики JetBrains.</p><a class="anchor" id="kotlinx_coroutines" name="kotlinx_coroutines"></a><h2>4. Библиотека kotlinx.corourines</h2><p>Одну из таких библиотек мы и будем рассматривать в этой статье, поскольку она предоставляет нам много полезных фишек для работы с корутинами. Несмотря на то что, какая-то часть корутинного мира уже встроена на уровне языка Котлин, большая часть необходимого функционала вынесена в отдельную библиотеку <strong>kotlinx.coroutines</strong>, обновления которой выходят намного чаще, чем обновления языка.</p><p>Подключить эту зависимость весьма просто, написав следующий код, если у вас используется Gradle:</p><pre><code>dependencies {
	...
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.1")
}</code></pre><p>Версию актуальной версии библиотеки вы можете взять из <a href="https://mvnrepository.com/artifact/org.jetbrains.kotlinx/kotlinx-coroutines-core" rel="noopener noreferrer nofollow">maven-репозитория</a>.</p><p>Ну а теперь после ее подключения давайте двинемся дальше и разберемся с основными понятиями корутин.</p><a class="anchor" id="runBlocking" name="runBlocking"></a><h2>4. Три способа войти в корутинный мир. runBlocking, CoroutineScope и suspend main</h2><p>Если вы вызовите в методе <code>main()</code> любой suspend-метод, то компилятор незамедлительно покроет вас матом сообщит о ошибке, и сделает это вполне осознанно. Дело в том, что вызов любой suspend-функции возможен только внутри любого CoroutineScope, который представляет собой область видимости (о них мы поговорим ниже).</p><p>Но где взять этот CoroutineScope в самый первый раз? Существует 3 способа сделать это:</p><ol><li><p>С помощью runBlocking</p></li><li><p>С помощью suspend main()</p></li><li><p>С помощью coroutineScope</p></li></ol><p>P. S. на самом деле только с помощью runBlocking, так как остальные два способа это переработанный runBlocking под капотом</p><p>Рассмотрим первый способ. <strong>runBlocking</strong> - это метод, который запускает корутину и предоставляет блоку кода внутри свой CoroutineContext. Любой вызов suspend-методов внутри runBlocking блокирует поток (заставляет ожидать выполнение кода). Но если он блокирует поток, зачем тогда он нужен и в чем его профит? </p><p>Дело в том, что это один из немногих способов попасть в корутинный мир, и никто не мешает нам в дальнейшем создать новые корутины внутри, переключив их на другие потоки. Поэтому самый простой способ попасть в корутинный мир выглядит именно так:</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    println("Начало выполнения программы")

    //Запуск suspend функции
    printTextWithDelay()

    println("Продолжение выполнения программы")
}

suspend fun printTextWithDelay() {
    delay(3000)
    println("Текст, напечатанный просто задержки в 3 секунды")
}</code></pre><p>Результат выполнения будет примерно следующим:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><p>Начало выполнения программы<br/>Текст, напечатанный просто задержки в 3 секунды<br/>Продолжение выполнения программы</p></div></details><p>Почему здесь мы ждали 3 секунды и только потом напечатали "Продолжение выполнение программы"? Как раз-таки по причине, описанной выше: <u>runBlocking блокирует поток</u>, дожидаясь выполнения всех suspend-методов.</p><p>Аналогичного результата можно было бы добиться, написав тот же самый код с помощью <code>suspend main()</code>:</p><pre><code class="kotlin">suspend fun main(args: Array&lt;String&gt;) {
    println("Начало выполнения программы")

    //Запуск suspend функции
    printTextWithDelay()

    println("Продолжение выполнения программы")
}

suspend fun printTextWithDelay() {
    delay(3000)
    println("Текст, напечатанный просто задержки в 3 секунды")
}</code></pre><p>Код выдаст аналогичный результат, как и в первом способе.</p><p>Ну и наконец можно воспользоваться <strong>CoroutineScope</strong>, написав примерно следующий код:</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) {
    println("Начало выполнения программы")

    // Создание пользовательского CoroutineScope
    val scope = CoroutineScope(Job() + Dispatchers.Default)

    // Запуск корутины в созданном scope
    scope.launch {
        printTextWithDelay()
    }

    println("Продолжение выполнения программы")
}</code></pre><p>Результат ее выполнения будет таким:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><p>Начало выполнения программы<br/>Продолжение выполнения программы</p></div></details><p>В данном случае мы создаем новый <strong>CoroutineScope</strong>, определяя его контекст, после чего с помощью билдерп корутин <code>launch()</code> запускаем нашу корутину. Не переживайте если вы не поняли значение слов scope, context и builder, это будет рассмотрено уже ниже.</p><p>Почему не вывелся текст после задержки 3 секунд? Потому что программа завершилась раньше, нежели запустилась наша первая корутина с помощью билдера <code>launch()</code> (о нем мы поговорим чуть ниже, а пока можно запомнить - что с помощью launch мы способны создавать новые корутины, которые будут запускаться асинхронно). Но если мы дождемся наш scope явно с помощью метода <code>.join()</code>, то результат станет аналогичным первым двум:</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    println("Начало выполнения программы")

    // Создание пользовательского CoroutineScope
    val scope = CoroutineScope(Job() + Dispatchers.Default)

    // Запуск корутины в созданном scope
    val job = scope.launch {
        printTextWithDelay()
    }
    job.join() // Дожидаеся выполнения корутины и идем дальше

    println("Продолжение выполнения программы")
}</code></pre><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><p>Начало выполнения программы<br/>Текст, напечатанный просто задержки в 3 секунды<br/>Продолжение выполнения программы</p></div></details><a class="anchor" id="coroutine_scope" name="coroutine_scope"></a><h2>6. Область видимости корутины. CoroutineScope и GlobalScope</h2><p>Давайте теперь разберемся, что же такое область видимости корутины Scope и зачем она вообще нужна.</p><p>На самом деле <strong><u>CoroutineScope</u></strong> - это очень простая вещь, которая нужна только для 2х вещей:</p><ol><li><p>Она хранит в себе <strong>CoroutineContext</strong></p></li><li><p>Она гарантирует, что все корутины, связанные с данным Scope, точно выполнятся (если внутри них не возникнет ошибка или мы их явно не отменим)</p></li></ol><p>Таким образом в рамках одного скоупа мы можем запускать множество корутин с помощью любых билдеров, и в любой момент отменять их в этом скоупе. Простыми словами - <strong>CoroutineScope</strong> - это место жизни наших корутин, которое описывается корутин контекстом, о котором мы поговорим чуть ниже.</p><p>Теперь давайте посмотрим на те CoroutineScope, которые мы можем с вами создать.</p><p>Первым и самым простым Scope является <strong>GlobalScope</strong>.</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><pre><code class="kotlin">@DelicateCoroutinesApi
public object GlobalScope : CoroutineScope {
    /**
     * Returns [EmptyCoroutineContext].
     */
    override val coroutineContext: CoroutineContext
        get() = EmptyCoroutineContext
}</code></pre><p></p></div></details><p>Данный Scope имеет в себе пустой корутин контекст, и будет выполняться до тех пор, пока не выполнятся все дочерние корутины внутри него. Если вы пришли из мира Android-разработки, то относитесь к данному Scope с осторожностью, так как он не привязан к жизненному циклу ваших экранов и поэтому ведёт себя как демон-поток (выполняясь фоново, даже когда метод, в котором вы его вызвали, уже завершён).</p><p>Когда может быть полезен этот Scope? Ответ простой: всегда, когда вам нужно что-то сделать, не привязываясь к конкретным жизненным циклами ваших компонентов. Нужно сделать длительную операцию во время работы вашего приложения или сделать что-то асинхронно не завязываясь на месте в UI вашей программы - смело можно использовать GlobalScope для этих задач. Главное помните, как именно он себя ведёт и используйте его в зависимости от контекста вашей задачи.</p><p>А что делать, если вам захочется использовать свой собственный корутин скоуп, который нужно будет гибко настроить в зависимости от специфики вашей программы? На помощь придет класс <strong>CoroutineScope.</strong></p><p>С его помощью вы сами можете настроить свой <strong>CoroutineContext</strong> и запускать в нем свои корутины:</p><pre><code class="kotlin">fun main() = runBlocking {
    // Создаем контекст с использованием Job и Dispatchers.IO
    val scope = CoroutineScope(Job() + Dispatchers.IO)

    // Запускаем корутину в заданном контексте
    val job = scope.launch {
        // Выполняем блокирующий код в корутине
        println("Запущен в ${Thread.currentThread().name}")
        delay(1000)
        println("Закончен в ${Thread.currentThread().name}")
    }

    // Ожидаем завершения job
    job.join()
    println("Все корутины завершены.")
}</code></pre><p>То есть по сути, единственное отличие вашего GlobalScope от CoroutineScope заключается в том, что во втором случае вы можете самостоятельно настроить свой корутин контекст, в отличие от первого, где он всегда равен EmptyCoroutineContext</p><a class="anchor" id="coroutine_context" name="coroutine_context"></a><h2>7. CoroutineContext или как настроить свою корутину. withContext</h2><p>Каждая корутина имеет свой контекст. Даже когда вы создаёте новую корутину, она либо наследует родительский контекст, либо имеет EmptyCoroutineContext, если родителя просто нет. Но что же такое контекст?</p><p>Контекст корутины - это, по сути, обычный Map из объектов типа <strong>Element</strong>, которые описывают "характеристики" нашей корутины. В качестве таких Element характеристик могут быть:</p><ul><li><p>CoroutineName</p></li><li><p>CoroutineId</p></li><li><p>Dispatcher корутины</p></li><li><p>Job корутины</p></li><li><p>и другие</p></li></ul><p>То есть контекст корутины просто описывает нашу корутину: как она называется, на каких потоках выполняется, какую Job выполняет и так далее.</p><p>Возможно ли изменить этот контекст? Да, и на помощь здесь придет функция <code>withContext()</code>, в которую мы можем передать контекст, на который хотим заменить текущий контекст.</p><pre><code class="kotlin">fun main() = runBlocking {
    println("Running in context: ${coroutineContext[CoroutineName]}")
    
    // Переключение контекста на Dispatchers.IO
    withContext(Dispatchers.IO) {
        println("Running in context: ${coroutineContext[CoroutineName]} on ${Thread.currentThread().name}")
        // Выполнение какой-то IO-операции
    }
    
    println("Back to context: ${coroutineContext[CoroutineName]}")
}</code></pre><p>Заметьте, <code>withContext()</code> <u>заменяет контекст, а не создаёт новую корутину</u>.<br/>Причем определяя новый контекст, вы можете пользоваться оператором плюс, как в примере выше. Почему это возможно? Потому что разработчики библиотеки позаботились о реализации данного оператора в своей библиотеке:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><pre><code class="kotlin">public operator fun plus(context: CoroutineContext): CoroutineContext =
	if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation
		context.fold(this) { acc, element -&gt;
			val removed = acc.minusKey(element.key)
			if (removed === EmptyCoroutineContext) element else {
				// make sure interceptor is always last in the context (and thus is fast to get when present)
				val interceptor = removed[ContinuationInterceptor]
				if (interceptor == null) CombinedContext(removed, element) else {
					val left = removed.minusKey(ContinuationInterceptor)
					if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else
						CombinedContext(CombinedContext(left, element), interceptor)
				}
			}
		}</code></pre><p></p></div></details><p>Проще говоря, код выше добавляет элемент контекста, если такого элемента еще не было, иначе заменяет его (например, если мы захотим переопределить в дальнейшем Dispatcher, речь о котором будет ниже).</p><p>Разобравшись зачем же нужен контекст, давайте подробнее поговорим о его основных <strong>Elemet'ах</strong>.</p><a class="anchor" id="Job" name="Job"></a><h2>8. Работа не Job, или все таки Job? Разбираемся в Job и Deferred</h2><p><strong>Job</strong> - это Element контекста корутины, который описывает текущее состояние корутины (активна ли она в данный момент времени, отменена ли она, какие дочерние Job имеет и есть ли у нее родительская Job и тд).</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><pre><code class="kotlin">public interface Job : CoroutineContext.Element {
    public companion object Key : CoroutineContext.Key&lt;Job&gt;

    @ExperimentalCoroutinesApi
    public val parent: Job?

    public val isActive: Boolean

    public val isCompleted: Boolean

    public val isCancelled: Boolean

    @InternalCoroutinesApi
    public fun getCancellationException(): CancellationException

    public fun start(): Boolean
	
    public fun cancel(cause: CancellationException? = null)
	
    @Deprecated(level = DeprecationLevel.HIDDEN, message = "Since 1.2.0, binary compatibility with versions &lt;= 1.1.x")
    public fun cancel(): Unit = cancel(null)
	
    @Deprecated(level = DeprecationLevel.HIDDEN, message = "Since 1.2.0, binary compatibility with versions &lt;= 1.1.x")
    public fun cancel(cause: Throwable? = null): Boolean

    public val children: Sequence&lt;Job&gt;

    @InternalCoroutinesApi
    public fun attachChild(child: ChildJob): ChildHandle

    public suspend fun join()
	
    @Suppress("DeprecatedCallableAddReplaceWith")
    @Deprecated(message = "Operator '+' on two Job objects is meaningless. " +
        "Job is a coroutine context element and `+` is a set-sum operator for coroutine contexts. " +
        "The job to the right of `+` just replaces the job the left of `+`.",
        level = DeprecationLevel.ERROR)
    public operator fun plus(other: Job): Job = other
}</code></pre><p></p></div></details><p>Как создавать и управлять Job, мы поговорим разделом ниже. Но прежде чем мы его коснемся обсудим ещё один важный тип - тип <strong>Deferred</strong>.</p><p>Если вспомнить определение корутин, то мы столкнемся с асинхронностью, из которой фактически следует, что никто не знает когда закончится та или иная асинхронная операция. Но как вернуть результат из корутины и/или дождаться его возвращения? На помощь придет тип Deferred, который является наследником Job (а значит наследует все его свойства и методы) и дополнительно имеет метод await, позволяющий нам дождаться выполнения работы и получить результат из корутины:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><pre><code class="kotlin">public interface Deferred&lt;out T&gt; : Job {
    public suspend fun await(): T

    public val onAwait: SelectClause1&lt;T&gt;

    @ExperimentalCoroutinesApi
    public fun getCompleted(): T

    @ExperimentalCoroutinesApi
    public fun getCompletionExceptionOrNull(): Throwable?
}</code></pre><p></p></div></details><p>То есть <strong>Deferred</strong> - это обычная расширенная Job, которая дополнительно предоставляет нам возможность <u>дождаться получения результата</u>.</p><p>Окей, с этим разобрались. Но как создавать и работать с Job и Deferred? Забегая вперёд: с помощью специальных билдеров. Давайте теперь разберемся с этим.</p><a class="anchor" id="coroutine_builder" name="coroutine_builder"></a><h2>9. Запуск корутины с помощью Coroutine Builders. launch и async</h2><p>Для того, чтобы создать Job нужно воспользоваться корутин билдером <code>launch()</code>, который после вызова в каком-то контексте <u>вернёт</u> нам ссылку на полученную <u>Job</u>:</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    println("Начало выполнения программы")

    // Создание пользовательского CoroutineScope
    val scope = CoroutineScope(Job() + Dispatchers.Default)

    // Создание и запуск корутины
    val job = scope.launch {
        printTextWithDelay()
    }

    println("Продолжение выполнения программы")
    job.join() // Дожидаеся выполнения корутины
}</code></pre><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><p>Начало выполнения программы<br/>Продолжение выполнения программы<br/>Текст, напечатанный просто задержки в 3 секунды</p></div></details><p>Причем если мы посмотрим исходники этого метода:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><pre><code class="kotlin">public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; Unit
): Job {
    val newContext = newCoroutineContext(context)
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    coroutine.start(start, coroutine, block)
    return coroutine
}</code></pre><p></p></div></details><p>то мы можем заметить, что:</p><ol><li><p>он обязательно должен вызываться на каком-то корутин контексте (чаще всего это унаследованный контекст от родительской корутины)</p></li><li><p>Мы можем дополнительно указать дополнение к нашему CoroutineContext при вызове этого метода (именно дополнение контекста, а не новый):</p></li></ol><pre><code class="kotlin">val job = scope.launch(Dispatchers.IO) {
    printTextWithDelay()
}</code></pre><ol start="3"><li><p>В качестве параметра мы можем дополнительно указать ленивый метод инициализации, который запустит корутину не сразу, а только после явного вызова метода <code>start()</code> на нашей Job:</p></li></ol><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    println("Начало выполнения программы")

    // Создание пользовательского CoroutineScope
    val scope = CoroutineScope(Job() + Dispatchers.Default)

    // Создание корутины
    val job = scope.launch(
        context = Dispatchers.IO,
        start = CoroutineStart.LAZY
    ) {
        printTextWithDelay()
    }

    println("Продолжение выполнения программы")
    job.start() // Запуск корутины
    job.join() // Дожидаеся выполнения корутины
}</code></pre><p>Результат аналогичен предыдущему:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><p>Начало выполнения программы<br/>Продолжение выполнения программы<br/>Текст, напечатанный просто задержки в 3 секунды</p></div></details><p>И да, помните про атрибут у Job, который содердит внутри себя все дочерние job? Так вот, в заполнении этих атрибутов никакой магии нет - этим как раз таки и занимается билдер launch. Это можно увидеть, провалившись в исходниках данного метода:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><pre><code class="kotlin">private open class StandaloneCoroutine(
    parentContext: CoroutineContext,
    active: Boolean
) : AbstractCoroutine&lt;Unit&gt;(parentContext, initParentJob = true, active = active) {
    override fun handleJobException(exception: Throwable): Boolean {
        handleCoroutineException(context, exception)
        return true
    }
}

...

public abstract class AbstractCoroutine&lt;in T&gt;(
    parentContext: CoroutineContext,
    initParentJob: Boolean,
    active: Boolean
) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope {

    init {
        if (initParentJob) initParentJob(parentContext[Job])
    }
	...
}

...

protected fun initParentJob(parent: Job?) {
	...
	@Suppress("DEPRECATION")
	val handle = parent.attachChild(this)
	parentHandle = handle
	...
}</code></pre><p></p></div></details><p>При этом <strong>родительская Job</strong> определяется в том же методе из <code>initParentJob()</code> из контекста:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><pre><code class="kotlin">public open class JobSupport constructor(active: Boolean) : Job, ChildJob, ParentJob {
    final override val key: CoroutineContext.Key&lt;*&gt; get() = Job
	
	override val parent: Job?
        get() = parentHandle?.parent 
		
	protected fun initParentJob(parent: Job?) {
		...
		@Suppress("DEPRECATION")
		val handle = parent.attachChild(this)
		parentHandle = handle
		...
	}
	
	...
}</code></pre><p></p></div></details><p>С launch разобрались. А что насчёт async?</p><p><strong><u>Async</u></strong> - это похожий билдер корутин, но возвращает он уже не Job, а его наследника Deffered. При этом параметры этого билдера очень похожи на launch:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><pre><code class="kotlin">public fun &lt;T&gt; CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; T
): Deferred&lt;T&gt; {
    val newContext = newCoroutineContext(context)
    val coroutine = if (start.isLazy)
        LazyDeferredCoroutine(newContext, block) else
        DeferredCoroutine&lt;T&gt;(newContext, active = true)
    coroutine.start(start, coroutine, block)
    return coroutine
}</code></pre><p></p></div></details><p>Работа с ним также очень похожа на работу с launch, только теперь у нас есть возможность дождаться и вернуть результат с помощью метода <code>await()</code>:</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    println("Начало выполнения программы")

    // Создание пользовательского CoroutineScope
    val scope = CoroutineScope(Job() + Dispatchers.Default + CoroutineName("123"))

    // Создание и запуск корутины
    val deferred = scope.async {
        delay(3000)
        return@async Math.random()
    }

    println("Продолжение выполнения программы")

    // Дожидаеся результата из корутины
    val result = deferred.await()
    println("Результат = $result")
}</code></pre><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><p>Начало выполнения программы<br/>Продолжение выполнения программы<br/>Результат = 0.8867756197456322</p></div></details><p>Подытожим выше сказанное:</p><ol><li><p>Билдеры корутин позволяют создать новую корутину, предоставляя возможность для нее переопределить родительский контекст. Если такого переопределения нет, контекст будет автоматически унаследован от родителя</p></li><li><p>Билдер launch возвращает объект типа <strong>Job</strong>, а билдер async - типа <strong>Deferred</strong> (предоставляя возможность вернуть значение из корутины)</p></li><li><p>Используя launch и async можно выстроить свою иерархию работ, при этом мы можем быть уверены что атрибуты children и parent в Job будут заполнены правильно при вызове этих билдеров</p></li></ol><a class="anchor" id="dispatchers" name="dispatchers"></a><h2>10. Dispatchers. Основные виды диспетчеров в корутинах и область их применения</h2><p>Давайте разберемся ещё с одним элементом контекста корутины, а именно с диспетчером.</p><p><strong>Диспатчер</strong> определяет на каких потоке(ах) будет выполняться ваша корутина. Существует множество диспатчеров, но мы разберём основные 4 вида и рассмотрим область их применения:</p><ol><li><p><strong>Diapatchers.Main</strong> - данный диспатчер говорит, что весь код вашей корутины должен выполняться в главном потоке. Его можно использовать, например, для работы с UI, так как в противном случае долгие операции (такие как сетевые вызовы, работа с базами данных или долгие расчеты) могут создать серьезную нагрузку на вашем главном потоке, а в следствие с этим и лаги на экране пользователя.</p></li><li><p><strong>Dispatchers.Default</strong> - данный вид диспатчера распределяет корутину на число потоков равное числу ядер. Его  рекомендуется использовать для долгих/интенсивных вычислений, связанных с работой CPU. Он использует ограниченный пул общих потоков</p></li><li><p><strong>Dispatchers.IO</strong> - этот вид диспатчера распределяет корутину на пуле общих потоков (обычно это 64 потока, но в зависимости от системы это число может изменяться). Под капотом он имеет сложную логику, которая рассчитывает, когда нужно добавить ещё один поток для выпололнения нашей корутины. И если не углубляться далеко в архитектуру нашего железа, то можно сказать, что этот вид диспатчера лучше применять для "ожидающих" вызовов (сетевые вызовы, работа с базами данных, запись и чтение в файлы). Это связано с тем что под капотом данного диспатчера также зашит таймер, который через время пробуждает так называемые "спящие" (ожидающие) корутины</p></li><li><p><strong>Diapatchera.Unconfined</strong> - диспатчер, который начинается на потоке, на котором его запустили и после первой приостановки возобновляется на любом случайном потоке. Некоторые источники рекомендуют его использовать, когда нам не важно, на каком потоке будет выполняться корутина, но на практике я лично так и не встретил такой ситуации когда бы он понадобился. Более подробно с ним можно ознакомиться на странице <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html" rel="noopener noreferrer nofollow">официальной документации</a></p></li></ol><a class="anchor" id="error" name="error"></a><h2>11. Способы обработок ошибок в корутинах. Try-catch, runCatching, CoroutineExceptionHandler, SupervisorJob / supervisorScope</h2><p>Теперь коснемся одной из самых важных тем, от которой напрямую зависит качество вашего продукта. Мы поговорим о различных способах обработки ошибок в корутинах.</p><p>Давайте для начала рассмотрим, что произойдет если в корутине возникнет ошибка. Допустим, во время нашего сетевого вызова возникнет ошибка:</p><pre><code class="kotlin">suspend fun loadImage() {
    withContext(Dispatchers.IO) {
        println("Начало загрузки фото")
        Thread.sleep(3000) // Ожидание сервера
        throw IOException("Ошибка во время сетевого запроса")
    }
}

fun main(args: Array&lt;String&gt;) = runBlocking {
    // Создание пользовательского scope
    val scope = CoroutineScope(EmptyCoroutineContext)
    
	// Запуск корутины с загрузкой фото
    val job1 = scope.launch { 
        loadImage()
    }
    
	// Дожидаемся выполнения job1
    job1.join()
}</code></pre><p>Это может быть ошибка любого рода: исключение при работе с сетью, получение null'а там, где его не ждали и т.д. В данном случае корутина, на которой возникло это исключение, просто отменится, уничтожив нашу программу с ошибкой:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><p><em>Начало загрузки фото<br/>Exception in thread "main" java.io.IOException: Ошибка во время сетевого запроса</em></p></div></details><p>Но это пол беды. Если наша программа имела несколько корутин в одном Scope, то при возникновении ошибки в одной из корутин, она отменяет и родительские корутины, и дочерние.</p><pre><code class="kotlin">suspend fun loadImage() {
    withContext(Dispatchers.IO) {
        println("Начало загрузки фото")
        Thread.sleep(3000) // Ожидание сервера
        throw IOException("Ошибка во время сетевого запроса")
    }
}

fun main(args: Array&lt;String&gt;) = runBlocking {
    // Создание пользовательского scope
    val scope = CoroutineScope(EmptyCoroutineContext)

    // Запуск корутины с загрузкой фото
    val job1 = scope.launch {
        loadImage()
    }

    val job2 = scope.launch {
        println("Начало job2")
        delay(5000)
        println("Завершение job2")
    }

    // Дожидаемся выполнения job1
    job1.join()
    job2.join()
}</code></pre><p>В результате мы увидим:</p><p><em>Начало job2<br/>Начало загрузки фото<br/>Exception in thread "DefaultDispatcher-worker-4" java.io.IOException: Ошибка во время сетевого запроса</em></p><p>Это не очевидный момент, который необходимо железобетонно запомнить, так как одно необработанное исключение может послужить проблемой в вашей программе.</p><p>Теперь давайте рассмотрим основные способы обработки исключений.</p><ol><li><p>Первый способ это стандартная обработка с помощью <strong>try-catch</strong>. Да, дёшево и сердито, без какой-либо магии мы можем избежать краша нашей программы, просто обработав возможную ошибку в стандартном блоке обработчике ошибок:</p></li></ol><pre><code class="kotlin">suspend fun loadImage() {
    withContext(Dispatchers.IO) {
        println("Начало загрузки фото")
        Thread.sleep(3000) // Ожидание сервера
        throw IOException("Ошибка во время сетевого запроса")
    }
}

fun main(args: Array&lt;String&gt;) = runBlocking {
    // Создание пользовательского scope
    val scope = CoroutineScope(EmptyCoroutineContext)

    // Запуск корутины с загрузкой фото
    val job1 = scope.launch {
        try {
            loadImage()
        } catch (e: Exception) {
            println("Ошибка обработана")
        }
    }

    val job2 = scope.launch {
        println("Начало job2")
        delay(5000)
        println("Завершение job2")
    }

    // Дожидаемся выполнения job1
    job1.join()
    job2.join()
}</code></pre><p>Результат:<br/> <em>Начало загрузки фото<br/> Начало job2<br/> Ошибка обработана<br/> Завершение job2</em></p><p>Причем, как вы заметили, даже если мы вызывали <code>withContext</code> (который очень желателен для сетевых вызовов), то вам необязательно дважды обрабатывать ошибку в своем коде. <code>withContext</code> не создаёт новую корутину, он лишь меняет контекст, и ошибка также будет обработана как в примере выше.</p><ol start="2"><li><p>Второй способ - это использование <strong>runCatching</strong>:</p></li></ol><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    // Создание пользовательского scope
    val scope = CoroutineScope(EmptyCoroutineContext)

    // Запуск корутины с загрузкой фото
    val job1 = scope.launch {
        val result = kotlin.runCatching {
            loadImage()
        }.onSuccess {
            // ... блок кода при успешном выполнении корутины
            println("Загрузка прошла успешно")
        }.onFailure {
            // ... блок кода при возникновении ошибки
            println("Ошибка во время загрузки")
        }
    }

    // Дожидаемся выполнения job1
    job1.join()
}</code></pre><p>Результат:<br/> <em>Начало загрузки фото<br/> Ошибка во время загрузки</em></p><p>Данный метод позволяет определить нам действия при успешном выполнении корутины и действия при ошибки.<br/> Если же мы откроем исходники данного метода, то увидим, что никакой магии на самом деле нет:</p><details class="spoiler"><summary>Скрытый текст</summary><div class="spoiler__content"><pre><code class="kotlin">public inline fun &lt;R&gt; runCatching(block: () -&gt; R): Result&lt;R&gt; {
    return try {
        Result.success(block())
    } catch (e: Throwable) {
        Result.failure(e)
    }
}</code></pre><p></p></div></details><p>Под капотом <code>runCatching</code> использует тот же самый try-catch, но, на мой взгляд, код с ним выглядит несколько красивее.</p><ol start="3"><li><p>Теперь рассмотрим подробнее обработку ошибок с помощью <strong>CoroutineExceptionHandler</strong>:</p></li></ol><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    // Создание CoroutineExceptionHandler
    val coroutineExceptionHandler = CoroutineExceptionHandler { context, throwable -&gt;
        println("Ошибка $throwable в $context")
    }

    // Создание пользовательского scope c CoroutineExceptionHandler в контексте
    val scope = CoroutineScope(coroutineExceptionHandler)

    // Запуск корутины с загрузкой фото
    val job1 = scope.launch {
        loadImage()
    }

    // Дожидаемся выполнения job1
    job1.join()
}</code></pre><p>Данный хэндлер является элементом контекста корутины, а потому мы можем применить его для всех корутин определенного Scope, указав, как именно обрабатывать любую ошибку, возникшую в этих корутинах.</p><p>Это может быть полезно, если мы хотим обработать разом вообще все ошибки в своем корутине контексте, как в примере выше. Но это можно же посчитать и минусом: мы не можем точно сказать, в какой именно корутине возникла ошибка.</p><ol start="4"><li><p>И, наконец, рассмотрим ещё один способ обработки корутин, с помощью <strong>SupervisorJob</strong> и <strong>supervisorScope</strong>. Начнем с первого.</p></li></ol><p><strong><u>SupervisorJob</u></strong> - это элемент контекста, указав который мы как бы говорим, что возникшую ошибку в корутине не нужно прокидывать вверх, как это происходит обычно. Нужно только отменить эту корутину и её дочерние. Давайте посмотрим пример:</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    // Создание пользовательского scope с SupervisorJob в контексте
    val scope = CoroutineScope(SupervisorJob())

    val job1 = scope.launch {
        println("job1 start")
        delay(2000)
        throw IOException("Ошибка во время сетевого запроса")
    }

    val job2 = scope.launch {
        println("job2 start")
        delay(4000)
        println("job2 end")
    }

    val job3 = scope.launch {
        println("job3 start")
        delay(3000)
        println("job3 end")
    }

    // Дожидаемся выполнения всех job
    job1.join()
    job2.join()
    job3.join()
}</code></pre><p>В результате выполнения ошибка возникающая в job1 не отменит остальные корутины в данном scope, так как в launch этой джобы мы передаём наш supervisorJob:</p><p>Результат:<br/><em>job1 start<br/> job2 start<br/> job3 start<br/> Exception in thread "DefaultDispatcher-worker-1" java.io.IOException: Ошибка во время сетевого запроса<br/> job3 end<br/> job2 end</em></p><p>Теперь давайте посмотрим на этот код:</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    // Создание пользовательского scope с SupervisorJob в контексте
    val scope = CoroutineScope(SupervisorJob())

    val job = scope.launch {
        val job1 = launch {
            println("job1 start")
            delay(2000)
            throw IOException("Ошибка во время сетевого запроса")
        }

        val job2 = launch {
            println("job2 start")
            delay(4000)
            println("job2 end")
        }

        val job3 = launch {
            println("job3 start")
            delay(3000)
            println("job3 end")
        }

        job1.join()
        job2.join()
        job3.join()
    }

    // Дожидаемся выполнения всех job
    job.join()
}</code></pre><p>Результат:<br/> <em>job1 start<br/> job3 start<br/> job2 start<br/> Exception in thread "DefaultDispatcher-worker-4" java.io.IOException: Ошибка во время сетевого запроса</em></p><p>В результате выполнения все три джобы отменяется. Но почему в первом случае все работало нормально, а тут все отменилось? Казалось бы, мы же использовали SupervisorJob в первой джобе. Это и есть одна из самых распространенных ошибок: в данном случае вложенные launch - это дочерние корутины job1, а примером выше все три job принадлежат одному scope. Наглядно это можно изобразить так:</p><figure class="full-width"><img alt="Отмена вложенных корутин" data-blurred="true" data-src="https://habrastorage.org/getpro/habr/upload_files/11c/0a9/e54/11c0a9e540cbe78d4bc8edd8906558b0.jpg" height="2772" src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/11c/0a9/e54/11c0a9e540cbe78d4bc8edd8906558b0.jpg" title="Отмена вложенных корутин" width="2862"/><div><figcaption>Отмена вложенных корутин</figcaption></div></figure><p>А в первом случае, когда мы запускали все корутины от одного Scope, это выглядело так:</p><figure class="full-width"><img alt="Отмена корутин в единном Scope" data-blurred="true" data-src="https://habrastorage.org/getpro/habr/upload_files/a51/f75/e41/a51f75e415e68185590e1bba67b4277e.jpg" height="1622" src="https://habrastorage.org/r/w780q1/getpro/habr/upload_files/a51/f75/e41/a51f75e415e68185590e1bba67b4277e.jpg" title="Отмена корутин в единном Scope" width="2862"/><div><figcaption>Отмена корутин в единном Scope</figcaption></div></figure><p>Работа с SupervisorScope выглядит аналогично, за тем исключением, что мы работаем со скоупом:</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    supervisorScope {
        val job1 = launch {
            println("job1 start")
            delay(2000)
            throw IOException("Ошибка во время сетевого запроса")
        }

        val job2 = launch {
            println("job2 start")
            delay(4000)
            println("job2 end")
        }

        val job3 = launch {
            println("job3 start")
            delay(3000)
            println("job3 end")
        }

        // Дожидаемся выполнения всех job
        job1.join()
        job2.join()
        job3.join()
    }
}</code></pre><p>И опять никакой магии нет. Главное внимательно смотреть в каком scope вы создаёте и запускаете свои корутины, и этот корутинный мир станет чуточку лучше :)</p><a class="anchor" id="cancel" name="cancel"></a><h2>12. Отмена корутин</h2><p>Этот пункт я не случайно оставил последним, и сейчас объясню почему. Давайте посмотрим следующий пример отмены корутин:</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    // Создание пользовательского CoroutineScope
    val scope = CoroutineScope(EmptyCoroutineContext)

    // Запускаем корутину
    val job1 = scope.launch {
        println("Начало job")

        launch {
            println("Старт дочерней корутины")
            delay(4000)
            println("Конец дочерней корутины")
        }

        delay(3000)
        println("Конец job")
    }

    // Старт другой корутины в том же Scope
    val job2 = scope.launch {
        println("Старт другой job")
        delay(5000)
        println("Конец другой job")
    }

    // Небольшая пауза, так как запуск корутин происходит не мгновенно
    // и отмена может быть раньше, чем job запустится
    delay(500)

    // Отменяем job1 (и как следствие, все дочерние корутины)
    job1.cancel()

    job1.join()
    job2.join()
}</code></pre><p>Результат:<br/> <em>Начало job<br/> Старт дочерней корутины<br/> Старт другой job<br/> Конец другой job</em></p><p>Для отмены job1 мы вызываем метод <code>cancel()</code>, который отменяет данную корутины и все дочерние корутины (job2 и job3, соответственно). Стоит отметить, что отмена происходит не мгновенно: мы как бы говорим котлину, что нужно отменить это джобу, а он уже при первой возможности этим займётся. Но как он понимает, какие корутины (а именно дочерние) нужно отменить?</p><p>А происходит это очень просто - путем <u>генерации</u> исключения <strong>CancelationException</strong>. Только данный вид исключения отменяет все корутины вниз, <u>не отменяя их вверх</u> и это зашито под капотом корутинного мира.</p><p>Вы можете это проверить, сгенерировав исключение CancelationException в любой вашей корутине, и увидев что родительская Job не будет отменяться, а вот дочерние закончат свое выполнение:</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    // Создание пользовательского CoroutineScope
    val scope = CoroutineScope(EmptyCoroutineContext)

    // Запускаем корутину
    val job1 = scope.launch {
        println("Начало job")

        launch {
            println("Старт дочерней корутины")
            delay(4000)
            println("Конец дочерней корутины")
        }

        delay(3000)
        throw CancellationException() // Аналог cancel()
        println("Конец job")
    }

    // Старт другой корутины в том же Scope
    val job2 = scope.launch {
        println("Старт другой job")
        delay(5000)
        println("Конец другой job")
    }

    // Небольшая пауза, так как запуск корутин происходит не мгновенно
    // и отмена может быть раньше, чем job запустится
    delay(500)

    job1.join()
    job2.join()
}</code></pre><p>Аналогично вы можете отменять не отдельные джобы, а целые scope, вызывая все тот же метод <code>cancel()</code>:</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) = runBlocking {
    // Создание пользовательского CoroutineScope
    val scope = CoroutineScope(EmptyCoroutineContext)

    // Запускаем корутину
    scope.launch {
        println("Начало job")

        launch {
            println("Старт дочерней корутины")
            delay(4000)
            println("Конец дочерней корутины")
        }

        delay(3000)
        println("Конец job")
    }

    // Старт другой корутины в том же Scope
    scope.launch {
        println("Старт другой job")
        delay(5000)
        println("Конец другой job")
    }

    // Небольшая пауза, так как запуск корутин происходит не мгновенно
    // и отмена может быть раньше, чем job запустится
    delay(500)

    //Отменем все корутины в заданном scope
    scope.cancel()
}</code></pre><p>Результат:<br/> Начало job<em><br/> Старт дочерней корутины<br/> Старт другой job</em></p><a class="anchor" id="custom_scope" name="custom_scope"></a><h2>13. Создание пользовательского Scope</h2><p>Разобравшись со всеми основными моментами в корутинах, мы можем самостоятельно попробовать создать свой пользовательский CoroutineScope, сделав его контекст настраиваемым через параметры конструктора. Выглядеть это будет это примерно так:</p><pre><code class="kotlin">/**
 * CoroutineScope для фоновой загрузки файлов в рамах отдельной фичи
 * Все возникшие сетевые ошибки обрабатываются в [errorCallback]
 */
class LoadCoroutineScope(
    private val parentCoroutineContext: CoroutineContext = EmptyCoroutineContext,
    private val dispatcher: CoroutineDispatcher = Dispatchers.IO,
    private val coroutineName: CoroutineName = CoroutineName(DEFAULT_COROUTINE_NAME),
    private val errorCallback: (CoroutineContext, Throwable) -&gt; Unit
) : CoroutineScope {

    override val coroutineContext: CoroutineContext
        get() = parentCoroutineContext + dispatcher + coroutineName + SupervisorJob() +
                CoroutineExceptionHandler { coroutineContext, throwable -&gt; 
                    errorCallback(coroutineContext, throwable)
                }
    
    companion object {
        private const val DEFAULT_COROUTINE_NAME = "Loading CoroutineScope"
    }
}</code></pre><p>Как видите, ничего сложного в своем Scope нет: нам достаточно просто настроить его контекст под наши цели и дальше запускать от него корутины. Теперь мы можем вызвать наш собственный CoroutineScope и при желании настроить его запуск и отмену в соответствии с жизненным циклом нашего приложения.</p><p>На самом деле, вы можете сделать даже собственный вид Job, но, пожалуй, это не будет входить в рамки данной статьи, а останется для кого-то домашним заданием.</p><a class="anchor" id="end" name="end"></a><h2>Заключение</h2><p>В этой статье я постарался раскрыть вам всю магию корутинного мира, обращаясь лишь к небольшой части исходников библиотеки. Надеюсь, для кого-то эти старания были не зря, и это непременно поможет им на практике и собеседованиях.</p><p>Но я дополнительно рекомендую после прочтения статьи немного попрактиковаться с созданием корутин, параллельно заглядывая в исходники библиотеки: это, на мой взгляд, поможет намного лучше осветить оставшиеся темные места, раскрыв окончательно пелену неизвестности корутинного мира.</p><p></p></div></div></div><!-- --><!-- --></div><!-- --><!-- --></div><!--]--><!-- --><div class="tm-article-presenter__meta" data-test-id="article-meta-links"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[Kotlin]"><span>Kotlin</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[coroutine]"><span>coroutine</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[coroutines]"><span>coroutines</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[%D0%BA%D0%BE%D1%80%D1%83%D1%82%D0%B8%D0%BD%D1%8B]"><span>корутины</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C]"><span>асинхронность</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5+%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5]"><span>асинхронное программирование</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[dispatcher]"><span>dispatcher</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[launch]"><span>launch</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[async]"><span>async</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[deffered]"><span>deffered</span></a><!--]--></li><!--]--><!-- --></ul></div><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/hubs/kotlin/"><!--[--><span>Kotlin</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/hubs/android_dev/"><!--[--><span>Разработка под Android</span><!--]--></a><!--]--></li><!--]--><!-- --></ul></div></div><!-- --><!--]--></article><!--]--></div><!-- --></div><div class="tm-article-sticky-panel" data-test-id="article-sticky-panel" style=""><div class="tm-data-icons tm-data-icons tm-data-icons_space-big tm-article-sticky-panel__icons" data-test-id="article-stats-icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon tm-votes-meter__icon_appearance-article" height="24" width="24"><title>Всего голосов 25: ↑25 и ↓0</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-rating"></use></svg><span class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating tm-votes-meter__value" data-test-id="votes-meter-value" title="Всего голосов 25: ↑25 и ↓0">+29</span></div><!--teleport start--><!--teleport end--><!-- --></div><!-- --><!-- --><button class="bookmarks-button tm-data-icons__item" title="Добавить в закладки" type="button"><span class="tm-svg-icon__wrapper bookmarks-button__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Добавить в закладки</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-favorite"></use></svg></span><span class="bookmarks-button__counter" title="Количество пользователей, добавивших публикацию в закладки">188</span></button><div class="tm-sharing tm-data-icons__item" title="Поделиться"><button class="tm-sharing__button" type="button"><svg class="tm-sharing__icon" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z" fill="currentColor"></path></svg></button><!--teleport start--><!--teleport end--></div><div class="tm-article-comments-counter-link tm-data-icons__item" title="Читать комментарии"><a class="tm-article-comments-counter-link__link" data-test-id="counter-comments" href="/ru/articles/838974/comments/"><!--[--><svg class="tm-svg-img tm-article-comments-counter-link__icon" height="24" width="24"><title>Комментарии</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value">12</span><!--]--></a><!-- --></div><!--[--><!--[--><!--[--><!-- --><!--]--><!--]--><!--]--><!--teleport start--><!--teleport end--><!-- --></div></div></div><!--[--><!--]--><div class="tm-article-presenter__footer"><!--[--><!--[--><div class="tm-article-blocks"><!-- --><!--[--><section class="tm-block tm-block tm-block_spacing-bottom"><!-- --><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-balanced"><!--[--><div class="tm-article-author" data-test-id="article-author-info"><!--[--><!--]--><div class="tm-user-card tm-user-card tm-user-card_variant-article tm-article-author__user-card" data-async-called="true"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a class="tm-user-card__userpic tm-user-card__userpic_size-40" href="/ru/users/E-Coding/"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" src="//habrastorage.org/getpro/habr/avatars/06f/0d8/bbd/06f0d8bbd16af532b0e1ed5246fee330.jpg"/></div></a><div class="tm-user-card__meta"><div class="tm-counter-container tm-karma tm-karma" title=" 6 голосов "><div class="tm-counter-container__header"><!--[--><div class="karma-display positive" data-v-7635202e="">6</div><!-- --><!--]--></div><div class="tm-counter-container__footer"><!--[--><div class="tm-karma__text">Карма</div><!--teleport start--><!--teleport end--><!--]--></div></div><div class="tm-counter-container" title="Рейтинг пользователя"><div class="tm-counter-container__header"><!--[--><!--[--><!--]--><div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating"><!-- --><div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score"><!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">0</span></span><!--]--></div><!-- --></div><!--]--></div><div class="tm-counter-container__footer"><!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]--></div></div></div></div></div><div class="tm-user-card__info tm-user-card__info_variant-article tm-user-card__info"><div class="tm-user-card__title tm-user-card__title_variant-article tm-user-card__title"><span class="tm-user-card__name tm-user-card__name_variant-article tm-user-card__name">Кузьменко Павел</span><a class="tm-user-card__nickname tm-user-card__nickname tm-user-card__nickname_variant-article" href="/ru/users/E-Coding/"> @E-Coding</a><!-- --></div><p class="tm-user-card__short-info tm-user-card__short-info_variant-article tm-user-card__short-info" data-test-id="user-card-speciality">Android developer</p></div></div><div class="tm-user-card__buttons tm-user-card__buttons_variant-article tm-user-card__buttons"><!-- --><div class="tm-user-card__button"><div class="tm-button-follow tm-user-card__button-follow"><!-- --><button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button></div></div><!-- --><div class="tm-user-card__button tm-user-card__button_write" data-test-id="user-card-conversations"><svg class="tm-svg-img tm-user-card__button-icon" height="16" width="16"><title>Отправить сообщение</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#mail"></use></svg></div><!-- --></div><!-- --></div><!-- --></div><!--]--></div><!--]--><!-- --></section><!-- --><!--[--><div class="banner-wrapper leaderboard tm-page-article__banner" data-v-ad758baa="" style="--467224fc:200px;--58ff5eba:auto;"><!--[--><div class="placeholder-wrapper placeholder" data-v-ad758baa=""><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="adfox-banner-placeholder leaderboard" data-v-12f7bcca=""><div class="image loads" data-v-12f7bcca=""></div><div class="lines" data-v-12f7bcca=""><div class="line loads" data-v-12f7bcca=""></div><div class="line loads" data-v-12f7bcca=""></div><div class="line loads" data-v-12f7bcca=""></div></div></div><!-- --></div><div class="tm-adfox-banner" data-v-ad758baa="" id="adfox_164725660339535756"></div><!--]--></div><!--]--><!--]--><div class="tm-article-blocks__comments"><div class="tm-article-page-comments" id="publication-comments"><div><!--[--><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style" data-test-id="counter-comments" href="/ru/articles/838974/comments/"><!--[--><svg class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted" height="24" width="24"><title>Комментарии</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted"> Комментарии 12 </span><!--]--></a><!-- --></div><!--]--></div></div></div><!--[--><!--[--><!--]--><section class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header tm-block__header_variant-borderless"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title tm-block__title_variant-large">Публикации</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-condensed-slim"><!--[--><!--[--><div class="tm-tabs tm-tabs"><div class=""><!--[--><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link_active tm-tabs__tab-link_slim tm-tabs__tab-link">Лучшие за сутки</button></span><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link_slim tm-tabs__tab-link">Похожие</button></span><!--]--></div><!-- --></div><div class="similar-and-daily__tab-view"><div class="daily-articles-list"><ul class="tm-article-card-list"><!--[--><!--]--><div class="tm-bordered-card"><!-- --><!--[--><!--]--></div></ul><div class="daily-articles-block__button-container"><button class="btn btn_transparent btn_small tm-button tm-button_color-horizon" type="button"><!--[--><!--[-->Показать лучшие за всё время<!--]--><!--]--></button></div></div><!-- --></div><!--]--><!--]--></div><!--]--><!-- --></section><!--[--><div><div class="placeholder-wrapper"><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="tm-placeholder-promo"><div class="tm-placeholder-promo__header"><div class="tm-placeholder__line tm-placeholder__line_promo-title"></div></div><div class="tm-placeholder-promo__body"><div class="tm-placeholder-promo__posts"><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div></div><div class="tm-placeholder-promo__dots"><div class="tm-placeholder-promo__dot"></div><div class="tm-placeholder-promo__dot"></div><div class="tm-placeholder-promo__dot"></div></div></div></div><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --></div></div><div><div class="placeholder-wrapper"><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="tm-placeholder-inset tm-placeholder-salary"><div class="tm-placeholder-inset__header"><div class="tm-placeholder__line tm-placeholder__line_inset-header loads"></div></div><div class="tm-placeholder-salary__body"><div class="tm-placeholder-salary__text"><div class="tm-placeholder__line tm-placeholder__line_salary_average"></div><div class="tm-placeholder-salary__description"><div class="tm-placeholder__line loads"></div><div class="tm-placeholder__line loads"></div><div class="tm-placeholder__line loads"></div><div class="tm-placeholder__line loads"></div></div></div><div class="tm-placeholder-salary__image loads"></div></div><div class="tm-placeholder-inset__footer tm-placeholder-inset__footer_salary"><div class="tm-placeholder__line tm-placeholder__line_inset-footer loads"></div></div></div><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --></div></div><!--]--><!-- --><!--[--><!--]--><!--]--></div><!--]--><!--]--></div></div><!--]--><!--]--></div></div><div class="tm-page__sidebar"><!--[--><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div><div class="tm-sexy-sidebar_initial tm-sexy-sidebar" style="margin-top:0px;"><!--[--><!--]--><!-- --><div class="tm-layout-sidebar__ads_initial tm-layout-sidebar__ads"><div class="banner-wrapper half-page tm-layout-sidebar__banner tm-layout-sidebar__banner_top" data-v-ad758baa="" style="--467224fc:600px;--58ff5eba:auto;"><!--[--><div class="placeholder-wrapper placeholder" data-v-ad758baa=""><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="adfox-banner-placeholder half-page" data-v-12f7bcca=""><div class="image loads" data-v-12f7bcca=""></div><div class="lines" data-v-12f7bcca=""><div class="line loads" data-v-12f7bcca=""></div><div class="line loads" data-v-12f7bcca=""></div><div class="line loads" data-v-12f7bcca=""></div></div></div><!-- --></div><div class="tm-adfox-banner" data-v-ad758baa="" id="adfox_164725680533065327"></div><!--]--></div></div><!--[--><!-- --><section class="tm-block tm-block tm-block_spacing-around tm-stories-block" data-async-called="true" data-navigatable="" tabindex="0"><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Истории</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-equal"><!--[--><div class="tm-stories-empty"><!--[--><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><!--]--></div><!-- --><!--]--></div><!--]--><!-- --></section><section class="tm-block tm-block tm-block_spacing-around" data-async-called="true"><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Работа</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body"><!--[--><!--[--><div class="tm-vacancies-block__item"><a class="tm-vacancies-block__vacancy-title" href="https://career.habr.com/vacancies/android_developer" target="_blank">Android разработчик </a><div class="tm-vacancies-block__vacancies-count">10
    вакансий</div></div><!--]--><!--]--></div><!--]--><footer class="tm-block__footer"><!--[--><a class="tm-block-extralink" href="https://career.habr.com/catalog">Все вакансии</a><!--]--></footer></section><section class="tm-block tm-block tm-block_spacing-around block" data-async-called="true" data-v-ebf6a21b=""><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Ближайшие события</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body"><!--[--><div class="swiper-container slider" data-v-ebf6a21b="" style="--swiper-space-between:22px;"><div class="swiper-wrapper"><!--[--><!--[--><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="588" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/588/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/f79/1fc/79d/f791fc79d0d9fdda84397ed0c0717764.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/f79/1fc/79d/f791fc79d0d9fdda84397ed0c0717764.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/f79/1fc/79d/f791fc79d0d9fdda84397ed0c0717764.png, https://habrastorage.org/getpro/habr/upload_files/f79/1fc/79d/f791fc79d0d9fdda84397ed0c0717764.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>17  февраля   – 24  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/588/"><span>Конкурс «Снежный код» от Хекслета. Три гранта на бесплатное 10-месячное обучение</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#588">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="596" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/596/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/b14/cd3/772/b14cd3772bc67698c8fbfd846e23824a.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/b14/cd3/772/b14cd3772bc67698c8fbfd846e23824a.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/b14/cd3/772/b14cd3772bc67698c8fbfd846e23824a.png, https://habrastorage.org/getpro/habr/upload_files/b14/cd3/772/b14cd3772bc67698c8fbfd846e23824a.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>20  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/596/"><span>Офлайн-конференция Хабр х K-team: как удерживать таланты в 2025 году</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#596">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="604" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/604/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/733/9ef/194/7339ef1945f3ee6906daf89db79829d4.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/733/9ef/194/7339ef1945f3ee6906daf89db79829d4.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/733/9ef/194/7339ef1945f3ee6906daf89db79829d4.png, https://habrastorage.org/getpro/habr/upload_files/733/9ef/194/7339ef1945f3ee6906daf89db79829d4.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>20  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/604/"><span>IX HappyWorkForum | Аутентичность и ментальное здоровье персонала</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><span class="tm-event-card__places-separator"> • </span></span><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#604">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="612" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/612/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/38f/10d/f4c/38f10df4c7f9d7c5d4610fe426af0ab4.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/38f/10d/f4c/38f10df4c7f9d7c5d4610fe426af0ab4.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/38f/10d/f4c/38f10df4c7f9d7c5d4610fe426af0ab4.png, https://habrastorage.org/getpro/habr/upload_files/38f/10d/f4c/38f10df4c7f9d7c5d4610fe426af0ab4.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>20  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/612/"><span>Вебинар «Мастерская бюджета: как управлять затратами на облачные ресурсы»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#612">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-admin"><span>Администрирование</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="616" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/616/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/523/7fb/13a/5237fb13ad7fb6fb483c49691aaec836.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/523/7fb/13a/5237fb13ad7fb6fb483c49691aaec836.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/523/7fb/13a/5237fb13ad7fb6fb483c49691aaec836.png, https://habrastorage.org/getpro/habr/upload_files/523/7fb/13a/5237fb13ad7fb6fb483c49691aaec836.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>21  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/616/"><span>Бизнес-конференция «Digital Brand Day 2025: Орбита 2025»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#616">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-marketing"><span>Маркетинг</span></div><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="606" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/606/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/400/0cb/fb8/4000cbfb86e5b97097f11d84cc50f089.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/400/0cb/fb8/4000cbfb86e5b97097f11d84cc50f089.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/400/0cb/fb8/4000cbfb86e5b97097f11d84cc50f089.png, https://habrastorage.org/getpro/habr/upload_files/400/0cb/fb8/4000cbfb86e5b97097f11d84cc50f089.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>24  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/606/"><span>Серия вебинаров «DevOps Middle: AvitoTech vs X5 Tech»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#606">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-admin"><span>Администрирование</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="608" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/608/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/8fd/e04/ddd/8fde04ddd9ba3f6bcd515aa6209f96b7.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/8fd/e04/ddd/8fde04ddd9ba3f6bcd515aa6209f96b7.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/8fd/e04/ddd/8fde04ddd9ba3f6bcd515aa6209f96b7.png, https://habrastorage.org/getpro/habr/upload_files/8fd/e04/ddd/8fde04ddd9ba3f6bcd515aa6209f96b7.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>27  марта  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/608/"><span>Вебинар «Контент-маркетинг здорового человека: как привлечь внимание аудитории»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#608">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-marketing"><span>Маркетинг</span></div><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="618" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/618/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/f76/0f9/a82/f760f9a827b851a5eeca4802c643a91d.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/f76/0f9/a82/f760f9a827b851a5eeca4802c643a91d.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/f76/0f9/a82/f760f9a827b851a5eeca4802c643a91d.png, https://habrastorage.org/getpro/habr/upload_files/f76/0f9/a82/f760f9a827b851a5eeca4802c643a91d.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>3  апреля  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/618/"><span>Реалити для разработчиков: узнайте, как строится новое публичное облако MWS</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#618">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="620" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/620/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/eba/c37/879/ebac378793b959ebce42f41713e7b67f.jpg" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/eba/c37/879/ebac378793b959ebce42f41713e7b67f.jpg" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/eba/c37/879/ebac378793b959ebce42f41713e7b67f.jpg, https://habrastorage.org/getpro/habr/upload_files/eba/c37/879/ebac378793b959ebce42f41713e7b67f.jpg 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>3  апреля  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/620/"><span>Открытая встреча «System Analysis Meetup SberHealth»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><span class="tm-event-card__places-separator"> • </span></span><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#620">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-analytics"><span>Аналитика</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="590" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/590/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/31b/e68/295/31be6829578e7934fbc944396eb330b1.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/31b/e68/295/31be6829578e7934fbc944396eb330b1.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/31b/e68/295/31be6829578e7934fbc944396eb330b1.png, https://habrastorage.org/getpro/habr/upload_files/31b/e68/295/31be6829578e7934fbc944396eb330b1.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>10  апреля  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/590/"><span>«GoCloud 2025» — масштабная IT-конференция про облака и AI</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><span class="tm-event-card__places-separator"> • </span></span><span class="tm-event-card__places-item"><span>Онлайн</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#590">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-admin"><span>Администрирование</span></div><div class="event-category__label event-category__label_type-management"><span>Менеджмент</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="516" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/516/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/0e9/3a8/3ec/0e93a83ecea09f806d1df907ddb036a4.jpg" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/0e9/3a8/3ec/0e93a83ecea09f806d1df907ddb036a4.jpg" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/0e9/3a8/3ec/0e93a83ecea09f806d1df907ddb036a4.jpg, https://habrastorage.org/getpro/habr/upload_files/0e9/3a8/3ec/0e93a83ecea09f806d1df907ddb036a4.jpg 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>25 – 26  апреля  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/516/"><span>IT-конференция Merge Tatarstan 2025</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Казань</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#516">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-marketing"><span>Маркетинг</span></div><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><div class="swiper-slide" data-v-ebf6a21b=""><!--[--><section class="tm-block tm-block tm-block_spacing-none" data-v-ebf6a21b="" id="610" tabindex="-1"><!-- --><!--[--><div class="tm-event-card tm-event-card_is-widget"><a class="" href="/ru/events/610/"><img alt="" class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/652/12d/998/65212d998fb4939d9787bd9c726d2acb.png" loading="eager" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/652/12d/998/65212d998fb4939d9787bd9c726d2acb.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/652/12d/998/65212d998fb4939d9787bd9c726d2acb.png, https://habrastorage.org/getpro/habr/upload_files/652/12d/998/65212d998fb4939d9787bd9c726d2acb.png 2x"/></a><!-- --><div class="tm-event-card__info"><div class="tm-event-card__date"><!-- --><div class="tm-event-card__day"><span>20 – 22  июня  </span></div></div><a class="tm-event-card__title-link" href="/ru/events/610/"><span>Летняя айти-тусовка Summer Merge</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Ульяновская область</span><!-- --></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a class="tm-event-card__link" href="/ru/events/#610">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!-- --></section><!--]--></div><!--]--><!--]--></div><!-- --><!--[--><button class="swiper-button-prev"><span class="tm-svg-icon__wrapper swiper-button-icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Влево</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#arrow-back"></use></svg></span></button><button class="swiper-button-next"><span class="tm-svg-icon__wrapper swiper-button-icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Вправо</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#arrow-back"></use></svg></span></button><!--]--></div><!--]--></div><!--]--><!-- --></section><!--]--><div class="banner-wrapper medium-rectangle tm-layout-sidebar__banner tm-layout-sidebar__banner_bottom" data-v-ad758baa="" style="--467224fc:250px;--58ff5eba:auto;"><!--[--><div class="placeholder-wrapper placeholder" data-v-ad758baa=""><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="adfox-banner-placeholder medium-rectangle" data-v-12f7bcca=""><div class="image loads" data-v-12f7bcca=""></div><div class="lines" data-v-12f7bcca=""><div class="line loads" data-v-12f7bcca=""></div><div class="line loads" data-v-12f7bcca=""></div><div class="line loads" data-v-12f7bcca=""></div></div></div><!-- --></div><div class="tm-adfox-banner" data-v-ad758baa="" id="adfox_164725691003361602"></div><!--]--></div></div></div><!--]--></div></div><!-- --><!--]--></div></div></main><!-- --></div><div class="tm-footer-menu"><div class="tm-page-width"><!--[--><div class="tm-footer-menu__container"><!--[--><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Ваш аккаунт</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/articles/838974/&amp;hl=ru" rel="nofollow" target="_self">Войти</a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/articles/838974/&amp;hl=ru" rel="nofollow" target="_self">Регистрация</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Разделы</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/articles/">Статьи</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/news/">Новости</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/hubs/">Хабы</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/companies/">Компании</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/users/">Авторы</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/sandbox/">Песочница</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Информация</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/help/">Устройство сайта</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/authors/codex/">Для авторов</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/companies/corpblogs/">Для компаний</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/docs/transparency/">Документы</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement/?hl=ru_RU" target="_blank">Соглашение</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/?hl=ru_RU" target="_blank">Конфиденциальность</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Услуги</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/corporate-blogs/" target="_blank">Корпоративный блог</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/advertising/" target="_blank">Медийная реклама</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/native-special/" target="_blank">Нативные проекты</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/education-programs/" target="_blank">Образовательные программы</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/hello-startup/" target="_blank">Стартапам</a></li><!--]--></ul></div></div><!--]--></div><!--]--></div></div><div class="tm-footer"><div class="tm-page-width"><!--[--><div class="tm-footer__container"><!-- --><div class="tm-footer__social"><!--[--><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Facebook</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Twitter</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>VK</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-vk"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Telegram</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Youtube</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://dzen.ru/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Яндекс Дзен</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-dzen"></use></svg></a><!--]--></div><!--teleport start--><!--teleport end--><button class="tm-footer__link"><!-- --> Настройка языка</button><a class="tm-footer__link" href="/ru/feedback/">Техническая поддержка</a><div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2025, </span><span class="tm-copyright__name"><a class="tm-copyright__link" href="https://company.habr.com/" rel="noopener" target="_blank">Habr</a></span></span></div></div><!--]--></div></div><!-- --><!--]--></div><!-- --></div></div>
<div id="overlays"><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--></div>
</body>
</html>
