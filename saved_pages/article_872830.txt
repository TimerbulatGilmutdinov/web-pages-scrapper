<!DOCTYPE html>

<html lang="ru">
<head>
<title>Jakarta Data и Persistence: Инструменты, которые меняют подход к работе с данными / Хабр</title>
</head>
<body>
<div id="mount"><div data-async-called="true" id="app"><div class="tm-layout__wrapper"><!--[--><!-- --><div></div><!-- --><header class="tm-header" data-test-id="header"><div class="tm-page-width"><!--[--><div class="tm-header__container"><!-- --><span class="tm-header__logo-wrap"><a class="tm-header__logo tm-header__logo_hl-ru tm-header__logo" href="/ru/"><svg class="tm-svg-img tm-header__icon" height="16" width="16"><title>Хабр</title><use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a><span class="tm-header__beta-sign" style="display:none;">β</span></span><!--[--><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><!--[--><button class="tm-header__dropdown-toggle"><svg class="tm-svg-img tm-header__icon tm-header__icon_dropdown" height="16" width="16"><title>Открыть список</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#arrow-down"></use></svg></button><!--]--></div><!-- --></div><a class="tm-header__become-author-btn" href="/ru/sandbox/start/">Как стать автором</a><div class="tm-feature tm-feature tm-feature_variant-inline tm-header__feature"><!-- --></div><!-- --><!--]--><!-- --></div><!--]--></div></header><div class="tm-layout"><div class="tm-page-progress-bar"></div><div class="tm-base-layout__header_is-sticky tm-base-layout__header" data-menu-sticky="true"><div class="tm-page-width"><!--[--><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/feed/">Моя лента</a><!--]--><!--[--><a class="tm-main-menu__item" href="/ru/articles/">Все потоки</a><!--]--><!--[--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/develop/">Разработка</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/admin/">Администрирование</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/design/">Дизайн</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/management/">Менеджмент</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/marketing/">Маркетинг</a><!--]--><!--[--><a class="tm-main-menu__item" data-test-id="main-menu-item" href="/ru/flows/popsci/">Научпоп</a><!--]--><!--]--></nav></div></div><div class="tm-header-user-menu tm-base-layout__user-menu"><a class="tm-header-user-menu__item tm-header-user-menu__search" data-test-id="search-button" href="/ru/search/"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark" height="24" width="24"><title>Поиск</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#search"></use></svg></a><!-- --><!-- --><div class="tm-header-user-menu__item tm-header-user-menu__write"><div><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_write tm-header-user-menu__icon_dark" height="24" width="24"><title>Написать публикацию</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#write"></use></svg></div><!-- --></div><!--[--><div class="tm-header-user-menu__item"><button class="tm-header-user-menu__toggle" data-test-id="user-menu-settings"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_dark" height="24" width="24"><title>Настройки</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#page-settings"></use></svg></button></div><a class="tm-header-user-menu__item" href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/companies/spring_aio/articles/872830/&amp;hl=ru" rel="nofollow"><!--[--><button class="btn btn_solid btn_small tm-header-user-menu__login" type="button"><!--[-->Войти<!--]--></button><!--]--></a><!--]--><!-- --><!--teleport start--><!--teleport end--><!-- --></div></div><!--]--></div></div><!-- --><div class="tm-page-width"><!--[--><!--]--></div><main class="tm-layout__container"><div class="tm-page" companyname="spring_aio" data-async-called="true" hl="ru" style="--0c809c5a:16px;--a086013e:100%;--7c457026:0;"><div class="tm-page-width"><!--[--><div class="tm-page__header"><!--[--><!--]--></div><div class="tm-page__wrapper"><div class="tm-page__main_has-sidebar tm-page__main"><div class="pull-down"><!-- --><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg class="tm-svg-img pull-down__icon pull-down__arrow" height="24" width="24"><title>Обновить</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#pull-arrow"></use></svg></div></div><!--[--><!--[--><div class="tm-article-presenter"><!--[--><!--[--><!-- --><div class="tm-company-profile-card tm-company-article__profile-card"><div class="tm-company-card tm-company-profile-card__info"><div class="tm-company-card__header"><a class="tm-company-card__avatar" href="/ru/companies/spring_aio/profile/"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" height="48" src="//habrastorage.org/getpro/habr/company/8f1/91a/458/8f191a4584b8fab12d15af23e447a1d5.png" width="48"/></div></a><!--[--><!-- --><div class="tm-counter-container tm-company-card__rating"><div class="tm-counter-container__header"><!--[--><!--[--><!--]--><div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating"><!-- --><div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score"><!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">77.73</span></span><!--]--></div><!-- --></div><!--]--></div><div class="tm-counter-container__footer"><!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]--></div></div><!-- --><!--]--></div><div class="tm-company-card__info"><a class="tm-company-card__name" href="/ru/companies/spring_aio/profile/"><span>Spring АйО</span></a><!-- --></div></div><div class="tm-company-profile-card__buttons"><div class="tm-button-follow tm-company-profile-card__button tm-company-profile-card__button_follow"><!-- --><button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button></div><!-- --><!-- --><!-- --></div></div><!-- --><!--]--><!--]--><div class="tm-article-presenter__body" data-test-id="article-body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><!--[--><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><!--[--><div class="tm-article-presenter__header"><!--[--><!--]--><div class="tm-article-snippet tm-article-snippet tm-article-presenter__snippet"><!--[--><!--]--><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a class="tm-user-info__userpic" data-test-id="user-info-pic" href="/ru/users/spring_aio/" title="spring_aio"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" height="24" src="//habrastorage.org/r/w48/getpro/habr/avatars/8e0/5e8/a1c/8e05e8a1c5fd4560f661efb2cb00e77e.png" width="24"/></div></a><span class="tm-user-info__user tm-user-info__user_appearance-default" data-test-id="user-info-description"><a class="tm-user-info__username" href="/ru/users/spring_aio/">spring_aio <!-- --></a><!--[--><span class="tm-article-datetime-published"><time datetime="2025-01-13T13:18:38.000Z" title="2025-01-13, 16:18">13  янв   в 16:18</time></span><!--]--></span></span></div><!-- --></div><h1 class="tm-title tm-title_h1" data-test-id="articleTitle" lang="ru"><span>Jakarta Data и Persistence: Инструменты, которые меняют подход к работе с данными</span></h1><div class="tm-article-snippet__stats" data-test-id="articleStats"><div class="tm-article-complexity tm-article-complexity_complexity-low"><span class="tm-svg-icon__wrapper tm-article-complexity__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Уровень сложности</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#complexity-low"></use></svg></span><span class="tm-article-complexity__label">Простой</span></div><div class="tm-article-reading-time"><span class="tm-svg-icon__wrapper tm-article-reading-time__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Время на прочтение</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#clock"></use></svg></span><span class="tm-article-reading-time__label">26 мин</span></div><span class="tm-icon-counter tm-data-icons__item"><svg class="tm-svg-img tm-icon-counter__icon" height="24" width="24"><title>Количество просмотров</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-views"></use></svg><span class="tm-icon-counter__value" title="6705">6.7K</span></span></div><div class="tm-publication-hubs__container" data-test-id="articleHubsList"><div class="tm-publication-hubs"><!--[--><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/companies/spring_aio/articles/"><!--[--><span>Блог компании Spring АйО</span><!-- --><!--]--></a></span><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/hubs/programming/"><!--[--><span>Программирование</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/hubs/java/"><!--[--><span>Java</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a class="tm-publication-hub__link" href="/ru/hubs/kotlin/"><!--[--><span>Kotlin</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><!--]--></div></div><div class="tm-article-labels" data-test-id="articleLabels"><div class="tm-article-labels__container"><div class="tm-publication-label tm-publication-label_variant-review"><span>Обзор</span></div><!--[--><div class="tm-publication-label tm-publication-label_variant-translation"><span>Перевод</span></div><!--]--></div></div><!-- --><!-- --></div></div><!--[--><div class="tm-article-presenter__origin"><a class="tm-article-presenter__origin-link" href="https://www.youtube.com/watch?v=X9GplCb5SWY" target="_blank">Автор оригинала: <span>Gavin King</span></a></div><div class="tm-article-body" data-gallery-root="" lang="ru"><div><!--[--><!--]--></div><div id="post-content-body"><div><div class="article-formatted-body article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><p>Команда <a href="https://t.me/+QmrKn0wA8CdkNjAy">Spring АйО</a> перевела и адаптировала доклад "Jakarta Data and Jakarta Persistence by Gavin King" Гевина Кинга с последнего Devoxx.</p><p>В своем выступлении Гевин Кинг рассказал о преимуществах и нововведениях Jakarta Data и Jakarta Persistence.</p><h2>Введение</h2><p>Когда команда Hibernate работала над тем, чтобы модернизировать и перепроектировать свой продукт и создать Hibernate 6, никто не мог быть уверен, что данная инициатива встретит большой интерес в рядах разработчиков. Но оказалось, что люди заинтересованы в этой теме. А годом позже стало ясно, что на самом деле Hibernate 6 оказался исключительно успешным, и это отразилось во всех метриках. На фоне таких открытий команда разработчиков пришла к выводу что имеет смысл отойти назад и вдохнуть новую жизнь в спецификацию Jakarta, прежде всего в том, что касалось Jakarta Persistence.</p><p>Еще более интересная история произошла с Jakarta Data. Изначально Jakarta Data была спецификацией, которая интересовала немногих. Даже разработчики надеялись, что она просто исчезнет, “рассосется” сама собой. Однако она осталась, и это оказалось положительным моментом. В какой-то момент стало ясно, что Jakarta Data не уйдет в никуда, и возникла необходимость взаимодействовать с ней. К счастью, к этому времени появилась ясность в том, в каком направлении стоит продолжать ее развитие. Параллельно этой работе менялись и взгляды на репозитории и на практическую пользу их применения, которая стала очевидна не сразу. Появились новые практические идеи о том, как улучшить существующую концепцию репозиториев, и эти идеи стали катализатором изменений, которые скоро произойдут в Jakarta Data или уже произошли.</p><p>Примерно пару лет назад популярная точка зрения на репозитории выглядела примерно так: “Зачем вообще нужны репозитории? JPA EntityManager уже является generic репозиторием, определенным согласно стандарту с многочисленными реализациями, созданным во взаимодействии людьми, которые разрабатывают ведущие решения на Java ORM.”  Не было понятно, какую именно выгоду может получить разработчик, спрятав JPA за non-generic, нестандартным проприетарным фреймворком, который не давал дополнительной типобезопасности, не давал никакой дополнительной инкрементальной способности и лишь усложнял доступ к некоторым возможностям JPA. </p><p>Главный аргумент здесь в том, что если бы было можно сделать JPA проще, люди бы это сделали. Попытка упростить JPA, впрочем, может нанести вред, если подходить к ней необдуманно, так как те операции, которые делают JPA сложным, реальны и полезны. И с этим сложно поспорить. Распространенной жалобой от разработчиков, использующих ORM, является жалоба на то, что использование библиотеки Persistence, особенно вместе с ORM решением и в stateful persistence контексте, уводит разработчика дальше от прямого контроля над его SQL и над взаимодействием с базой данных.    </p><p>Увы, Repository Framework делают эту ситуацию еще хуже. Они не могут не сделать эту ситуацию еще хуже. Они — еще один слой абстракций.</p><p>Это утверждение особенно верно, если фреймворк репозиториев пытается стать абстракцией поверх двух очень разных вещей. Одна из этих вещей — это CRUD-ориентированный API, который дает полный контроль над над моментом времени взаимодействия с базой данных, где нет persistence контекста, нет кеширования данных сущности. Вторая вещь — это <code>stateful persistent</code> контекст в стиле JPA. Это абсолютно разные, фундаментально разные модели программирования. Невозможно рационально и эффективно создать абстракцию поверх этих двух моделей, а если вы попытаетесь, вы только создадите все разновидности путаницы в голове пользователя. </p><p>И это происходит каждый день, я вижу как люди верят, что используют JPA, но на самом деле они используют другую абстракцию поверх JPA, которая имеет свое собственное представление о том, какая программная модель здесь присутствует, и таким образом эти люди остаются в подвешенном состоянии.</p><p>Еще один негативный момент состоит в том, что в популярных фреймворках, которые реализуют паттерн репозитория, каждая сущность имеет свой собственный репозиторий, так этот фреймворк устроен. Как правило вы расширяете некий интерфейс, который параметризуется типом сущности. Проблема состоит в том, что многие интересные операции в реляционных базах данных работают сразу со многими сущностями.</p><p>Вот наиболее тривиальный пример, который приходит в голову: <code>“автор → книга”</code> — это ассоциация многие ко многим. Или, например, <code>“студент → профессор → класс”</code> — это тоже ассоциации многие ко многим. Реляционные данные доверху полны такими ассоциациями. </p><p>Запросы, которые работают с реляционными данными, не появляются через какой-то <em>domain driven design</em>, от верхней сущности и вниз по дереву. Реляционные данные работают не так. </p><p>Поэтому, работая с репозиториями, мы не должны думать об отдельных  сущностях и операциях над отдельными сущностями. Это не имеет смысла для реляционных данных. У нас должна быть возможность производить операции над репозиторием, который работает над несколькими сущностями. </p><p>Одна из главных вещей, которые предлагают нам репозитории — это возможность описать запросы внутри приложения, и ценят их именно за это.</p><p>И еще один момент. Во фреймворках репозиториев, которые сейчас существуют в мире, легко прослеживается тот факт, что они вдохновлялись Ruby on Rails, и в стремлении сделать работу с запросами наиболее простой, написать максимально тривиальный запрос, как, например, найти книгу по ее заглавию, была применена идея автоматического угадывания запроса по имени метода репозитория. К чему это в конце концов приводит, это создание языка запросов, включаемых в имя метода. Что означает “никаких пробелов, никаких знаков препинания, очень ограниченные возможности”.</p><p>Посмотрим на реальные примеры. Здесь мы видим имена методов вроде <code>findFirstByOrderByLastNameAsc()</code> или <code>findTopByOrderByAgeDesc()</code>. Это ужасно. </p><p>Пришла пора перестать так делать. Метод должен не только выполнять свою функцию, но и нести понятную семантику. Его имя должно отражать цель и роль в коде, чтобы разработчик, пришедший в проект позже, мог легко понять его назначение и продолжить работу.</p><p>Если у разработчика нет контроля над тем, какое имя дать методу, он лишается  основной части коммуникации с тем, кто вызывает этот API. Конечно, можно вписать предназначение метода в комментарии. Но это движение назад.</p><h3>Так почему репозитории нравятся людям?    </h3><p>В этом разделе мы займемся спекуляциями на тему того, почему люди все же используют репозитории, ведь если используют, значит, что-то полезное в них разработчик находят.</p><p>Возможно, эти спекуляции будут далеки от истины в некоторых случаях. Прежде всего, если базироваться на том, что говорилось десять, пятнадцать лет назад, когда эти репозитории назывались DAO, основным оправданием для их применения было то, что наличие DAO объектов было способом отделения своего кода от внутренней технологии работы с данными, способом упрощения перехода от использования, к примеру, JPA, к использованию кода JDBC напрямую или, возможно, перехода от PostgreSQL на Mongo.</p><p>Однако, такое мнение больше не считается общепринятым. Давайте скажем так, что для этой цели их польза в лучшем случае микроскопическая. </p><p>Репозитории традиционно реализуются таким образом, чтобы не давать дополнительной типобезопасности. Причина их популярности состоит, скроее, в том, что это удобное место, куда можно сложить все запросы к данным. Размещение JPA-кода, выполняющего запросы create и устанавливающего параметры, прямо в бизнес-логике, связанной с работой persistence, часто воспринимается как неудачная и неопрятная практика.</p><p>Соответственно, репозитории — это приятный способ организации кода.</p><p><em>Организация кода — это важно, верно?</em></p><p>Однако, в прежние времена реализация слоя репозитория была настолько тривиальной и настолько прозрачной, что она не стояла на пути отладки или понимания кода. Не существовало дополнительного слоя, отделяющего разработчика  от взаимодействия с JPA и базой данных. А значит, не было и никакой запутанности между репозиториями в стиле CRUD и <em>stateful persistence</em> контекстом. </p><p>И если бы мы нашли более элегантный способ, чем вставка в имя метода, выражения тривиальных запросов, если бы архитектура не ограничивала разработчика в способах организации операций работы с данными и если бы репозитории реально расширили типобезопасность, тогда критикам репозиториев пришлось бы признать поражение и согласиться с тем, что репозитории не так и плохи, что бы там ни говорили. </p><h3>Быстрое введение в репозитории в Jakarta Data</h3><p>Технология, которая делает это возможным в данном случае — это <strong><em>annotation processing</em></strong></p><details class="spoiler"><summary>Комментарий от команды Spring АйО</summary><div class="spoiler__content"><p><em>Речь про APT - Java Annotation Processing Tool</em></p></div></details><p>Да, <em>annotation processing</em>, в каком-то смысле, имеет плохую репутацию в некоторых кругах. Дело в том, что annotation processing на макроуровне является мощной языковой функцией. И, как любая мощная языковая функция, она может использоваться, чтобы делать что-то по-настоящему прекрасное, либо она может использоваться, чтобы делать что-то плохое и вредное. Как в случае с острым ножом.</p><p>У многих людей есть опыт в <em>annotation processing</em>, который выходит за грань того, что вроде как разрешается делать официально. Есть один конкретный обработчик аннотаций, который очень хорошо всем вам известен. Он очень хорошо известен, и он точно делает вещи, которые делать не разрешается. </p><details class="spoiler"><summary>Комментарий от команды Spring АйО</summary><div class="spoiler__content"><p><em>В данном случае речь идет про то, как Lombok использует APT</em></p></div></details><p>Что же касается <strong>Jakarta Data</strong>, очень важно упомянуть, что этот продукт был построен так, чтобы его можно было реализовать через обработчик аннотаций, которому не надо нарушать правила по поводу того, что должны делать обработчики аннотаций. Так что, если у вас был какой-то плохой опыт с какими-то другими обработчиками аннотаций, это не обязательно означает, что у вас был плохой опыт, связанный с Jakarta Data, и нет оснований полагать, что он когда-либо появится.</p><p>Итак, давайте сделаем быстрое введение в репозитории в Jakarta Data. Поговорим об использовании Jakarta Data для получения доступа к реляционным данным, и конкретно об использовании Hibernate.  </p><p>На самом деле, Jakarta Data — это гораздо больше. Jakarta Data — это <em>generic</em> спецификация, которая может использоваться для реализации фреймворков репозиториев в том числе для нереляционных данных, если у вас есть в этом необходимость, и вам следует взглянуть на Eclipse JNoSQL, который нацелен именно на такое применение спецификации. На данный момент имеются как минимум три реализации в Jakarta Data: одна от IBM, одна от Eclipse и одна от Hibernate.</p><pre><code class="java">@Repository
Interface Library {
}</code></pre><p>Итак, как выглядит интерфейс репозитория? Только этот код. Это интерфейс с аннотацией <code>@Repository</code>, он не обязан ничего расширять. Хотя, если есть такая необходимость, он может это делать.</p><p>И, чтобы получить к нему доступ, вы можете инжектировать его, например, через CDI:</p><pre><code class="java">@Inject 
Library library;</code></pre><p>Благодаря <code>@Inject</code> инжектируем через CDI (или любым другим способом)</p><p>Вы также можете захотеть инстанцировать репозиторий, используя <code>new</code>, и сделать это можно следующим способом:</p><pre><code class="java">var library = new Library_();</code></pre><p>Но этот код специфичен для Hibernate, универсального способа сделать что-то подобное пока нет.</p><p>Первый вид распространенных операций с данными — это операции чтения. Мы хотим сказать нашей программе: <em>“Найди мне такую-то книгу по таким-то параметрам”.</em> Что надо для этого сделать? Нам придется написать метод, и он должен возвращать объект типа Book, именно такой тип в данном случае тип возвращает операция репозитория. И этот метод должен быть помечен аннотацией <code>@Find</code>.</p><pre><code class="java">@Repository
Interface Library {
	@Find Book book(String isbn);
}</code></pre><p>Что здесь есть интересного и нового — это то, что параметры в этом методе проверяются на соответствие полям типа Book. Поэтому они должны иметь тот же тип и то же имя, что и поле типа Book, и это может быть провалидировано во время компиляции посредством <em>annotation processing</em>.</p><p>Поэтому если вы неправильно напишите <code>isbn</code> или почему-то подумаете, что это тип <code>Long</code>, а не <code>String</code>, или ошибетесь в чем-то еще, вы получите ошибку немедленно во время компиляции, а не во время выполнения.</p><p>И что еще важно, имя этого метода не имеет особого значения, вы можете называть эти операции, как считаете нужным:</p><pre><code class="java">@Repository 
interface Library {
	@Find Book book(String isbn);
	@Find Author authorForSsn(@Nonnull String ssn); //Имя метода никогда не имеет значения
}</code></pre><p>Как вы можете видеть, один метод работает с <code>Book</code>, а другой с <code>Author</code>, а значит есть и свобода выбора: </p><ul><li><p>выбрать по одному репозиторию на каждую сущность</p></li><li><p> создать один репозиторий на все сущности, если у вас маленькая программа, </p></li><li><p>или, что особенно интересно, репозиторий, относящийся к группе взаимосвязанных сущностей</p></li></ul><pre><code class="java">@Repository
interface Library {
	@Find Book book(String isbn);
	@Find Author authorForSsn(@Nonnull String ssn);
}</code></pre><p>Теперь поговорим об операции <code>update()</code>.</p><pre><code class="java">@Repository
interface Library {
	@Find Book book(String isbn);
	@Insert void insert(Book book);
	@Update void update(Book book); //update является отдельной операцией
}</code></pre><p>Опять же, здесь мы аннотируем метод, он принимает объект типа <code>Book</code>, и этого достаточно для репозитория. Обработчик аннотаций знает, что он должен делать. </p><p>Заметьте, что <code>update</code> — это отдельная операция, а репозитории Jakarta Data всегда <em>stateless</em>. В них нет <em>persistence</em> контекста. Никогда. Поэтому в Hibernate в описываемой реализации репозитория поддерживаются <code>StatelessSession</code>. Если вы хотите забрать контроль над этой <code>StatelessSession</code> и что-то с ней сделать, Jakarta Data также предоставляет способ это сделать. </p><pre><code class="java">@Repository
interface Library {
    StatelessSession session(); //получение внутренней StatelessSession
  
    default void upsert(Book book) {
        session().upsert(book); //операция над репозиторием, реализованная пользователем
    }
}</code></pre><p>Вы просто декларируете метод, который возвращает <code>StatelessSession</code>, и можете использовать его в методе по умолчанию, который вы можете назвать <code>upsert()</code>.</p><h2>Язык запросов Jakarta Data</h2><p>Теперь поговорим о запросах. То, что мы видели выше — это методы запросов, базирующиеся на параметрах.</p><p>Существуют методы запросов, в которых параметры метода определяют ограничения на результаты, и это тип возвращаемого методом результата, что определяет сущность, к которой отправляется запрос. Есть также и другие возможности, о которых можно почитать в спецификации или в документации по Hibernate. Методы запросов, базирующиеся на параметрах, мапятся на JPA Criteria API. Такая практика является полностью типобезопасной.</p><pre><code class="java">@Repository
interface Library {
  @Find Optional&lt;Book&gt; book(String isbn);
  @Query("where name.first like :firstName" +
        " and name.last like :lastName")

  Author author(String firstName, String lastName);
  
  @Query("where title like ?1 and publisher.name = ?2" +
        " order by title")

  List&lt;Book&gt; booksByTitle(String title, String publisher);
  
}</code></pre><p><strong>JDQL (Jakarta Data Query Language)</strong> — это гораздо более мощный и гибкий язык. С его помощью вы можете написать запрос прямо в аннотации, но, спросите вы, где же в этом типобезопасность? Что, если имя этого параметра не соответствует типу или параметр не соответствует параметру метода? Что, если Book не имеет атрибута под названием <code>title</code>? Ответ прост: <strong>вы получите ошибку во время компиляции.</strong> </p><p>Посмотрим на реализацию. </p><pre><code class="java">@Repository
interface Library {

    @Find
    Optional&lt;Book&gt; book(String isbn);

    @Query("where name.first like :firstName" +
           " and name.last like :lastName") //ошибка компиляции

    Author author(String firstName, String lastName);

    @Query("where title like ?1 and publisher.name = ?2" +
           "order by title") ////ошибка компиляции

    List&lt;Book&gt; booksByTitle(String title, String publisher);

}</code></pre><p>Под всем этим скрыты серьезные механизмы, в написание которых вложено много труда команды разработчиков пусть даже на первый взгляд построить эти механизмы не так и трудно, поскольку у IntelliJ они тоже есть. Соответственно, IntelliJ тоже может делать подобные валидации, и таким образом вы получаете два слоя валидации, которые отрабатывают каждый раз, когда вы компилируете ваш код. </p><p>JDQL является подмножеством JPQL, ограниченным под возможность реализации на широком диапазоне реляционных и нереляционных хранилищ данных. Это подмножество может быть реализовано на весьма простых хранилищах данных. </p><p><strong>Что, если запрос более динамичный?</strong></p><pre><code class="java">@Repository
interface Library {

  @Find Book book(String isbn);
  
  @Query("select isbn from Book"
        " where lower(title) like 21"
        " order by isbn")

  List&lt;String&gt; booksByTitle(String title);

}</code></pre><p>Помимо вышесказанного, такой запрос является более динамичным. Мы видим, что мы можем делать проекции и ограничения, сортировку и всякое тому подобное в методе запроса, но что если все это поменяется в зависимости от условий рантайма?</p><pre><code class="java">@Repository
interface Library {

    @Find
    Book book(String isbn);

    @Query("select isbn from Book" +
           " where lower(title) like ?1")

    List&lt;String&gt; booksByTitle(String title, 
                              PageRequest page, //пагинация
                              Sort sort); //динамическая сортировка
}</code></pre><p>У Jakarta Data есть решение и для такого случая! Можно передать объект типа <code>PageRequest</code>, который задает пагинацию, и также можно передать объект типа <code>Sort</code>, который задает динамическую сортировку, и для этих сценариев в Jakarta Data также присутствует типобезопасность. </p><pre><code class="java">var isbns = library
        .booksByTitle("%hibernate%", 
                PageRequest.ofPage(1).size(20),
                _Book.isbn.asc()); //isbn - ссылка на статическую метамодель</code></pre><p>Типобезопасность для этого сценария реализуется через статическую метамодель Jakarta. Вы уже, возможно, знакомы со статической метамоделью Jakarta Persistence, которая первоначально создавалась для использования с запросами Criteria API, и теперь в Jakarta Data есть нечто похожее. К сожалению, приходится использовать синтаксис, основанный на символе подчеркивания, то есть, если использовать JPA и Jakarta Data вместе, появятся классы <code>Book_</code> и <code>_Book</code>, но зато здесь присутствует возможность задать порядок сортировки этого запроса, используя <code>_Book.isbn.asc()</code>, и она тоже полностью типобезопасна. </p><h2>Могут ли Java Record’ы быть типами сущностей?</h2><p>Отвлечемся ненадолго и поговорим о некотором моменте, который не относится напрямую к теме статьи, но этот вопрос все время поднимается к тому же является весьма интересным. И состоит он в следующем: </p><p><em>Могут ли сущности быть Java Record’ами?</em> </p><p>Мы все любим <em>Java records</em>. <em>Immutable</em> типы прекрасны. Первое, что надлежит упомянуть, это то, что <em>immutable</em> типы прекрасно подходят для представления деревьев. Вы можете работать со связными списками, вы можете создать дерево с многочисленными ветвями, у вас могут быть связные списки. Но у вас не может быть циркулярных референсов. С <em>immutable</em> объектами вы просто не сможете создать <em>Immutable</em> объект имея циркулярный референс.</p><p>Итак, какие данные дают хорошие деревья? Самый очевидный пример — <em>документоориентированные БД</em>. Они являются деревьями от природы. Но для реляционных это утверждение неверно. Как уже говорилось ранее, реляционные данные полны отношений <em>“многие ко многим”</em>, и это именно то, что делает реляционные данные настолько более мощными, чем иерархические модели. Эти ассоциации многие ко многим просты в представлении, естественны и являются частью модели. </p><p>Итак, в то время как некоторые реализации Jakarta Data будут поддерживать <em>records</em> как типы сущностей, это не является требованием в соответствии со спецификацией, а реализация, основанная на Hibernate ORM, не будет их поддерживать.</p><p>С другой стороны, <em>records</em> могут использоваться для <code>@Embeddable</code> типов, как в JPA, и по этой причине они нужны в JPA 3.2 и, отсюда мы совершенно естественно переходим к разговору Jakarta Persistence. </p><h3>Как сделать Jakarta Persistence более простым в тестировании</h3><p>JPA 3.2 сильно отличается от Jakarta Data. Команда разработчиков спецификации перенесла сюда многое из Hibernate и EclipseLink, то, что доказало свою полезность за годы и легко подвергалось стандартизации  что можно легко стандартизировать в спецификацию. Одновременно были устранены некоторые шероховатости этих APIs, в основном опять-таки с целью улучшения типобезопасности. В рамках этой статьи мы поговорим только о двух вещах.</p><pre><code class="java">//persistence.xml файл больше не нужен
//теперь можно создать Persistence Unit динамически в рантайме

var factory = new PersistenceConfiguration("Bookshop")
    .nonJtaDataSource("java:global/jdbc/BookshopData")
    .managedClass(Book.class)
    .managedClass(Author.class)
    .property(PersistenceConfiguration.LOCK_TIMEOUT, 5000)
    .createEntityManagerFactory();</code></pre><p>Одна из этих вещей — упрощенное тестирование. В первую очередь, есть способ полностью сконфигурировать стартовую процедуру, <em>persistent unit, entity manager factory,</em> полностью сделать это через код Java. Как мы жили десятилетиями, не имея этих возможностей в спецификации? Очевидно же, что их надо туда добавить, чтобы вам больше не требовался persistence XML, чтобы запустить Jakarta Persistence, чтобы запустить любую managerFactory в ваших сырых тестах. </p><p>Этот класс является расширяемым, так что реализации типа Hibernate или EclipseLink могут иметь свои собственные Hibernate Persistence конфигурации со своими специфическими конфигурационными опциями.</p><p>Во-вторых, раньше существовали разные моды работы со схемой БД (создание, валидация и т.д.), контролируемая настройками свойств. Теперь же появился объект, называемый <code>SchemaManager</code>, который можно использовать для динамической манипуляции схемы данных</p><details class="spoiler"><summary>Комментарий от команды Spring АйО</summary><div class="spoiler__content"><p><em>Интерфейс, о котором говорит Гевин: </em><a href="https://jakarta.ee/specifications/persistence/3.2/apidocs/jakarta.persistence/jakarta/persistence/schemamanager"><em><u>https://jakarta.ee/specifications/persistence/3.2/apidocs/jakarta.persistence/jakarta/persistence/schemamanager</u></em></a></p></div></details><pre><code class="java">factory.getSchemaManager().create(true) //экспортирует схему
factory.getSchemaManager().drop(true) //выполняет зачистку</code></pre><p>Это суперполезно в тестах. Вы также можете провалидировать схему, а еще, что даже еще более полезно, вы можете очистить с помощью операции <code>truncate()</code> все таблицы в вашей базе данных после прогона теста. </p><pre><code class="java">factory.getSchemaManager().validate() //валидирует схему
factory.getSchemaManager().truncate() //выполняет зачистку только данных</code></pre><p>Это намного быстрее на некоторых базах данных, чем удаление всех таблиц. Это суперполезно для тестирования. </p><p>И наконец, есть способ прогнать некоторые операции на транзакциях с <code>entityManager</code>, без необходимости писать многочисленные <code>try … catch</code> блоки, без необходимости беспокоиться о том, чтобы запускать это внутри Java EE контейнера. </p><pre><code class="java">//callInTransaction автоматически обрабатывает транзакции и исключения
var book = factory.callInTransaction(em -&gt; em.find(Book.class, isbn)); </code></pre><p>Так мы автоматически управляем транзакциями и исключениями, получая максимально простое решение.</p><h3>Улучшение типобезопасности в Jakarta Persistence</h3><p>Во всей работе команды Jakarta Data типобезопасность была главной и определяющей целью. И одной из первых задач в рамках поставленной цели  было найти способ предоставить <em>type safe</em> ссылки на атрибуты, на поля нашей сущности внутри аннотаций другой сущности. Наконец-то мы можем воспользоваться всеми преимуществами статической метамодели.</p><pre><code class="java">@Entity
class Book {

    @Id String isbn;

    @ManyToMany(mappedBy = Author_.BOOK) //типобезопасная ссылка на поле 
    List&lt;Author&gt; authors;

    String text;

}</code></pre><p>Это особенно полезно для маппинга, когда используется ненавистное <code>mappedBy</code> для членов коллекции аннотаций типа <em>многие ко многим</em>.</p><p>Теперь уже Jakarta Persistence, а не Jakarta Data, статическая метамодель, имеет эти атрибуты, такие как <code>BOOK</code> (с большой буквы), сгенерированные в ней с именами полей сущности. Это сдвиг в позитивном направлении.</p><p>А как насчет именованных запросов (<code>NamedQuery</code>) и именованных графов сущностей (<code>NamedEntityGraph</code>)? </p><pre><code class="java">@NamedQuery(name = "TextForIsbn", //имя типа, объявленное при помощи строки
    query = "select text from Book where isbn = ?1"
)
@NamedEntityGraph(
    name = "BookWithAuthors",
    attributeNodes = @NamedAttributeNode(value = "authors"))
@Entity
class Book {

    @Id String isbn;
  
    @ManyToMany(mappedBy = Author_.BOOK)
    List&lt;Author&gt; authors;

    String text;
}</code></pre><p>Начать следует с обозначения имен типов с помощью строк. Как упростить их использование? Хуже всего то, что у них не только строковые имена типов, но и, как вы знаете, до версии 3.2 JPA не содержал способа задать возвращаемый тип именованного запроса, и приходилось делать <em>type cast</em>. </p><p>Ответом здесь является то, что мы генерируем ссылку на типовой запрос и вставляем ее в статическую метамодель. </p><pre><code class="java">//_TextForIsbn_ - типобезопасная ссылка на именованный запрос
//String - возвращаемый тип запроса выводится автоматически
String text = em.createNamedQuery(Book_._TextForIsbn_)
                .setParameter(1, "9781932394153")
                .getSingleResult();</code></pre><p>И таким образом мы просто можем сделать любой запрос, созданный менеджером, передать ссылку на типовой запрос, установить параметры, получить результат и этот результат будет правильного типа, а именно строкой, строка здесь, поскольку ранее приведенный запрос вернул строку. </p><p>Хорошо, хорошо, на самом деле мы нигде не говорили в явном виде, что запрос возвращает строку. Это лишь снова последствие факта, что Hibernate очень хорошо анализирует причинно-следственные связи во время компиляции. </p><pre><code class="java">//_BookWithAuthors - типобезопасная ссылка на именованный граф
//Тип сущности Book выводится автоматически
Book book = em.find(Book_._BookWithAuthors, “9781932394153”);</code></pre><p>Подобным образом, у нас может существовать типобезопасная ссылка на именованный граф. </p><pre><code class="java">var bookWithAuthors = em.createEntityGraph(Book.class);
bookWithAuthors.addSubgraph(Book_.authors);
//bookWithAuthors - обычно лучше, чем именованный граф сущности
Book book = em.find(bookWithAuthors, “9781932394153”);</code></pre><p>До появления JPA 3.2 API для работы с графами тоже содержал много проблем с типобезопасностью, но они были успешно исправлены, и вы снова можете писать типобезопасный код и использованием графов сущностей.</p><p>Операции <code>find(), refresh() и lock()</code> также были замещены объектами со свойствами, которые используются для кастомизации поведения <code>EntityManager</code>.</p><pre><code class="java">Book book = 
    em.find(Book.class, "9781932394153", 
            LockModeType.PESSIMISTIC_READ, 
            Timeout.seconds(2), 
            CacheStoreMode.REFRESH); //типобезопасные опции</code></pre><p>Сейчас некоторые из этих операций являются типобезопасными опциями. Они также расширяемы, так что Hibernate или EclipseLink могут добавить свои собственные типобезопасные опции, и это делает более чистым контроль над поведением этих пераций.  </p><h3>Будущее: что дальше?</h3><p>Итак, что же дальше? Две вещи. Конечно, вы хотите упростить процедуру получения большей выгоды от JPA при использовании Jakarta Data, что означает, что необходимо найти больше способов для выставления наружу большего количества JPA через репозитории. Команда разработки также планирует упростить реализацию Jakarta Data, переписав ее с использованием только стандартных API из JPA. В частности, команда планирует обратить внимание на <code>StatelessEntityManager</code>, не вошедший в 3.2, поскольку он очень остро необходим разработчикам, которые сейчас вынуждены прибегать к нестандартным возможностям Hibernate. </p><p>В идеальном мире у разработчиков должна быть возможность реализовывать Jakarta Data поверх JPA без необходимости вызывать какие-либо нестандартные возможности внутренней реализации JPA. </p><p>Jakarta Data должна сама по себе поддерживать <code>stateful persistence</code> контексты, а это по сути означает новый API.</p><p> В дополнение к аннотациям <code>@Add, @Insert, @Update и @Delete</code> теперь понадобятся также <code>@Persist, @Merge, @Remove, @Refresh, @Lock</code>, чтобы моделировать жизненный цикл сущности, который задается JPA, и таким образом обойти стороной упомянутую в начале статьи путаницу. Будут предоставлены оба способа, но очень важно четко говорить о том, что они имеют разную семантику. Цель команды состоит в том, чтобы уменьшить эту дистанцию. В настоящее время существуют запрос-методы, базирующиеся на параметрах, которые очень ограничены в некоторых смыслах, и с другой стороны имеется также JDQL. В настоящее время команда смотрит и расследует, какие есть способы уменьшить дистанцию между ними.</p><p>Далее мы быстро пробежимся по существующим способам и идеям, чтобы увидеть, как они выглядят на практике. </p><pre><code class="java">package devoxx;

import ...

@Repository
interface Library {

// 	@Find
// 	Book book(String isbn);

// 	@Find
// 	Optional&lt;Book&gt; bookWithTitle(String title);

// 	@Query("from Book where title like ?! order by title")
// 	List&lt;Book&gt; books(String title);

// 	@Find
//	Author author (@Nonnull String ssn);

//	@Find Author author(String name_first, String name_last);

// 	@Save
// 	void upsert (Book book);

}</code></pre><p>Это всего лишь интерфейс с аннотацией. Обработчик аннотаций от Hibernate генерирует CDI бин <code>@RequestScoped</code>.</p><pre><code class="java">@RequestScoped
@Generated("org.hibernate.processor.HibernateProcessor")
public class Library. implements Library {

protected @Nonnull StatelessSession session;

public Library_(@Nonnull StatelessSession session) {
  this.session = session;
}

public @Nonnull StatelessSession session() {
  return session;
}

@PersistenceUnit
private EntityManagerFactory sessionFactory;

@PostConstruct
private void openSession() { 
  session = sessionFactory.unwrap(SessionFactory.class).openStatelessSession(); 
}

@PreDestroy
private void closeSession() { session.close(); }

@Inject
Library_ { }

}</code></pre><p>Что он сгенерирует в вашем случае, сильно зависит от библиотек, которые находятся у вас в <em>classpath</em>. Если бы здесь в пути сборки был, например, Quarkus, то сгенерировался бы несколько иной код, который работал бы с Quarkus. Как мы видим, в приведенном коде инжектируется <code>StatelessSession</code>. И, собственно,на этом все. </p><p>Далее, добавим очень простой метод <code>find()</code> (по факту, раскомментируем нужный нам метод в приведенном выше коде).</p><pre><code class="java">package devoxx;

import ...

@Repository
interface Library {

 	@Find
 	Book book(String isbn);

// 	@Find
// 	Optional&lt;Book&gt; bookWithTitle(String title);

// 	@Query("from Book where title like ?! order by title")
// 	List&lt;Book&gt; books(String title);

// 	@Find
//	Author author (@Nonnull String ssn);

//	@Find Author author(String name_first, String name_last);

// 	@Save
// 	void upsert (Book book);

}</code></pre><p>Он находит объект типа <code>Book</code> по полю <code>isbn</code>. И вы можете видеть, что сгенерированный код действительно прост в понимании.</p><pre><code class="java">public class Library_ implements Library {

    /**
     * Find {@link Book} by {@link Book#isbn isbn}.
     *
     * @see devoxx.Library#book (String)
     **/
    @Override
    public Book book(@Nonnull String isbn) {

        if (isbn == null) throw new IllegalArgumentException("Null isbn");

        try {
            var _result = session.get(Book.class, isbn);
            if (result == null) throw new EmptyResultException("No 'Book' for given id (" + isbn + "]",
                    new ObjectNotFoundException((Object) isbn, "devoxx.Book"));
            return _result;

        } catch (PersistenceException exception) {

            throw new DataException(exception.getMessage(), exception);

        }
    }

    protected @Nonnull StatelessSession session;

    public Library_(@Nonnull StatelessSession session) {
        this.session = session;
    }

    public @Nonnull StatelessSession session() {
        return session;
    }
}</code></pre><p>Это то, что вы написали бы вручную. Возможно, ваш код был бы несколько опрятнее Существует конверсия исключений, которую вы возможно не стали бы писать, если бы писали это самостоятельно. Но в остальном это всего лишь <code>session.get(Book.class, isbn);</code>.  Вы легко можете понять этот код, он не мешает вам наслаждаться вашим Hibernate. По факту вы можете взять этот метод, скопировать его, вставить его в интерфейс библиотеки, добавить <code>default</code>, и это будет работать без дальнейших изменений.</p><p>Теперь проверим, что произойдет, если поменять написание имени этого параметра на неправильное? </p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/8c8/e97/4b7/8c8e974b73d49e6ebe482eedbddcf908.png" height="526" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/8c8/e97/4b7/8c8e974b73d49e6ebe482eedbddcf908.png" width="915"/></figure><p>Как и следовало ожидать, появится сообщение: <em>“no matching field named ‘isb’ in entity class ‘devoxx.Book’”</em> (Отсутствует поле с соответствующим именем ‘isb’ в классе сущности ‘devoxx.Book’).</p><p>А что случится, если дать параметру неправильный тип? Сделаем его <code>long</code>. </p><p>Получаем сообщение <em>“Matching field has type ‘java.lang.String’”</em> (соответствующее поле имеет тип ‘‘java.lang.String’)</p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/20c/800/7c6/20c8007c6244b05cb4ad5ff5087c1e9f.png" height="515" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/20c/800/7c6/20c8007c6244b05cb4ad5ff5087c1e9f.png" width="903"/></figure><p>Сообщение об ошибке даже говорит нам, какой тип следует использовать. Намного лучше, чем получить эту ошибку при запуске приложения или при прогоне тестов.</p><p>Можно сделать и больше. Допустим, мы хотим найти книгу по ее заголовку. Если мы не уверены, что книга с таким заголовком существует, мы можем вернуть <code>Optional</code>.</p><pre><code class="java">package devoxx;

import ...

@Repository
interface Library {

    @Find
    Book book(String isbn);

    @Find
    Optional&lt;Book&gt; bookWithTitle(String title);

// 	@Query("from Book where title like ?! order by title")
// 	List&lt;Book&gt; books(String title);

// 	@Find
//	Author author (@Nonnull String ssn);

//	@Find Author author(String name_first, String name_last);

// 	@Save
// 	void upsert (Book book);

}</code></pre><p>В этот раз мы запускаем запрос по критериям, и можно сказать, что этот код немного страшноват, но, если вы посмотрите на него внимательно, это всего лишь запрос по критериям, который вы запустили бы вручную, используя JPA. </p><pre><code class="java">@Override
public Optional&lt;Book&gt; bookWithTitle(@Nonnull String title) {

    if (title == null) throw new IllegalArgumentException("Null title");

    var _builder = session.getFactory().getCriteriaBuilder();
    var _query = _builder.createQuery(Book.class);
    var _entity = _query.from(Book.class);

    _query.where(
            _builder.equal(_entity.get(Book_.title), title)
    );

    try {
        return session.createSelectionQuery(_query).uniqueResultOptional();
    } catch (PersistenceException exception) {
        throw new DataException(exception.getMessage(), exception);
    }
}</code></pre><p>В этом коде есть нечто, что необходимо исправить. Это использование <code>equal()</code>.  Обычно, когда вы хотите найти книгу по ее заголовку, вы хотите получить какие-то <em>wildcards</em> или что-то наподобие. Вы хотите использовать паттерн поиска, и в качестве временной меры в Hibernate, пока Jakarta Data не выпустит стандартное решение, можно использовать аннотацию <code>@Pattern</code>: </p><pre><code class="java">@Find
Optional&lt;Book&gt; bookWithTitle(@Pattern String title);</code></pre><p>Теперь, если мы посмотрим на реализацию, она будет использовать операцию <code>like</code> вместо <code>equal</code>.</p><pre><code class="java">_query.where(
_builder.like(_entity.get(Book_.title), title)
);</code></pre><p>Теперь рассмотрим пример с аннотацией <code>@Query</code>. Раскомментируем его в нашем примере:</p><pre><code class="java">package devoxx;

import ...

@Repository
interface Library {

	@Find
	Book book(String isbn);

	@Find
	Optional&lt;Book&gt; bookWithTitle(String title);

 	@Query("from Book where title like ?! order by title")
 	List&lt;Book&gt; books(String title);

// 	@Find
//	Author author (@Nonnull String ssn);

//	@Find Author author(String name_first, String name_last);

// 	@Save
// 	void upsert (Book book);

}</code></pre><p>Здесь используется простой запрос, ищущий книгу с заголовком, который удовлетворяет операции <code>like</code> по отношению к искомой строке. </p><p>Обратим также внимание на маленькую особенность. Jakarta Data не требует, чтобы вы писали <code>“from Book”</code> в теле запроса. Вы можете написать:</p><pre><code class="java">@Query("where title like ?! order by title")
List&lt;Book&gt; books(String title);</code></pre><p>Тип <code>Book</code> здесь неявно определяется возвращаемым типом метода. К сожалению, IntelliJ в текущем релизе просто не знает об это и выдает ошибку. Будем надеяться, что очень скоро это поправят. Hibernate же полностью принимает этот код. </p><p>Посмотрим еще раз на то, что произойдет, если неправильно написать имя сущности. IntelliJ, конечно, укажет на это, но во время компиляции будет также получено сообщение об ошибке от Hibernate.</p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/f51/f13/ae1/f51f13ae16bc872b3e735d7aaaa3ded4.png" height="392" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/f51/f13/ae1/f51f13ae16bc872b3e735d7aaaa3ded4.png" width="919"/></figure><p>Если неправильно написать атрибут, опять же  IntelliJ это поймает, но то же самое сделает и процессор:</p><figure class="full-width"><img data-src="https://habrastorage.org/getpro/habr/upload_files/34f/c9f/a22/34fc9fa220e79b0b77b82618ff4561ac.png" height="398" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/34f/c9f/a22/34fc9fa220e79b0b77b82618ff4561ac.png" width="895"/></figure><p>Код реализации приводится ниже:</p><pre><code class="java">@Override
public List&lt;Book&gt; books(String title) {
    try {
        return session.createSelectionQuery(BOOKS_String, Book.class)
                .setParameter(1, title)
                .getResultList();
    } catch (PersistenceException exception) {
        throw new DataException(exception.getMessage(), exception);
    }
}</code></pre><p>Опять-таки, код полностью прозрачен. Это именно такой же код, который вы написали бы сами. </p><p>Если необходимо сослаться на поле в составе поля через базирующийся на параметрах метод запроса, можно сделать это через синтаксис, основанный на символах подчеркивания. Раскомментируем еще один пример:</p><pre><code class="java">package devoxx;

import ...

@Repository
interface Library {

    @Find
    Book book(String isbn);

    @Find
    Optional&lt;Book&gt; bookWithTitle(String title);

    @Query("from Book where title like ?! order by title")
    List&lt;Book&gt; books(String title);

// 	@Find
//	Author author (@Nonnull String ssn);

    @Find Author author(String name_first, String name_last);

// 	@Save
// 	void upsert (Book book);

}</code></pre><p>Сгенерированный код запроса, основанного на критериях, будет выглядеть следующим образом:</p><pre><code class="java">@Override
public Author author(String name$first, String name$last) {
    var _builder = session.getFactory().getCriteriaBuilder();
    var _query = _builder.createQuery(Author.class);
    var _entity = _query.from(Author.class);
    _query.where(
            name$first == null
                    ? _entity.get(Author_.name).get(Name_.first).isNull()
                    : _builder.equal(_entity.get(Author_.name).get(Name_.first), name$first),
            name$last == null
                    ? _entity.get(Author_.name).get(Name_.last).isNull()
                    : _builder.equal(_entity.get(Author_.name).get(Name_.last), name$last));
    try {
        return session.createSelectionQuery(_query).getSingleResult();
    } catch (NoResultException exception) {
        throw new EmptyResultException(exception.getMessage(), exception);
    } catch (NonUniqueResultException exception) {
        throw new jakarta.data.exceptions.NonUniqueResultException(exception.getMessage(), exception);
    }
}</code></pre><p>Как вы можете видеть, он содержит многочисленные символы подчеркивания, как, например, в этой строке:</p><pre><code class="java">_entity.get(Author_.name).get(Name_.first).isNull()</code></pre><p>Этот способ, возможно, не идеален, но он полностью типобезопасен, и в случае появления несоответствия Hibernate обязательно его заметит и укажет нам на ошибку. </p><p>Если говорить об операциях обновления данных, они, как правило, тривиальны. В качестве примера посмотрим на операцию <code>save()</code>. Раскомментируем соответствующие строки в нашем примере:</p><pre><code class="java">package devoxx;

import ...

@Repository
interface Library {

	@Find
	Book book(String isbn);

	@Find
	Optional&lt;Book&gt; bookWithTitle(String title);

 	@Query("from Book where title like ?! order by title")
 	List&lt;Book&gt; books(String title);

// 	@Find
//	Author author (@Nonnull String ssn);

	@Find 
    Author author(String name_first, String name_last);

 	@Save
 	void upsert (Book book);

}</code></pre><p>Операция <code>save()</code> присутствует в Jakarta Data наряду с <code>insert()</code>, <code>update()</code> и <code>delete()</code>, и логика ее примерно следующая:  <em>“вставьте вот этот объект, если его пока нет в базе данных или обновите его, если он существует”</em> </p><pre><code class="java">@Override
public void upsert(@Nonnull Book book) {
    if (book == null) throw new IllegalArgumentException("Null book");
    try {
        session.upsert(book);
    } catch (StaleStateException exception) {
        throw new OptimisticLockingFailureException(exception.getMessage(), exception);
    } catch (PersistenceException exception) {
        throw new DataException(exception.getMessage(), exception);
    }
}</code></pre><p>Таким образом, это маппируется на <em>stateless</em> сессию <code>upsert()</code>.</p><p>А вот еще одна интересная возможность.</p><pre><code class="java">package devoxx;

import ...

@Repository
interface Library {

	@Find
	Book book(String isbn);

	@Find
	Optional&lt;Book&gt; bookWithTitle(String title);

 	@Query("from Book where title like ?! order by title")
 	List&lt;Book&gt; books(String title);

 	@Find
	Author author(@Nonnull String ssn);

	@Find 
    Author author(String name_first, String name_last);

 	@Save
 	void upsert (Book book);

}</code></pre><p>В случае с уже рассмотренными операциями чтения, Hibernate рассуждал таким образом - <code>isbn</code> является первичным ключом, и, соответственно не может быть <code>null</code>. Поэтому там бросалось исключение. Заголовок же является обязательным полем, поэтому он тоже не может отсутствовать. И если написать подобный запрос для автора (<code>Author</code>) и его <code>social security number (ssn)</code>, который не объявлен как <em>non-nullable</em> поле.</p><pre><code class="java">@Find
Author author (String ssn);</code></pre><p>Тогда вы увидите, что Hibernate замечает тот факт, что это поле может являться <code>null</code> и примет <code>null</code> аргумент.  </p><pre><code class="java">@Override
public Author author(String ssn) {

    var _builder = session.getFactory().getCriteriaBuilder();
    var _query = _builder.createQuery(Author.class);
    var _entity = _query.from(Author.class);

    _query.where(
        ssn == null //Hibernate принимает аргумент null 
            ? _entity.get(Author_.ssn).isNull()
            : _builder.equal(_entity.get(Author_.ssn), ssn)
    );

    try {
        return session.createSelectionQuery(_query)
                      .getSingleResult();
    }
}</code></pre><p>Если же вы хотите, чтобы здесь тоже было <code>Nonnull</code>, вы можете воспользоваться аннотацией <code>@Nonnull</code> от Jakarta. </p><pre><code class="java">@Find
Author author (@Nonnull String ssn);</code></pre><p>И для этого случая тоже будет сгенерирован корректный код. </p><pre><code class="java">@Override
public Author author(@Nonnull String ssn) {

    if (ssn == null) throw new IllegalArgumentException("Null ssn"); //Hibernate отказывается принимать аргумент null
    var _builder = session.getFactory().getCriteriaBuilder();
    var _query = _builder.createQuery(Author.class);
    var _entity = _query.from(Author.class);
    _query.where(
        _builder.equal(_entity.get(Author_.ssn), ssn)
    );
}</code></pre><figure class="full-width"><img data-src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/5fd/388/92f/5fd38892fb3e4b89b881f0b93c384eb8.png" height="334" src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/5fd/388/92f/5fd38892fb3e4b89b881f0b93c384eb8.png" width="1560"/></figure><p>Присоединяйтесь к русскоязычному сообществу разработчиков на Spring Boot в телеграм — <a href="https://t.me/+oBwACbkvJ19iODAy">Spring АйО</a>, чтобы быть в курсе последних новостей из мира разработки на Spring Boot и всего, что с ним связано.</p><p></p></div></div></div><!-- --><!-- --></div><!-- --><!-- --></div><!--]--><!-- --><div class="tm-article-presenter__meta" data-test-id="article-meta-links"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[java]"><span>java</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[kotlin]"><span>kotlin</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-tags-list__link" href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[jakarta]"><span>jakarta</span></a><!--]--></li><!--]--><!-- --></ul></div><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/companies/spring_aio/articles/"><!--[--><span>Блог компании Spring АйО</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/hubs/programming/"><!--[--><span>Программирование</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/hubs/java/"><!--[--><span>Java</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a class="tm-hubs-list__link" href="/ru/hubs/kotlin/"><!--[--><span>Kotlin</span><!--]--></a><!--]--></li><!--]--><!-- --></ul></div></div><!-- --><!--]--></article><!--]--></div><!-- --></div><div class="tm-article-sticky-panel" data-test-id="article-sticky-panel" style=""><div class="tm-data-icons tm-data-icons tm-data-icons_space-big tm-article-sticky-panel__icons" data-test-id="article-stats-icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon tm-votes-meter__icon_appearance-article" height="24" width="24"><title>Всего голосов 14: ↑14 и ↓0</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-rating"></use></svg><span class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating tm-votes-meter__value" data-test-id="votes-meter-value" title="Всего голосов 14: ↑14 и ↓0">+14</span></div><!--teleport start--><!--teleport end--><!-- --></div><!-- --><!-- --><button class="bookmarks-button tm-data-icons__item" title="Добавить в закладки" type="button"><span class="tm-svg-icon__wrapper bookmarks-button__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Добавить в закладки</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-favorite"></use></svg></span><span class="bookmarks-button__counter" title="Количество пользователей, добавивших публикацию в закладки">58</span></button><div class="tm-sharing tm-data-icons__item" title="Поделиться"><button class="tm-sharing__button" type="button"><svg class="tm-sharing__icon" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z" fill="currentColor"></path></svg></button><!--teleport start--><!--teleport end--></div><div class="tm-article-comments-counter-link tm-data-icons__item" title="Читать комментарии"><a class="tm-article-comments-counter-link__link" data-test-id="counter-comments" href="/ru/companies/spring_aio/articles/872830/comments/"><!--[--><svg class="tm-svg-img tm-article-comments-counter-link__icon" height="24" width="24"><title>Комментарии</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value">9</span><!--]--></a><!-- --></div><!--[--><!--[--><!--[--><!-- --><!--]--><!--]--><!--]--><!--teleport start--><!--teleport end--><!-- --></div></div></div><!--[--><!--]--><div class="tm-article-presenter__footer"><!--[--><!--[--><div class="tm-article-blocks"><!-- --><!--[--><section class="tm-block tm-block tm-block_spacing-bottom"><!-- --><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-balanced"><!--[--><div class="tm-article-author" data-test-id="article-author-info"><!--[--><!--[--><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a class="tm-company-snippet__logo-link" href="/ru/companies/spring_aio/profile/"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" height="40" src="//habrastorage.org/getpro/habr/company/8f1/91a/458/8f191a4584b8fab12d15af23e447a1d5.png" width="40"/></div></a><div class="tm-company-snippet__info"><a class="tm-company-snippet__title" data-test-id="company-title" href="/ru/companies/spring_aio/profile/"><span>Spring АйО</span></a><div class="tm-company-snippet__description">Компания</div></div></div><div class="tm-article-author__buttons"><!-- --><!-- --></div></div><div class="tm-article-author__company-contacts"><!--[--><a class="tm-article-author__contact" href="https://telegram.me/spring_aio" rel="noopener" target="_blank">Telegram</a><a class="tm-article-author__contact" href="https://www.springnow.ru" rel="noopener" target="_blank">Сайт</a><!--]--></div><div class="tm-article-author__separator"></div></div><!--]--><!--]--><div class="tm-user-card tm-user-card tm-user-card_variant-article tm-article-author__user-card" data-async-called="true"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a class="tm-user-card__userpic tm-user-card__userpic_size-40" href="/ru/users/spring_aio/"><div class="tm-entity-image"><img alt="" class="tm-entity-image__pic" src="//habrastorage.org/getpro/habr/avatars/8e0/5e8/a1c/8e05e8a1c5fd4560f661efb2cb00e77e.png"/></div></a><div class="tm-user-card__meta"><div class="tm-counter-container tm-karma tm-karma" title=" 85 голосов "><div class="tm-counter-container__header"><!--[--><div class="karma-display positive" data-v-7635202e="">45</div><!-- --><!--]--></div><div class="tm-counter-container__footer"><!--[--><div class="tm-karma__text">Карма</div><!--teleport start--><!--teleport end--><!--]--></div></div><div class="tm-counter-container" title="Рейтинг пользователя"><div class="tm-counter-container__header"><!--[--><!--[--><!--]--><div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating"><!-- --><div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score_no-margin tm-votes-lever__score"><!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">105.9</span></span><!--]--></div><!-- --></div><!--]--></div><div class="tm-counter-container__footer"><!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]--></div></div></div></div></div><div class="tm-user-card__info tm-user-card__info_variant-article tm-user-card__info"><div class="tm-user-card__title tm-user-card__title_variant-article tm-user-card__title"><span class="tm-user-card__name tm-user-card__name_variant-article tm-user-card__name">Spring АйО</span><a class="tm-user-card__nickname tm-user-card__nickname tm-user-card__nickname_variant-article" href="/ru/users/spring_aio/"> @spring_aio</a><!-- --></div><p class="tm-user-card__short-info tm-user-card__short-info_variant-article tm-user-card__short-info" data-test-id="user-card-speciality">Главный по Spring</p></div></div><div class="tm-user-card__buttons tm-user-card__buttons_variant-article tm-user-card__buttons"><!-- --><div class="tm-user-card__button"><div class="tm-button-follow tm-user-card__button-follow"><!-- --><button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button></div></div><!-- --><div class="tm-user-card__button tm-user-card__button_write" data-test-id="user-card-conversations"><svg class="tm-svg-img tm-user-card__button-icon" height="16" width="16"><title>Отправить сообщение</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#mail"></use></svg></div><!-- --></div><!-- --></div><!-- --></div><!--]--></div><!--]--><!-- --></section><!-- --><!--[--><!--]--><!--]--><div class="tm-article-blocks__comments"><div class="tm-article-page-comments" id="publication-comments"><div><!--[--><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style" data-test-id="counter-comments" href="/ru/companies/spring_aio/articles/872830/comments/"><!--[--><svg class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted" height="24" width="24"><title>Комментарии</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted"> Комментарии 9 </span><!--]--></a><!-- --></div><!--]--></div></div></div><!--[--><!--[--><!--]--><section class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header tm-block__header_variant-borderless"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title tm-block__title_variant-large">Публикации</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-condensed-slim"><!--[--><!--[--><div class="tm-tabs tm-tabs"><div class=""><!--[--><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link_active tm-tabs__tab-link_slim tm-tabs__tab-link">Лучшие за сутки</button></span><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link_slim tm-tabs__tab-link">Похожие</button></span><!--]--></div><!-- --></div><div class="similar-and-daily__tab-view"><div class="placeholder-wrapper"><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><div class="tm-placeholder-article-cards"><!--[--><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><div class="tm-placeholder-article-card"><div class="tm-placeholder__user"><div class="tm-placeholder__user-pic loads"></div><div class="tm-placeholder__user-date loads"></div></div><div class="tm-placeholder-article-card__title"><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div><div class="tm-placeholder__line tm-placeholder-article-card__title-line loads"></div></div><div class="tm-placeholder-article-card__icons tm-placeholder__counters"><!--[--><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><div class="tm-placeholder-data-icon"><div class="tm-placeholder__icon tm-placeholder__icon_large loads"></div><div class="tm-placeholder__line tm-placeholder__line_icon-text"></div></div><!--]--></div></div><!--]--></div><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --><!-- --></div><!-- --></div><!--]--><!--]--></div><!--]--><!-- --></section><!--[--><!--]--><!-- --><!--[--><!--]--><!--]--></div><!--]--><!--]--></div></div><!--]--><!--]--></div></div><div class="tm-page__sidebar"><!--[--><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div><div class="tm-sexy-sidebar_initial tm-sexy-sidebar" style="margin-top:0px;"><!--[--><!--]--><!-- --><div class="tm-layout-sidebar__placeholder_initial"></div><!--[--><section class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Информация</h2><!--[--><!--]--></div><!-- --></header><!--[--><div class="tm-block__body tm-block__body"><!--[--><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">Сайт</dt><dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body"><!--[--><a class="tm-company-basic-info__link" href="https://t.me/spring_aio" target="_blank">t.me</a><!--]--></dd></dl><dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">Дата регистрации</dt><dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body"><!--[--><time datetime="2024-05-27T07:08:22.000Z" title="2024-05-27, 10:08">27  мая  2024</time><!--]--></dd></dl><!-- --><dl class="tm-description-list tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap tm-description-list__title">Численность</dt><dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap tm-description-list__body"><!--[-->11–30 человек<!--]--></dd></dl><!-- --><!-- --></div><!--]--></div><!--]--><!-- --></section><div class="tm-company-widgets"><!--[--><!--]--></div><!-- --><!-- --><!--]--><!-- --></div></div><!--]--></div></div><!-- --><!--]--></div></div></main><!-- --></div><div class="tm-footer-menu"><div class="tm-page-width"><!--[--><div class="tm-footer-menu__container"><!--[--><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Ваш аккаунт</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/companies/spring_aio/articles/872830/&amp;hl=ru" rel="nofollow" target="_self">Войти</a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/companies/spring_aio/articles/872830/&amp;hl=ru" rel="nofollow" target="_self">Регистрация</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Разделы</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/articles/">Статьи</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/news/">Новости</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/hubs/">Хабы</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/companies/">Компании</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/users/">Авторы</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/sandbox/">Песочница</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Информация</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/help/">Устройство сайта</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/authors/codex/">Для авторов</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/companies/corpblogs/">Для компаний</a></li><li class="tm-footer-menu__list-item"><a class="footer-menu__item-link" href="/ru/docs/docs/transparency/">Документы</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement/?hl=ru_RU" target="_blank">Соглашение</a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/?hl=ru_RU" target="_blank">Конфиденциальность</a></li><!--]--></ul></div></div><div class="tm-footer-menu__block"><p class="tm-footer-menu__block-title">Услуги</p><div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><!--[--><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/corporate-blogs/" target="_blank">Корпоративный блог</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/advertising/" target="_blank">Медийная реклама</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/native-special/" target="_blank">Нативные проекты</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/education-programs/" target="_blank">Образовательные программы</a></li><li class="tm-footer-menu__list-item"><a href="https://company.habr.com/ru/hello-startup/" target="_blank">Стартапам</a></li><!--]--></ul></div></div><!--]--></div><!--]--></div></div><div class="tm-footer"><div class="tm-page-width"><!--[--><div class="tm-footer__container"><!-- --><div class="tm-footer__social"><!--[--><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Facebook</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Twitter</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>VK</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-vk"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Telegram</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Youtube</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://dzen.ru/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Яндекс Дзен</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-dzen"></use></svg></a><!--]--></div><!--teleport start--><!--teleport end--><button class="tm-footer__link"><!-- --> Настройка языка</button><a class="tm-footer__link" href="/ru/feedback/">Техническая поддержка</a><div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2025, </span><span class="tm-copyright__name"><a class="tm-copyright__link" href="https://company.habr.com/" rel="noopener" target="_blank">Habr</a></span></span></div></div><!--]--></div></div><!-- --><!--]--></div><!-- --></div></div>
<div id="overlays"><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--><!-- --><!--teleport anchor--></div>
</body>
</html>
